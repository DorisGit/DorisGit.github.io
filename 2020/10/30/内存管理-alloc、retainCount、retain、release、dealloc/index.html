<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorisgit.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="接下来继续从源码角度，分析alloc、retainCount、retain、release、dealloc等方法的实现。 源码地址：https:&#x2F;&#x2F;opensource.apple.com&#x2F;tarballs&#x2F;objc4&#x2F; slowpath &amp; fastpath 宏定义如下： #define fastpath(x) (__builtin_expect(bool(x), 1)) #define">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理-alloc、retainCount、retain、release、dealloc">
<meta property="og:url" content="https://dorisgit.github.io/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-alloc%E3%80%81retainCount%E3%80%81retain%E3%80%81release%E3%80%81dealloc/index.html">
<meta property="og:site_name" content="泡泡茶壶">
<meta property="og:description" content="接下来继续从源码角度，分析alloc、retainCount、retain、release、dealloc等方法的实现。 源码地址：https:&#x2F;&#x2F;opensource.apple.com&#x2F;tarballs&#x2F;objc4&#x2F; slowpath &amp; fastpath 宏定义如下： #define fastpath(x) (__builtin_expect(bool(x), 1)) #define">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://dorisgit.github.io/Users/mikasa/Desktop/image_mark/202011032030.png">
<meta property="article:published_time" content="2020-10-30T02:32:42.000Z">
<meta property="article:modified_time" content="2020-11-17T07:58:41.875Z">
<meta property="article:author" content="Doris AI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dorisgit.github.io/Users/mikasa/Desktop/image_mark/202011032030.png">

<link rel="canonical" href="https://dorisgit.github.io/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-alloc%E3%80%81retainCount%E3%80%81retain%E3%80%81release%E3%80%81dealloc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>内存管理-alloc、retainCount、retain、release、dealloc | 泡泡茶壶</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泡泡茶壶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-alloc%E3%80%81retainCount%E3%80%81retain%E3%80%81release%E3%80%81dealloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          内存管理-alloc、retainCount、retain、release、dealloc
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-30 10:32:42" itemprop="dateCreated datePublished" datetime="2020-10-30T10:32:42+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-17 15:58:41" itemprop="dateModified" datetime="2020-11-17T15:58:41+08:00">2020-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>接下来继续从源码角度，分析<code>alloc</code>、<code>retainCount</code>、<code>retain</code>、<code>release</code>、<code>dealloc</code>等方法的实现。</p>
<p>源码地址：<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a></p>
<h3 id="slowpath-amp-fastpath"><a href="#slowpath-amp-fastpath" class="headerlink" title="slowpath &amp; fastpath"></a>slowpath &amp; fastpath</h3><blockquote>
<p>宏定义如下：</p>
<p>#define fastpath(x) (__builtin_expect(bool(x), 1))</p>
<p>#define slowpath(x) (__builtin_expect(bool(x), 0))</p>
</blockquote>
<p>他们都是用了__builtin_expect函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __builtin_expect(<span class="keyword">long</span> <span class="built_in">exp</span>, <span class="keyword">long</span> c);</span><br></pre></td></tr></table></figure>

<p><code>__builtin_expect()</code>函数是GCC提供给程序员是用的，由于大部分程序员在分支预测上都非常糟糕，所以GCC提供这个内建函数来帮助程序员处理分支预测，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。它的意思是: <code>exp == c</code>的概率很大。</p>
<p><code>fastpath(x)</code> 表示  <code>x</code> 是1的概率很大，<code>slowpath(x)</code>表示 <code>x</code> 是0的概率很大。它和if一起使用，<code>if (fastpath(x))</code>表示执行<code>if</code>语句的可能性大，<code>if (slowpath(x))</code>表示执行<code>if</code>语句的可能性小。</p>
<h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>alloc方法的函数调用栈</p>
<h4 id="callAlloc"><a href="#callAlloc" class="headerlink" title="callAlloc"></a>callAlloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="comment">// 调用[cls alloc] or [cls allocWithZone:nil]函数的时候会来到这里，使用适当的快捷方式优化</span></span><br><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">  	<span class="comment">// 校验（checkNil &amp; !cls）</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  	<span class="comment">// 如果cls没有实现默认的allocWithZone，调用_objc_rootAllocWithZone</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">  	<span class="comment">// 给cls 发送 allocWithZone:消息</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="keyword">@selector</span>(allocWithZone:), <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 否则发送alloc消息</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callAlloc()</code>函数主要执行了一下步骤：</p>
<ul>
<li>判断类有没有实现自定义的<code>allocWithZone</code>方法，如果没有，就调用<code>_objc_rootAllocWithZone</code>函数（快捷方式）</li>
<li>如果没有快捷方式，根据<code>allocWithZone</code>的值，true 给<code>cls</code>类发送<code>allocWithZone</code>消息，false则给<code>cls</code>类发送<code>alloc</code>消息</li>
</ul>
<h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Replaced by ObjectAlloc</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>allocWithZone</code>其实现也是调用<code>_objc_rootAllocWithZone</code>函数</p>
<h4 id="alloc-1"><a href="#alloc-1" class="headerlink" title="alloc"></a>alloc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootAlloc"><a href="#objc-rootAlloc" class="headerlink" title="_objc_rootAlloc"></a>_objc_rootAlloc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc</code>函数会调用<code>_objc_rootAlloc</code>函数，最终会再次来到<code>callAlloc</code>函数，传参不再进行nil检查</p>
<h4 id="objc-rootAllocWithZone"><a href="#objc-rootAllocWithZone" class="headerlink" title="_objc_rootAllocWithZone"></a>_objc_rootAllocWithZone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_class_createInstanceFromZone</code>函数，参数<code>zone</code>已经被忽略直接传nil</p>
<h4 id="class-createInstanceFromZone"><a href="#class-createInstanceFromZone" class="headerlink" title="_class_createInstanceFromZone"></a>_class_createInstanceFromZone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();<span class="comment">// 获取cls是否有构造函数</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();<span class="comment">// 获取cls是否有析构函数</span></span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();<span class="comment">// 获取cls是否进行了isa指针优化</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">		<span class="comment">// 获取需要申请的空间大小</span></span><br><span class="line">    <span class="built_in">size</span> = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = <span class="built_in">size</span>;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 如果zone为nil，调用malloc_zone_calloc申请内存空间</span></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (id)malloc_zone_calloc((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果内存空间申请失败，调用_objc_callBadAllocHandler</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 初始化 isa 如果 zone == nil &amp;&amp; isa进行了指针优化，调用initInstanceIsa</span></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">      	<span class="comment">// 否则使用initIsa进行初始化isa指针</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果没有构造函数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 进行构造函数处理，在返回</span></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数_class_createInstanceFromZone中，通过C函数calloc申请内存空间，并初始化对象的isa</p>
<h4 id="initInstanceIsa"><a href="#initInstanceIsa" class="headerlink" title="initInstanceIsa"></a>initInstanceIsa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    ASSERT(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initIsa"><a href="#initIsa" class="headerlink" title="initIsa"></a>initIsa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">  	&#x2F;&#x2F; 未开启isa指针优化，直接将isa指针指向cls类对象</span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa &#x3D; isa_t((uintptr_t)cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ASSERT(!DisableNonpointerIsa);</span><br><span class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA		&#x2F;&#x2F; 对于64位系统，该值为0</span><br><span class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">      	&#x2F;&#x2F; 设置nonpointer 和 magic值位1 和 1101</span><br><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">      	&#x2F;&#x2F; 设置是否有析构函数</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">      	&#x2F;&#x2F; 设置class&#x2F;meta-class对象</span><br><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This write must be performed in a single store in some cases</span><br><span class="line">        &#x2F;&#x2F; (for example when realizing a class because other threads</span><br><span class="line">        &#x2F;&#x2F; may simultaneously try to use the class).</span><br><span class="line">        &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to</span><br><span class="line">        &#x2F;&#x2F; guarantee memory order w.r.t. the class index table</span><br><span class="line">        &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation</span><br><span class="line">        isa &#x3D; newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于ISA指针，具体可见内存管理—ISA指针</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [[cls alloc] init].</span><br><span class="line">id</span><br><span class="line">objc_alloc_init(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return [callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;) init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span><br><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类的init方法什么都没有做，只是将alloc创建的对象返回。因为我们可以重写init方法做一些初始化操作。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calls [cls new]</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_opt_new(Class cls)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(cls &amp;&amp; !cls-&gt;ISA()-&gt;hasCustomCore())) &#123;</span><br><span class="line">        <span class="keyword">return</span> [callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>) init];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(new));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)new &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(<span class="keyword">self</span>, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new方法比较简单，只是嵌套了alloc和init</p>
<h3 id="copy-amp-mutableCopy"><a href="#copy-amp-mutableCopy" class="headerlink" title="copy &amp; mutableCopy"></a>copy &amp; mutableCopy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)copy &#123;</span><br><span class="line">    return [(id)self copyWithZone:nil];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return (id)self;</span><br><span class="line">&#125;</span><br><span class="line">- (id)mutableCopy &#123;</span><br><span class="line">    return [(id)self mutableCopyWithZone:nil];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return (id)self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy和mutableCopy也很简单，只是调用了copyWithZone和mutableCopyWithZone方法。</p>
<h3 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h3><p>获取对象的引用计数器</p>
<h4 id="retainCount-1"><a href="#retainCount-1" class="headerlink" title="retainCount"></a>retainCount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return _objc_rootRetainCount(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRetainCount"><a href="#objc-rootRetainCount" class="headerlink" title="_objc_rootRetainCount"></a>_objc_rootRetainCount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_objc_rootRetainCount(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    return obj-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rootRetainCount"><a href="#rootRetainCount" class="headerlink" title="rootRetainCount"></a>rootRetainCount</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果是taggedpointer 直接返回this</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">  	<span class="comment">// 获取isa指针</span></span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">  	<span class="comment">// 判断isa指针是否开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">      	<span class="comment">// 从extra_rc读取引用计数器 再 +1</span></span><br><span class="line">        uintptr_t rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">      	<span class="comment">// 判断是否使用sidetable额外存储引用计数器</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">  	<span class="comment">// isa指针不是nonpointer, 返回sidetable_retainCount函数获取到的值</span></span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sidetable-getExtraRC-nolock"><a href="#sidetable-getExtraRC-nolock" class="headerlink" title="sidetable_getExtraRC_nolock"></a>sidetable_getExtraRC_nolock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_t </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sidetable-retainCount"><a href="#sidetable-retainCount" class="headerlink" title="sidetable_retainCount"></a>sidetable_retainCount</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数sidetable_getExtraRC_nolock和函数sidetable_retainCount，均是通过哈希查找获取他们的引用计数器表。</p>
<p>不同的是：</p>
<ul>
<li>isa 是 nonpointer会调用sidetable_getExtraRC_nolock函数，它的引用计数器会存在两部分，一部分在isa_t的extra_rc，另一部分存在于SideTable中，不进行加锁</li>
<li>isa不是nonpointer会调用sidetable_retainCount函数，他的引用计数器之存在于SideTable中，需要加锁查找</li>
</ul>
<p>SideTable查找步骤：</p>
<ul>
<li>先根据对象的内存地址，经过哈希查找后从SideTables中获取到它所在的SideTable</li>
<li>再根据当前对象的内存地址，经过哈希查找从SideTable表中的refcnts中取出它的引用计数器表</li>
</ul>
<blockquote>
<p>小结：rootRetainCount函数</p>
<ul>
<li>在arm64之前，isa 不是 nonpointer 对象的引用计数器存储在SideTable中，rootRetainCount获取到的就是1 + SideTable中存储的值</li>
<li>arm64之后，isa如果是nonpointer 对象的引用计数器先存储在extra_rc中，如果19位extra_rc不够存储，你们溢出的部分在存储在SideTable中，rootRetainCount获取到的就是1+ extra_rc的值+SideTable的值</li>
<li>初始化情况下，通过rootRetainCount获取到的1，这是rootRetainCount的功劳，alloc并没有设置对象的引用计数器</li>
</ul>
</blockquote>
<p><strong>Q：alloc方法没有设置对象的引用计数为1，而且内部也没有调用<code>retainCount</code>方法，那<code>alloc</code>创建的对象不会因引用计数器为0，而直接被<code>dealloc</code>吗？</strong></p>
<p>A：dealloc方法是在release方法内部调用的，只有你直接调用了<code>dealloc</code>，或者调用了<code>release</code>方法且在release中判断对象的引用计数器是否为0，才会调用dealloc</p>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p>之前已经说过，持有对象的方式有两种，一种是<code>alloc/new/copy/mutableCopy</code>，一种是<code>retain</code>，<code>retain</code>会将对象的引用计数+1</p>
<h4 id="objc-retain"><a href="#objc-retain" class="headerlink" title="objc_retain"></a>objc_retain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if __OBJC2__</span><br><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">id objc_retain(id obj) &#123; return [obj retain]; &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>如果是<code>__OBJC2__</code>，则调用<code>objc_retain</code>，否则调用<code>retain</code></p>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(id) retain</span><br><span class="line">&#123;</span><br><span class="line">    return _objc_rootRetain(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRetain"><a href="#objc-rootRetain" class="headerlink" title="_objc_rootRetain"></a>_objc_rootRetain</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">id</span></span><br><span class="line">_objc_rootRetain(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRetain"><a href="#objc-object-rootRetain" class="headerlink" title="objc_object::rootRetain()"></a>objc_object::rootRetain()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Base retain implementation, ignoring overrides.</span><br><span class="line">&#x2F;&#x2F; This does not check isa.fast_rr; if there is an RR override then </span><br><span class="line">&#x2F;&#x2F; it was already called and it chose to call [super retain].</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; tryRetain&#x3D;true is the -_tryRetain path.</span><br><span class="line">&#x2F;&#x2F; handleOverflow&#x3D;false is the frameless fast path.</span><br><span class="line">&#x2F;&#x2F; handleOverflow&#x3D;true is the framed slow path including overflow to side table</span><br><span class="line">&#x2F;&#x2F; The code is structured this way to prevent duplication.</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    return rootRetain(false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRetain-bool-tryRetain-bool-handleOverflow"><a href="#objc-object-rootRetain-bool-tryRetain-bool-handleOverflow" class="headerlink" title="objc_object::rootRetain(bool tryRetain, bool handleOverflow)"></a>objc_object::rootRetain(bool tryRetain, bool handleOverflow)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">id</span> </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;<span class="comment">// 是否要将引用计数器存储在SideTable中</span></span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 不去检查isa指针是否fast_rr，因为我们可能会调用重载方法</span></span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">      	<span class="comment">// #   define RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line">      	<span class="comment">// 将引用计数器+1</span></span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">				</span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">          	<span class="comment">// 如果extra_rc上溢</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 设置extra_rc为RC_HALF，同时标记has_sidetable_rc</span></span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;<span class="comment">// #   define RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 如果需要 将溢出的引用计数器存储到sidetable中</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-retain"><a href="#objc-object-sidetable-retain" class="headerlink" title="objc_object::sidetable_retain()"></a>objc_object::sidetable_retain()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage &#x3D; table.refcnts[this];&#x2F;&#x2F; 获取当前引用计数</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; &#x2F;&#x2F; 获取到了 &amp; 未溢出</span><br><span class="line">        refcntStorage +&#x3D; SIDE_TABLE_RC_ONE;&#x2F;&#x2F; 将引用计数+1</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏定义信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The order of these bits is important.</span><br><span class="line">#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)		&#x2F;&#x2F; 标记对象是否有弱引用</span><br><span class="line">#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  	&#x2F;&#x2F; 标记对象是否正在deallocating</span><br><span class="line">#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  	&#x2F;&#x2F; 对象引用计数存储的开始位，引用计数存储在2～63位</span><br><span class="line">#define SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1)) &#x2F;&#x2F; 引用计数 </span><br><span class="line"></span><br><span class="line">#define SIDE_TABLE_RC_SHIFT 2</span><br><span class="line">#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span><br></pre></td></tr></table></figure>

<p>对象引用计数表<code>refcnts</code></p>
<p><img src="/Users/mikasa/Desktop/image_mark/202011032030.png" alt="img"></p>
<h4 id="rootRetain-overflow"><a href="#rootRetain-overflow" class="headerlink" title="rootRetain_overflow"></a>rootRetain_overflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE id </span><br><span class="line">objc_object::rootRetain_overflow(bool tryRetain)</span><br><span class="line">&#123;</span><br><span class="line">    return rootRetain(tryRetain, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果extra_rc存储满了，就会调用rootRetain_overflow，该函数调用了rootRetain，但参数handleOverflow传true</p>
<h4 id="sidetable-addExtraRC-nolock"><a href="#sidetable-addExtraRC-nolock" class="headerlink" title="sidetable_addExtraRC_nolock"></a>sidetable_addExtraRC_nolock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts to the side table from the isa field.</span></span><br><span class="line"><span class="comment">// Returns true if the object is now pinned.</span></span><br><span class="line"><span class="comment">// 将一些引用计数存储在sideTable表中</span></span><br><span class="line"><span class="keyword">bool</span> </span><br><span class="line">objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    size_t oldRefcnt = refcntStorage;</span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    size_t newRefcnt = </span><br><span class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        refcntStorage =</span><br><span class="line">            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        refcntStorage = newRefcnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>extra_rc</code>存储满了，就会调用<code>sidetable_addExtraRC_nolock</code>将<code>extra_rc</code>中的<code>RC_HALF(extra_rc满</code>值的一半)个引用计数转移到<code>sidetable</code>中存储，也是调用<code>addc</code>对<code>refcnt</code>引用计数表进行计数增加操作。</p>
<blockquote>
<p>小结：<code>retain</code>方法：</p>
<ul>
<li>如果<code>isa</code>不是<code>nonpointer</code>，那么就对<code>Sidetable</code>中的引用计数+1</li>
<li>如果isa是nonpointer，就对isa中的<code>extra_rc</code>存储的引用计数进行+1，如果溢出，就将extra_rc中<code>RC_HALF</code>(<code>extra_rc</code>满值的一半)个引用计数转移到<code>sidetable</code>中存储，从<code>rootRetain</code>函数中我们可以看到，如果<code>extra_rc</code>溢出，设置它的值为RC_HALF，这时候又对<code>sidetable</code>中的<code>refcnt</code>增加引用计数。<code>extra_rc</code>是<code>19</code>位，而<code>RC_HALF</code>宏是<code>(1ULL&lt;&lt;18)</code>，实际上相等于进行了 +1 操作</li>
</ul>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>当我们在不需要持有对象的时候，需要调用<code>release</code>方法进行释放，<code>release</code>会将对象的引用计数-1</p>
<h4 id="objc-release"><a href="#objc-release" class="headerlink" title="objc_release"></a>objc_release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span> objc_release(<span class="keyword">id</span> obj) &#123; [obj release]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="objc-object-release"><a href="#objc-object-release" class="headerlink" title="objc_object::release"></a>objc_object::release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::release()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        rootRelease();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(release));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果方法没有被重写，直接调用<code>rootRelease()</code>;，这是快捷方式，否则调用<code>release</code></p>
<h4 id="release-1"><a href="#release-1" class="headerlink" title="release"></a>release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)release</span><br><span class="line">&#123;</span><br><span class="line">    _objc_rootRelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRelease"><a href="#objc-rootRelease" class="headerlink" title="_objc_rootRelease"></a>_objc_rootRelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootRelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootRelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRelease"><a href="#objc-object-rootRelease" class="headerlink" title="objc_object::rootRelease"></a>objc_object::rootRelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base release implementation, ignoring overrides.</span></span><br><span class="line"><span class="comment">// Does not call -dealloc.</span></span><br><span class="line"><span class="comment">// Returns true if the object should now be deallocated.</span></span><br><span class="line"><span class="comment">// This does not check isa.fast_rr; if there is an RR override then </span></span><br><span class="line"><span class="comment">// it was already called and it chose to call [super release].</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// handleUnderflow=false is the frameless fast path.</span></span><br><span class="line"><span class="comment">// handleUnderflow=true is the framed slow path including side table borrow</span></span><br><span class="line"><span class="comment">// The code is structured this way to prevent duplication.</span></span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootReleaseShouldDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">      	<span class="comment">// 不是nonpointer</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">          	<span class="comment">// 如果是meta-class直接return</span></span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">          	<span class="comment">// 调用sidetable_release函数</span></span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">      	<span class="comment">// subc函数对extra_rc--</span></span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">      	<span class="comment">// 如果extra_rc已经溢出了</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don't ClearExclusive()</span></span><br><span class="line">          	<span class="comment">// 执行underflow处理下溢</span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line"> <span class="comment">// 处理下溢</span></span><br><span class="line"> underflow:</span><br><span class="line">    <span class="comment">// newisa.extra_rc-- underflowed: borrow from side table or deallocate</span></span><br><span class="line">		<span class="comment">// 出现extra_rc-- 下溢，sidetable移除或者dealloc对象</span></span><br><span class="line">    <span class="comment">// abandon newisa to undo the decrement</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line">		<span class="comment">// 如果has_sidetable_rc 为true</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">      	<span class="comment">// 没有出现下溢</span></span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">          	<span class="comment">// 执行rootRelease_underflow函数</span></span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></span><br><span class="line">				<span class="comment">// 引用计数从sidetable转移到extra_rc中存储</span></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Need to start over to avoid a race against </span></span><br><span class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 尝试从sidetable中删除一些引用计数，传入RC_HALF，borrowed为实际删除的引用计数</span></span><br><span class="line">        <span class="comment">// Try to remove some retain counts from the side table.        </span></span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line">      </span><br><span class="line">				<span class="comment">// 为了避免竞争，has_sidetable_rc必须设置，即使现在sidetable中的引用计数已经是0了</span></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Side table retain count decreased.</span></span><br><span class="line">            <span class="comment">// Try to add them to the inline count.</span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">          	<span class="comment">// 存储失败，再试一次</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 如果还是失败，就将引用计数重新保存在sidetable中</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed.</span></span><br><span class="line">                <span class="comment">// Put the retains back in the side table.</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果引用计数器为0 dealloc对象</span></span><br><span class="line">    <span class="comment">// Really deallocate.</span></span><br><span class="line">		<span class="comment">// 如果当前对象处于deallocating，保证对象只会deallocating一次</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 设置isa处于deallocating状态</span></span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">  	<span class="comment">// 如果存储失败 继续重试</span></span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line">		<span class="comment">// 如果performDealloc==true,给对象发送一条dealloc消息</span></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-release"><a href="#objc-object-sidetable-release" class="headerlink" title="objc_object::sidetable_release"></a>objc_object::sidetable_release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rdar://20206767</span></span><br><span class="line"><span class="comment">// return uintptr_t instead of bool so that the various raw-isa </span></span><br><span class="line"><span class="comment">// -release paths all return zero in eax</span></span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 设置是否需要执行do_dealloc标记，默认不需要</span></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 获取当前对象是否正在执行deallocating</span></span><br><span class="line">    auto it = table.refcnts.try_emplace(<span class="keyword">this</span>, SIDE_TABLE_DEALLOCATING);</span><br><span class="line">  	<span class="comment">// 获取refcnt</span></span><br><span class="line">    auto &amp;refcnt = it.first-&gt;second;</span><br><span class="line">    <span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">      	<span class="comment">// 如果对象处于deallocating状态</span></span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        refcnt |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;<span class="comment">// 如果引用计数器还有值，作计数器-1</span></span><br><span class="line">        refcnt -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">  	<span class="comment">// 如果对象正在作dealloc 和 performDealloc，对当前对象发送dealloc消息</span></span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>isa</code>不是<code>nonpointer</code>，那么就对<code>SideTable</code>中引用计数-1，如果引用计数为0，发送<code>dealloc</code>消息</p>
<h4 id="subc"><a href="#subc" class="headerlink" title="subc"></a>subc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE uintptr_t </span><br><span class="line">subc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)</span><br><span class="line">&#123;</span><br><span class="line">    return __builtin_subcl(lhs, rhs, carryin, carryout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>subc</code> 就是 <code>addc</code>反向操作，用来减少引用计数</p>
<h4 id="objc-object-rootRelease-underflow"><a href="#objc-object-rootRelease-underflow" class="headerlink" title="objc_object::rootRelease_underflow"></a>objc_object::rootRelease_underflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::rootRelease_underflow(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">    return rootRelease(performDealloc, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>extra_rc</code>下溢，就会调用<code>rootRelease_underflow</code>，该函数会再次调用<code>rootRelease</code>，但是参数<code>handleUnderflow</code>传true</p>
<h4 id="objc-object-sidetable-subExtraRC-nolock"><a href="#objc-object-sidetable-subExtraRC-nolock" class="headerlink" title="objc_object::sidetable_subExtraRC_nolock"></a>objc_object::sidetable_subExtraRC_nolock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts from the side table to the isa field.</span></span><br><span class="line"><span class="comment">// Returns the actual count subtracted, which may be less than the request.</span></span><br><span class="line"><span class="comment">// 尝试从sidetable中移动一些引用计数到isa中，返回真实移动的数量，有可能比请求移动的要少</span></span><br><span class="line">size_t </span><br><span class="line">objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 获取refcnts</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="comment">// 如果当前refcnts为空，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()  ||  it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Side table retain count is zero. Can't borrow.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t oldRefcnt = it-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 减少引用计数器</span></span><br><span class="line">    size_t newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class="line">    ASSERT(oldRefcnt &gt; newRefcnt);  <span class="comment">// shouldn't underflow</span></span><br><span class="line">    it-&gt;second = newRefcnt;</span><br><span class="line">    <span class="keyword">return</span> delta_rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sidetable_subExtraRC_nolock</code>函数将引用计数器转移到<code>isa</code>指针的<code>extra_rc</code>中，有可能比请求要移动的少。</p>
<h4 id="objc-object-overrelease-error"><a href="#objc-object-overrelease-error" class="headerlink" title="objc_object::overrelease_error"></a>objc_object::overrelease_error</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::overrelease_error()</span><br><span class="line">&#123;</span><br><span class="line">    _objc_inform_now_and_on_crash(<span class="string">"%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug"</span>, object_getClassName((<span class="keyword">id</span>)<span class="keyword">this</span>), <span class="keyword">this</span>);</span><br><span class="line">    objc_overrelease_during_dealloc_error();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// allow rootRelease() to tail-call this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前对象正处于dealloc状态，再次release机会执行overrelease_error，该函数用于处理过度调用release的时候使用。</p>
<blockquote>
<p><strong>小结：release方法</strong></p>
<p>如果isa不是nonpointer,那么直接对sidetable中的引用计数-1，如果引用计数==0，调用dealloc</p>
<p>如果isa是nonpointer，就将当前extra_rc存储的引用计数器-1，如果下溢，即extra_rc中的引用计数器为0了，判断has_sidetable_rc是否为true，即是否使用的sidetable进行引用计数存储，如果有的话就申请从Sidetable中申请RC_HALF个引用计数转移到extra_rc中存储，如果不足RC_HALF就有多少转移多少，然后将Sitetable中的引用计数减去RC_HALF（或者实际转移数量）将实际申请的引用计数器-1后存储在extra_rc中，如果extra_rc中引用计数器为0了而且has_sidetable_rc 为false或者sitetable中的引用计数器也为0了，你们就发送dealloc消息</p>
</blockquote>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><h4 id="objc-autorelease"><a href="#objc-autorelease" class="headerlink" title="objc_autorelease"></a>objc_autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">id</span> objc_autorelease(<span class="keyword">id</span> obj) &#123; <span class="keyword">return</span> [obj autorelease]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果是<code>__OBJC2__</code>，则调用autorelease函数，否则调用autorelease方法</p>
<h4 id="objc-object-autorelease"><a href="#objc-object-autorelease" class="headerlink" title="objc_object::autorelease"></a>objc_object::autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) <span class="keyword">return</span> rootAutorelease();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该方法没有被重写，直接调用objc_object::rootAutorelease，这是快捷方式；否则调用autorelease方法。</p>
<h4 id="objc-object-autorelease-1"><a href="#objc-object-autorelease-1" class="headerlink" title="objc_object::autorelease"></a>objc_object::autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootAutorelease2"><a href="#objc-object-rootAutorelease2" class="headerlink" title="objc_object::rootAutorelease2"></a>objc_object::rootAutorelease2</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数中调用了<code>AutoreleasePoolPage</code>中<code>autorelease</code>方法</p>
<h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><h4 id="dealloc-1"><a href="#dealloc-1" class="headerlink" title="dealloc"></a>dealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootDealloc"><a href="#objc-rootDealloc" class="headerlink" title="_objc_rootDealloc"></a>_objc_rootDealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootDealloc"><a href="#objc-object-rootDealloc" class="headerlink" title="objc_object::rootDealloc"></a>objc_object::rootDealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  <span class="comment">// 判断是否有弱引用</span></span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  				 <span class="comment">// 判断是否有关联对象</span></span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  		 <span class="comment">// 没有c++析构函数</span></span><br><span class="line">                 !isa.has_sidetable_rc))		 <span class="comment">// 没有使用sidetable进行引用计数存储</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">      	<span class="comment">// 直接使用free销毁对象</span></span><br><span class="line">        free(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 调用object_dispose函数</span></span><br><span class="line">        object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">object_dispose(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);   <span class="comment">// 调用 objc_destructInstance 函数</span></span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);<span class="comment">// 如果有c++析构函数，调用object_cxxDestruct</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);<span class="comment">// 如果有关联对象，移除关联对象</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-clearDeallocating"><a href="#objc-object-clearDeallocating" class="headerlink" title="objc_object::clearDeallocating"></a>objc_object::clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果 isa 不是 nonpointer</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果 isa 是 nonpointer 或者 isa.has_sidetable_rc == true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-clearDeallocating"><a href="#objc-object-sidetable-clearDeallocating" class="headerlink" title="objc_object::sidetable_clearDeallocating"></a>objc_object::sidetable_clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_object::sidetable_clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 获取SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear any weak table items</span></span><br><span class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></span><br><span class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 获取弱引用散列表</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">      	<span class="comment">// 当前对象是否有弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 调用table.refcnts.erase从引用计数器中</span></span><br><span class="line">        table.refcnts.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-clearDeallocating-slow"><a href="#objc-object-clearDeallocating-slow" class="headerlink" title="objc_object::clearDeallocating_slow"></a>objc_object::clearDeallocating_slow</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Slow path of clearDeallocating() </span></span><br><span class="line"><span class="comment">// for objects with nonpointer isa</span></span><br><span class="line"><span class="comment">// that were ever weakly referenced </span></span><br><span class="line"><span class="comment">// or whose retain count ever overflowed to the side table.</span></span><br><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 是否有弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">      	<span class="comment">// 清理弱引用指针</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果有has_sidetable_rc</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">      	<span class="comment">// 调用table.refcnts.erase从引用计数器中</span></span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结：dealloc方法</strong></p>
<ul>
<li><p>判断条件（1、isa 为nonpointer; 2、没有弱引用；3、没有关联对象；4、没有c++析构函数；5、没有额外使用sidetable进行引用计数器存储）是否成立，均成立的话，使用free函数直接销毁对象，否则调用object_dispose做一些释放对象前的处理</p>
</li>
<li><p>如果有C++析构函数，调用<code>object_cxxDestruct</code>;</p>
</li>
<li><p>如果有关联对象，<code>_object_remove_assocations</code>移除关联对象</p>
</li>
<li><p>如果有弱引用，调用<code>weak_clear_no_lock</code>将指向该对象的弱引用指针置为nil</p>
</li>
<li><p>如果有使用sidetable进行引用计数器存储，调用<code>table.refcnts.erase</code>从引用计数表中擦除该对于的引用计数</p>
</li>
<li><p>调用<code>free</code>函数销毁对象</p>
<p>根据dealloc过程，<code>__weak</code>修饰符的变量在对象被<code>dealloc</code>时，会将该<code>weak</code>置为nil。可见，如果大量使用<code>weak</code>变量的话，是会消耗CPU的资源，所以建议只在需要避免循环引用的时候使用<code>weak</code>修饰符。</p>
</li>
</ul>
</blockquote>
<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><h4 id="清除weak"><a href="#清除weak" class="headerlink" title="清除weak"></a>清除weak</h4><p>以上从dealloc方法实现我们知道了对象在dealloc的时候，会调用weak_clear_no_lock函数将指向该对象的弱引用指针置为nil</p>
<h4 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the </span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 获取weak指向的地址，即当掐对象的地址</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">		<span class="comment">// 找到管理weak_entry_t的容器</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 判断弱引用是否超出定长</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">      	<span class="comment">// 获取entry中的referrers，referrers是一个数组，存储所有指向referent_id的指针</span></span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">      	<span class="comment">// 弱引用数组长度</span></span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果是使用的定长存储</span></span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历弱引用数组，将所有指向referent_id的指针置为nil</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将entry从弱引用表中移除</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结：清除weak</strong></p>
<p>当一个对象销毁是，在<code>dealloc</code>方法内部经过一系列的函数调用栈，通过二次哈希查找，第一次根据对象的地址找到它所在的<code>sidetable</code>，第二次根据对象的地址在Sidetable的<code>weak_table</code>中找打它的弱引用表。弱引用表中存储的是对象的地址（作为<code>key</code>）和weak指针地址的数组（作为<code>value</code>）的映射。<code>weak_clear_no_lock</code>函数中遍历弱引用数组，将指向该对象的地址的<code>weak</code>变量全部置为nil</p>
</blockquote>
<h3 id="添加weak"><a href="#添加weak" class="headerlink" title="添加weak"></a>添加weak</h3><p>一个被声明未__weak的指针，在经过编译之后，通过<code>objc_initWeak</code>函数初始化附有<code>weak</code>修饰符的变量，在变量作用域结束时，通过<code>objc_destroyWeak</code>函数销毁该变量。</p>
<h4 id="objc-moveWeak"><a href="#objc-moveWeak" class="headerlink" title="objc_moveWeak"></a>objc_moveWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Move a weak pointer from one location to another.</span></span><br><span class="line"><span class="comment"> * Before the move, the destination must be uninitialized.</span></span><br><span class="line"><span class="comment"> * After the move, the source is nil.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to either weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_moveWeak(<span class="keyword">id</span> *dst, <span class="keyword">id</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    objc_copyWeak(dst, src);</span><br><span class="line">    objc_destroyWeak(src);</span><br><span class="line">    *src = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-copyWeak"><a href="#objc-copyWeak" class="headerlink" title="objc_copyWeak"></a>objc_copyWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function copies a weak pointer from one location to another,</span></span><br><span class="line"><span class="comment"> * when the destination doesn't already contain a weak pointer. It</span></span><br><span class="line"><span class="comment"> * would be used for code like:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  __weak id src = ...;</span></span><br><span class="line"><span class="comment"> *  __weak id dst = src;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the destination variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param dst The destination variable.</span></span><br><span class="line"><span class="comment"> * @param src The source variable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_copyWeak(<span class="keyword">id</span> *dst, <span class="keyword">id</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = objc_loadWeakRetained(src);</span><br><span class="line">    objc_initWeak(dst, obj);</span><br><span class="line">    objc_release(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Initialize a fresh weak pointer to some object location. </span></span><br><span class="line"><span class="comment"> * It would be used for code like: </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (The nil case) </span></span><br><span class="line"><span class="comment"> * __weak id weakPtr;</span></span><br><span class="line"><span class="comment"> * (The non-nil case) </span></span><br><span class="line"><span class="comment"> * NSObject *o = ...;</span></span><br><span class="line"><span class="comment"> * __weak id weakPtr = o;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param location Address of __weak ptr. </span></span><br><span class="line"><span class="comment"> * @param newObj Object ptr. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)<span class="comment">// location为__weak指针地址，newObj为对象地址</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果对象为nil，那就将__weak指针置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update a weak variable.</span></span><br><span class="line"><span class="comment">// If HaveOld is true, the variable has an existing value </span></span><br><span class="line"><span class="comment">//   that needs to be cleaned up. This value might be nil.</span></span><br><span class="line"><span class="comment">// If HaveNew is true, there is a new value that needs to be </span></span><br><span class="line"><span class="comment">//   assigned into the variable. This value might be nil.</span></span><br><span class="line"><span class="comment">// If CrashIfDeallocating is true, the process is halted if newObj is </span></span><br><span class="line"><span class="comment">//   deallocating or newObj's class does not support weak references. </span></span><br><span class="line"><span class="comment">//   If CrashIfDeallocating is false, nil is stored instead.</span></span><br><span class="line"><span class="comment">// 更新weak变量</span></span><br><span class="line"><span class="comment">// 如果 HaveOld == true，表示变量有旧值，这个值可能为nil</span></span><br><span class="line"><span class="comment">// 如果 HaveNew == true，表示一个新值需要赋值给变量，这个新值可能是nil</span></span><br><span class="line"><span class="comment">// 如果 CrashIfDeallocating == true，表示对象正在销毁 或者 对象不支持弱引用，则停止更新</span></span><br><span class="line"><span class="comment">// 如果 CrashIfDeallocating == false，则存储nil</span></span><br><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) ASSERT(newObj == <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    SideTable *oldTable;<span class="comment">// 旧表，用来存放已有的weak变量</span></span><br><span class="line">    SideTable *newTable;<span class="comment">// 新表，用来存放新的weak变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// 存在旧值，获取旧值对象 和旧值所在的弱引用表</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在新值，创建新表</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 对旧值 新值 分别加锁</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">		<span class="comment">// 判断旧值 和 location指向的值是否相等，即是否同一对象，如果不是就重新获取旧值相关联的对象和表</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="comment">// 存在新值</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">      	<span class="comment">// 判断新值所属的类是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">          	<span class="comment">// 未初始化，先进行初始化，防止 +initialize 内部调用 storeWeak 产生死锁</span></span><br><span class="line">            class_initialize(cls, (<span class="keyword">id</span>)newObj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this class is finished with +initialize then we're good.</span></span><br><span class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">            <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">            <span class="comment">// 标记类已经进行初始化检查</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="comment">// 如果存在旧值，调用weak_unregister_no_lock进行清理</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="comment">// 存在新值，调用weak_register_no_lock方法，将所有weak指针重新指向新的对象</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line">				<span class="comment">// 如果存储成功</span></span><br><span class="line">      	<span class="comment">// 如果对象是 taggedPointer，不做操作</span></span><br><span class="line">      	<span class="comment">// 如果isa 不是 nonpointer,设置Sidetable中弱引用标志位</span></span><br><span class="line">      	<span class="comment">// 如果isa 是 nonpointer，设置isa 的 weakly_referenced弱引用标志位</span></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">      	<span class="comment">// 将location指向新的对象</span></span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：<code>storeWeak</code>函数执行过程：</strong></p>
<ul>
<li>分别获取新旧值相关联的弱引用表；</li>
<li>如果有旧值，就调用<code>weak_unregister_no_lock</code>进行清理</li>
<li>如果有新值，就调用<code>weak_register_no_lock</code>函数分配新值，将所有<code>weak</code>指针重新指向新的对象；</li>
<li>判断<code>isa</code>是否为<code>nonpointer</code> 来设置弱引用标志位，如果不是<code>nonponinter</code>，设置<code>SideTable</code>中的弱引用标志位，否则设置<code>isa</code>的<code>weakly_referenced</code>弱引用标志位。</li>
</ul>
</blockquote>
<h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registers a new (object, weak pointer) pair. Creates a new weak</span></span><br><span class="line"><span class="comment"> * object entry if it does not exist.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object pointed to by the weak reference.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;<span class="comment">// 对象</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;<span class="comment">// 弱引用指针</span></span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 判断对象是否为nil &amp;&amp; 是否是taggedPointer指针，如果是 直接返回当前对象</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">  	<span class="comment">// 确保对象是可用的</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">  	<span class="comment">// 判断当前对象是否正在deallocating</span></span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 当前对象是否支持弱引用</span></span><br><span class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </span><br><span class="line">                                           <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// allowsWeakReference 函数获取的其实就是当前对象! [self _isDeallocating]; </span></span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 正在执行deallocating 不可使用weak指针</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">  	<span class="comment">// 获取弱引用entry</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">  	<span class="comment">// 如果当前entry存在，指向将weak指针追加进去</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果当前entry不存在，先创建一个新的entry，将新的entry存储到weak_table中</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：weak_register_no_lock用于保存弱引用信息，具体实现如下：</strong></p>
<ul>
<li>判断对象是否正在释放，是否支持弱引用，如果实例对象<code>allowsWeakReference</code>返回NO，表明对象正在执行<code>deallocating</code> 不可使用weak指针</li>
<li>查询<code>weak_table</code>表，判断引用表中是否已经保存与对象相关联的弱引用信息；</li>
<li>如果已经有相关弱引用信息，则调用<code>append_referrer</code>函数将弱引用信息添加进现有的entry容器中；如果没有相关联信息，则创建一个<code>entry</code>，判断<code>weak_table</code>是否需要扩容（大小超过<code>3/4，进行2倍扩</code>容），将<code>entry</code>插入到弱引用表中。</li>
</ul>
</blockquote>
<h4 id="weak-unregister-no-lock-1"><a href="#weak-unregister-no-lock-1" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unregister an already-registered weak reference.</span></span><br><span class="line"><span class="comment"> * This is used when referrer's storage is about to go away, but referent</span></span><br><span class="line"><span class="comment"> * isn't dead yet. (Otherwise, zeroing referrer later would be a</span></span><br><span class="line"><span class="comment"> * bad memory access.)</span></span><br><span class="line"><span class="comment"> * Does nothing if referent/referrer is not a currently active weak reference.</span></span><br><span class="line"><span class="comment"> * Does not zero referrer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * FIXME currently requires old referent value to be passed in (lame)</span></span><br><span class="line"><span class="comment"> * FIXME unregistration should be automatic if referrer is collected</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                        <span class="keyword">id</span> *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 是否存在与当前对象相关联的弱引用表</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">      	<span class="comment">// 从entry中移除弱引用指针referrer</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 判断是否超出定长（4），out_of_line_ness为2标记还是通过inline_referrers存储</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 判断inline_referrers中是否存在weak信息</span></span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：<code>weak_unregister_no_lock</code>函数用来移除弱引用信息，具体实现如下：</p>
<ul>
<li>查询<code>weak_table</code>表，获取与当前对象相关联的弱引用信息；</li>
<li>如果有，调用<code>remove_referrer</code>移除相关弱引用信息；接着判断数组是否为空，如果为空，调用<code>weak_entry_remove</code>移除<code>entry</code></li>
</ul>
</blockquote>
<h4 id="objc-destroyWeak"><a href="#objc-destroyWeak" class="headerlink" title="objc_destroyWeak"></a>objc_destroyWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Destroys the relationship between a weak pointer</span></span><br><span class="line"><span class="comment"> * and the object it is referencing in the internal weak</span></span><br><span class="line"><span class="comment"> * table. If the weak pointer is not referencing anything, </span></span><br><span class="line"><span class="comment"> * there is no need to edit the weak table. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param location The weak pointer address. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_destroyWeak(<span class="keyword">id</span> *location)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="keyword">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_initWeak</code> 和 objc_destroyWeak 函数中都调用了storeWeak，但是传入的参数不同</p>
<ul>
<li><code>objc_initWeak</code>将对象地址传入，且DontHaveOld，DoHaveNew，DoCrashIfDeallocating</li>
<li>objc_destroyWeak将nil传入，且DontHaveOld，DoHaveNew，DoCrashIfDeallocating</li>
</ul>
<p>storeWeak函数将参数二的赋值的对象地址作为key，将参数一的附有__weak修饰符的变量的地址注册到weak表中。如果参数二为nil，则将变量的地址从weak表中删除。</p>
<blockquote>
<p><strong>小结：添加`weak</strong>`</p>
<p>一个被标记为<code>weak</code>的指针，在经过编译之后会调用<code>objc_copyWeak</code>函数，在<code>objc_copyWeak</code>函数中调用<code>objc_initWeak</code>函数，<code>objc_initWeak</code>函数中初始化weak变量后调用<code>storeWeak</code>函数。添加weak的过程如下：</p>
<ul>
<li>经过一系列的调用栈，最终在<code>weak_register_no_lock</code>函数中，进行弱引用变量的添加，具体添加的位置是通过哈希算法来查找的，如果对应位置已经存在当前对象的弱引用表（数组），直接将弱引用变量添加进入，如果不存在弱引用表，先创建弱引用表，再判断是否需要对<code>weak_table</code>进行扩容，然后再将弱引用变量添加进去。</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">内存管理方法</th>
<th align="left">具体实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">alloc</td>
<td align="left">经过一系列的函数调用栈，最终通过调用 C 函数<code>calloc</code>来申请内存空间，并初始化对象的<code>isa</code>，但并没有设置对象的引用计数值为 1。</td>
</tr>
<tr>
<td align="left">init</td>
<td align="left">基类的<code>init</code>方法啥都没干，只是将<code>alloc</code>创建的对象返回。我们可以重写<code>init</code>方法来对<code>alloc</code>创建的实例做一些初始化操作。</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left"><code>new</code>方法很简单，只是嵌套了<code>alloc</code>和<code>init</code>。</td>
</tr>
<tr>
<td align="left">copy、mutableCopy</td>
<td align="left">调用了<code>copyWithZone</code>和<code>mutableCopyWithZone</code>方法。</td>
</tr>
<tr>
<td align="left">retainCount</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，引用计数值 = <code>SideTable</code>中的引用计数表中存储的值 + 1； ② 如果<code>isa</code>是<code>nonpointer</code>，引用计数值 = <code>isa</code>中的<code>extra_rc</code>存储的值 + 1 +<code>SideTable</code>中的引用计数表中存储的值。</td>
</tr>
<tr>
<td align="left">retain</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，就对<code>Sidetable</code>中的引用计数进行 +1； ② 如果<code>isa</code>是<code>nonpointer</code>，就将<code>isa</code>中的<code>extra_rc</code>存储的引用计数进行 +1，如果溢出，就将<code>extra_rc</code>中<code>RC_HALF</code>（<code>extra_rc</code>满值的一半）个引用计数转移到<code>sidetable</code>中存储。</td>
</tr>
<tr>
<td align="left">release</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，就对<code>Sidetable</code>中的引用计数进行 -1，如果引用计数 =0，就<code>dealloc</code>对象； ② 如果<code>isa</code>是<code>nonpointer</code>，就将<code>isa</code>中的<code>extra_rc</code>存储的引用计数进行 -1。如果下溢，即<code>extra_rc</code>中的引用计数已经为 0，判断<code>has_sidetable_rc</code>是否为<code>true</code>即是否有使用<code>Sidetable</code>存储。如果有的话就申请从<code>Sidetable</code>中申请<code>RC_HALF</code>个引用计数转移到<code>extra_rc</code>中存储，如果不足<code>RC_HALF</code>就有多少申请多少，然后将<code>Sidetable</code>中的引用计数值减去<code>RC_HALF</code>（或是小于<code>RC_HALF</code>的实际值），将实际申请到的引用计数值 -1 后存储到<code>extra_rc</code>中。如果<code>extra_rc</code>中引用计数为 0 且<code>has_sidetable_rc</code>为<code>false</code>或者<code>Sidetable</code>中的引用计数也为 0 了，那就<code>dealloc</code>对象。</td>
</tr>
<tr>
<td align="left">dealloc</td>
<td align="left">① 判断销毁对象前有没有需要处理的东西（如弱引用、关联对象、<code>C++</code>的析构函数、<code>SideTabel</code>的引用计数表等等）； ② 如果没有就直接调用<code>free</code>函数销毁对象； ③ 如果有就先调用<code>object_dispose</code>做一些释放对象前的处理（置弱引用指针置为<code>nil</code>、移除关联对象、<code>object_cxxDestruct</code>、在<code>SideTabel</code>的引用计数表中擦出引用计数等等），再用<code>free</code>函数销毁对象。</td>
</tr>
<tr>
<td align="left">清除<code>weak</code>，<code>weak</code>指针置为<code>nil</code>的过程</td>
<td align="left">当一个对象被销毁时，在<code>dealloc</code>方法内部经过一系列的函数调用栈，通过两次哈希查找，第一次根据对象的地址找到它所在的<code>Sidetable</code>，第二次根据对象的地址在<code>Sidetable</code>的<code>weak_table</code>中找到它的弱引用表。遍历弱引用数组，将指向对象的地址的<code>weak</code>变量全都置为<code>nil</code>。</td>
</tr>
<tr>
<td align="left">添加<code>weak</code></td>
<td align="left">经过一系列的函数调用栈，最终在<code>weak_register_no_lock()</code>函数当中，进行弱引用变量的添加，具体添加的位置是通过哈希算法来查找的。如果对应位置已经存在当前对象的弱引用表（数组），那就把弱引用变量添加进去；如果不存在的话，就创建一个弱引用表，然后将弱引用变量添加进去。</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-ISA/" rel="prev" title="内存管理-ISA & Weak底层">
      <i class="fa fa-chevron-left"></i> 内存管理-ISA & Weak底层
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/17/iOS%E2%80%94%E2%80%94KVC%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" rel="next" title="iOS——KVC相关总结">
      iOS——KVC相关总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#slowpath-amp-fastpath"><span class="nav-number">1.</span> <span class="nav-text">slowpath &amp; fastpath</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc"><span class="nav-number">2.</span> <span class="nav-text">alloc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#callAlloc"><span class="nav-number">2.1.</span> <span class="nav-text">callAlloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allocWithZone"><span class="nav-number">2.2.</span> <span class="nav-text">allocWithZone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-1"><span class="nav-number">2.3.</span> <span class="nav-text">alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-rootAlloc"><span class="nav-number">2.4.</span> <span class="nav-text">_objc_rootAlloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-rootAllocWithZone"><span class="nav-number">2.5.</span> <span class="nav-text">_objc_rootAllocWithZone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-createInstanceFromZone"><span class="nav-number">2.6.</span> <span class="nav-text">_class_createInstanceFromZone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initInstanceIsa"><span class="nav-number">2.7.</span> <span class="nav-text">initInstanceIsa</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initIsa"><span class="nav-number">2.8.</span> <span class="nav-text">initIsa</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init"><span class="nav-number">3.</span> <span class="nav-text">init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new"><span class="nav-number">4.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-amp-mutableCopy"><span class="nav-number">5.</span> <span class="nav-text">copy &amp; mutableCopy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#retainCount"><span class="nav-number">6.</span> <span class="nav-text">retainCount</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#retainCount-1"><span class="nav-number">6.1.</span> <span class="nav-text">retainCount</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-rootRetainCount"><span class="nav-number">6.2.</span> <span class="nav-text">_objc_rootRetainCount</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rootRetainCount"><span class="nav-number">6.3.</span> <span class="nav-text">rootRetainCount</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sidetable-getExtraRC-nolock"><span class="nav-number">6.3.1.</span> <span class="nav-text">sidetable_getExtraRC_nolock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sidetable-retainCount"><span class="nav-number">6.3.2.</span> <span class="nav-text">sidetable_retainCount</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#retain"><span class="nav-number">7.</span> <span class="nav-text">retain</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-retain"><span class="nav-number">7.1.</span> <span class="nav-text">objc_retain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retain-1"><span class="nav-number">7.2.</span> <span class="nav-text">retain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-rootRetain"><span class="nav-number">7.3.</span> <span class="nav-text">_objc_rootRetain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-rootRetain"><span class="nav-number">7.4.</span> <span class="nav-text">objc_object::rootRetain()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-rootRetain-bool-tryRetain-bool-handleOverflow"><span class="nav-number">7.5.</span> <span class="nav-text">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-sidetable-retain"><span class="nav-number">7.6.</span> <span class="nav-text">objc_object::sidetable_retain()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rootRetain-overflow"><span class="nav-number">7.7.</span> <span class="nav-text">rootRetain_overflow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sidetable-addExtraRC-nolock"><span class="nav-number">7.8.</span> <span class="nav-text">sidetable_addExtraRC_nolock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#release"><span class="nav-number">8.</span> <span class="nav-text">release</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-release"><span class="nav-number">8.1.</span> <span class="nav-text">objc_release</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-release"><span class="nav-number">8.2.</span> <span class="nav-text">objc_object::release</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#release-1"><span class="nav-number">8.3.</span> <span class="nav-text">release</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-rootRelease"><span class="nav-number">8.4.</span> <span class="nav-text">_objc_rootRelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-rootRelease"><span class="nav-number">8.5.</span> <span class="nav-text">objc_object::rootRelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-sidetable-release"><span class="nav-number">8.6.</span> <span class="nav-text">objc_object::sidetable_release</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subc"><span class="nav-number">8.7.</span> <span class="nav-text">subc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-rootRelease-underflow"><span class="nav-number">8.8.</span> <span class="nav-text">objc_object::rootRelease_underflow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-sidetable-subExtraRC-nolock"><span class="nav-number">8.9.</span> <span class="nav-text">objc_object::sidetable_subExtraRC_nolock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-overrelease-error"><span class="nav-number">8.10.</span> <span class="nav-text">objc_object::overrelease_error</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autorelease"><span class="nav-number">9.</span> <span class="nav-text">autorelease</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-autorelease"><span class="nav-number">9.1.</span> <span class="nav-text">objc_autorelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-autorelease"><span class="nav-number">9.2.</span> <span class="nav-text">objc_object::autorelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-autorelease-1"><span class="nav-number">9.3.</span> <span class="nav-text">objc_object::autorelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-rootAutorelease2"><span class="nav-number">9.4.</span> <span class="nav-text">objc_object::rootAutorelease2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dealloc"><span class="nav-number">10.</span> <span class="nav-text">dealloc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dealloc-1"><span class="nav-number">10.1.</span> <span class="nav-text">dealloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-rootDealloc"><span class="nav-number">10.2.</span> <span class="nav-text">_objc_rootDealloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-rootDealloc"><span class="nav-number">10.3.</span> <span class="nav-text">objc_object::rootDealloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object-dispose"><span class="nav-number">10.4.</span> <span class="nav-text">object_dispose</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-destructInstance"><span class="nav-number">10.5.</span> <span class="nav-text">objc_destructInstance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-clearDeallocating"><span class="nav-number">10.6.</span> <span class="nav-text">objc_object::clearDeallocating</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-sidetable-clearDeallocating"><span class="nav-number">10.7.</span> <span class="nav-text">objc_object::sidetable_clearDeallocating</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object-clearDeallocating-slow"><span class="nav-number">10.8.</span> <span class="nav-text">objc_object::clearDeallocating_slow</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak"><span class="nav-number">11.</span> <span class="nav-text">weak</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#清除weak"><span class="nav-number">11.1.</span> <span class="nav-text">清除weak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-clear-no-lock"><span class="nav-number">11.2.</span> <span class="nav-text">weak_clear_no_lock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加weak"><span class="nav-number">12.</span> <span class="nav-text">添加weak</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-moveWeak"><span class="nav-number">12.1.</span> <span class="nav-text">objc_moveWeak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-copyWeak"><span class="nav-number">12.2.</span> <span class="nav-text">objc_copyWeak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-initWeak"><span class="nav-number">12.3.</span> <span class="nav-text">objc_initWeak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#storeWeak"><span class="nav-number">12.4.</span> <span class="nav-text">storeWeak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-unregister-no-lock"><span class="nav-number">12.5.</span> <span class="nav-text">weak_unregister_no_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-unregister-no-lock-1"><span class="nav-number">12.6.</span> <span class="nav-text">weak_unregister_no_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-destroyWeak"><span class="nav-number">12.7.</span> <span class="nav-text">objc_destroyWeak</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">13.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doris AI</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doris AI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
