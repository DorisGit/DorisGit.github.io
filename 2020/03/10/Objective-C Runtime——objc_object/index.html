<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorisgit.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Object-c中我们知道，所有类均继承自NSObject，那么NSObject具体是什么呢？ objc_object123456@interface NSObject &lt;NSObject&gt; &amp;#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&amp;q">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C Runtime——objc_object">
<meta property="og:url" content="https://dorisgit.github.io/2020/03/10/Objective-C%20Runtime%E2%80%94%E2%80%94objc_object/index.html">
<meta property="og:site_name" content="泡泡茶壶">
<meta property="og:description" content="Object-c中我们知道，所有类均继承自NSObject，那么NSObject具体是什么呢？ objc_object123456@interface NSObject &lt;NSObject&gt; &amp;#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&amp;q">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/23_7.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/image-20200311232447574.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/23_8.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/23_9.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/23-10.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/23-11.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/image-20200311164228160.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/image-20200311170751822.png">
<meta property="og:image" content="http://q6luryr3j.bkt.clouddn.com/23.12.png">
<meta property="article:published_time" content="2020-03-10T08:36:42.000Z">
<meta property="article:modified_time" content="2020-03-12T14:43:14.141Z">
<meta property="article:author" content="Doris AI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://q6luryr3j.bkt.clouddn.com/23_7.png">

<link rel="canonical" href="https://dorisgit.github.io/2020/03/10/Objective-C%20Runtime%E2%80%94%E2%80%94objc_object/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Objective-C Runtime——objc_object | 泡泡茶壶</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泡泡茶壶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/10/Objective-C%20Runtime%E2%80%94%E2%80%94objc_object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Objective-C Runtime——objc_object
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-10 16:36:42" itemprop="dateCreated datePublished" datetime="2020-03-10T16:36:42+08:00">2020-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-12 22:43:14" itemprop="dateModified" datetime="2020-03-12T22:43:14+08:00">2020-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Object-c中我们知道，所有类均继承自NSObject，那么NSObject具体是什么呢？</p>
<h3 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直观看到的是NSObject类中只有一个类型为Class的isa指针，那么我们重点关注一下Class类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; initIsa() should be used to init the isa of new objects only.</span><br><span class="line">    &#x2F;&#x2F; If this object already has an isa, use changeIsa() for correctness.</span><br><span class="line">    &#x2F;&#x2F; initInstanceIsa(): objects with no custom RR&#x2F;AWZ</span><br><span class="line">    &#x2F;&#x2F; initClassIsa(): class objects</span><br><span class="line">    &#x2F;&#x2F; initProtocolIsa(): protocol objects</span><br><span class="line">    &#x2F;&#x2F; initIsa(): other objects</span><br><span class="line">    void initIsa(Class cls &#x2F;*nonpointer&#x3D;false*&#x2F;);</span><br><span class="line">    void initClassIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">    void initProtocolIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">    void initInstanceIsa(Class cls, bool hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line">  </span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>objc_object结构体中包含一个<code>isa_t</code>类型的结构体isa，而<code>objc_class</code>继承自<code>objc_object</code>，表明<code>objc_class</code>也会包含isa_t类型的结构体isa。</p>
<p>objc_class除了isa之外还有三个成员，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法列表。</p>
<p>![image-20200310221249637](/Users/mikasa/Library/Application Support/typora-user-images/image-20200310221249637.png)</p>
<p>当对象的实例方法被调用时，会通过isa找到对应的Class，然后在该类的bits中查找对应的方法，<code>bits.data()</code>获取类对象的数据区域，在该区域中可以查找对应的方法和对应的实现。</p>
<p>当类的类方法被调用时，会通过isa找到对应的元类（meta-class）,查找方法的机制与对象一致</p>
<p>总结：</p>
<p>对象方法被调用时，通过对象的isa在类中获取方法的实现</p>
<p>类方法被调用时，通过类的isa在元类中获取方法的实现</p>
<h3 id="Meta-Class"><a href="#Meta-Class" class="headerlink" title="Meta-Class"></a><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">Meta-Class</a></h3><p>每个类都会有一个单独的meta-class，meta-class中存储着这个类的所有方法</p>
<blockquote>
<p>The meta-class, like the <code>Class</code> before it, is also an object. This means that you can invoke methods on it too. Naturally, this means that it must also have a class.</p>
<p>All meta-classes use the base class’ meta-class (the meta-class of the top <code>Class</code> in their inheritance hierarchy) as their class. This means that for all classes that descend from <code>NSObject</code> (most classes), the meta-class has the <code>NSObject</code> meta-class as its class.</p>
<p>Following the rule that all meta-classes use the base class’ meta-class as their class, any base meta-classes will be its own class (their <code>isa</code> pointer points to themselves). This means that the <code>isa</code> pointer on the <code>NSObject</code> meta-class points to itself (it is an instance of itself).</p>
</blockquote>
<p>This means that the <code>isa</code> pointer on the <code>NSObject</code> meta-class points to itself (it is an instance of itself).这也意味着NSObject元类上的isa指针指向着元类它自己</p>
<p>如下对应图，描述了基类、元类、对象三者之间的关系</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23_7.png" alt="23_7"></p>
<p>添加代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)clickCell_1 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]);</span><br><span class="line">    </span><br><span class="line">    Class currentClass &#x3D; [self class];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;%@ the isa pointer %d times gives %p&quot;, currentClass,i, currentClass);</span><br><span class="line">        currentClass &#x3D; object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;NSObject&#39;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&#39;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This object is 0x7fa88fd05280.</span><br><span class="line">Class is MMViewController, and super is MMBaseViewController.</span><br><span class="line">MMViewController the isa pointer 1 times gives 0x10087daf0</span><br><span class="line">MMViewController the isa pointer 2 times gives 0x10087db18</span><br><span class="line">NSObject the isa pointer 3 times gives 0x1027e61d8</span><br><span class="line">NSObject the isa pointer 4 times gives 0x1027e61d8</span><br><span class="line"></span><br><span class="line">NSObject&#39;s class is 0x1027e6200</span><br><span class="line">NSObject&#39;s meta class is 0x1027e61d8</span><br></pre></td></tr></table></figure>

<ol>
<li>基类（NSObject）没有超类，所以基类的supperClass指向nil</li>
<li>每个Class都有唯一的isa指针指向meta-class，意味着每个类都有自己唯一的方法列表，同时意味着每个类对象本身并不是同一个类</li>
<li>meta-class的supperClass指向NSObject，形成回路</li>
<li>每个meta-class的isa指针都指向基类的meta-class，基类的meta-class的isa指针也指向自身</li>
</ol>
<p>objc_object关系图：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image-20200311232447574.png" alt="image-20200311232447574"></p>
<h3 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t"></a>isa_t</h3><p>isa_t是一个union联合体，联合体的所有成员会占用同一段内存，修改一个成员会影响其余所有成员，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Objc_object结构体中三个初始化个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void initIsa(Class cls &#x2F;*nonpointer&#x3D;false*&#x2F;);</span><br><span class="line">void initClassIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">void initProtocolIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">void initInstanceIsa(Class cls, &#x2F;*nonpointer&#x3D;true*&#x2F;bool hasCxxDtor);</span><br></pre></td></tr></table></figure>

<p>最终都会调到<code>objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa.cls &#x3D; cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line">        isa &#x3D; newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SUPPORT_INDEXED_ISA</p>
<blockquote>
<p>表示 isa_t 中存放的 Class 信息是 Class 的地址，还是一个索引(根据该索引可在类信息表中查找该类结构地址)。经测试，iOS 设备上 SUPPORT_INDEXED_ISA 是 0。 </p>
</blockquote>
<p>ISA_MAGIC_VALUE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                      \</span><br><span class="line">      uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">      uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">      uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">      uintptr_t deallocating      : 1;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">      uintptr_t extra_rc          : 19</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line"></span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                        \</span><br><span class="line">      uintptr_t nonpointer        : 1;                                         \</span><br><span class="line">      uintptr_t has_assoc         : 1;                                         \</span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                         \</span><br><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                         \</span><br><span class="line">      uintptr_t weakly_referenced : 1;                                         \</span><br><span class="line">      uintptr_t deallocating      : 1;                                         \</span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                         \</span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</span><br></pre></td></tr></table></figure>

<p>has_cxx_dtor</p>
<blockquote>
<p>表示对象是否有C++或者Objc的析构器</p>
</blockquote>
<p>has_assoc</p>
<blockquote>
<p>对象含有或者曾经含有关联音乐，没有关联引用的可以更快的释放内存</p>
</blockquote>
<p>shiftcls</p>
<blockquote>
<p>类的指针，源码中<code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</code>表示将当前地址右移三位，用于将Class指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8bits）对其内存，其指针后三位都是没有意义的0。</p>
</blockquote>
<p>magic</p>
<blockquote>
<p>判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间</p>
</blockquote>
<p>weakly_referenced</p>
<blockquote>
<p>对象被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以被尽快释放</p>
</blockquote>
<p>deallocating</p>
<blockquote>
<p>对象是否正在释放内存</p>
</blockquote>
<p>has_sidetable_rc</p>
<blockquote>
<p>判断该对象的引用计数器是否过大，如果过大则需要其他的散列表来存储</p>
</blockquote>
<p>extra_rc</p>
<blockquote>
<p>存放该对象的引用计数值减1后的结果。对象引用计数超过1，会存在这个里面，如果引用计数为10，extra_rc为9</p>
</blockquote>
<p>ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23_8.png" alt="23_8"></p>
<p>ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001，结构如下图：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23_9.png" alt="23_9"></p>
<p>参数说明：</p>
<p>第一位index，代表是否开启isa指针优化，1表示开启</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">Tagged Pointer</a></h3><p>关于taggerPointer，在 2013 年 9 月，苹果推出了<a href="http://en.wikipedia.org/wiki/IPhone_5S" target="_blank" rel="noopener"> iPhone5s </a>，与此同时，iPhone5s 配备了首个采用 64 位架构的<a href="http://en.wikipedia.org/wiki/Apple_A7" target="_blank" rel="noopener"> A7 双核处理器</a>，为了节省内存和提高执行效率，苹果提出了<code>Tagged Pointer</code>的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p>
<p>为什么能减少近一半的内存占用呢？假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。</p>
<p>所以一个普通的 iOS 程序，如果没有<code>Tagged Pointer</code>对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23-10.png" alt="23-10"></p>
<p>从效率上来看，为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>为了改进上面提到的内存占用和效率问题，苹果提出了taggedPointer对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：2^31=2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。</p>
<p>所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了<code>Tagged Pointer</code>对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23-11.png" alt="23-11"></p>
<p>可见，当 8 字节可以承载用于表示的数值时，系统就会以<code>Tagged Pointer</code>的方式生成指针，如果 8 字节承载不了时，则又用以前的方式来生成普通的指针。关于以上关于<code>Tag Pointer</code>的存储细节，我们也可以在<a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">这里</a>找到相应的讨论，但是其中关于<code>Tagged Pointer</code>的实现细节与我们的实验并不相符，笔者认为可能是苹果更改了具体的实现细节，并且这并不影响<code>Tagged Pointer</code>我们讨论<code>Tagged Pointer</code>本身的优点</p>
<p>taggedPointer特点：</p>
<ol>
<li><code>Tagged Pointer</code>专门用来存储小的对象，例如<code>NSNumber</code>和<code>NSDate</code></li>
<li><code>Tagged Pointer</code>指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free。</li>
<li>在内存读取上有着 3 倍的效率，创建时比以前快 106 倍。</li>
<li>Tagged Pointer并不是真正的对象，直接访问其isa指针会有编译警告问题，实际使用过程中也不要直接访问</li>
</ol>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    &#x2F;&#x2F; IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    &#x2F;&#x2F; SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__</span><br><span class="line">    uintptr_t _imp;</span><br><span class="line">    SEL _sel;</span><br><span class="line">#else</span><br><span class="line">    SEL _sel;</span><br><span class="line">    uintptr_t _imp;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;  &#x2F;&#x2F; x86_64 &amp; arm64 asm are less efficient with 16-bits</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/image-20200311164228160.png" alt="image-20200311164228160"></p>
<p>cache_t结构中有三个成员，一个bucket_t的结构体和两个unsigned int的变量</p>
<p>_mask ：分配缓存bucket的总数</p>
<p>_occupied：表示目前实际占用的缓存buckets的个数</p>
<p>bucket_t结构体中存储了一个unsigned long和一个IMP(unsigned long)。IMP是一个函数指针，指向了一个方法的具体实现</p>
<p>_buckets其实就是一个散列表，用来存储Method的链表。</p>
<p>cache_t的主要作用是为了优化方法调用的性能，当对象receiver调用方法message时，首先根据对象receiver的isa指针找到他对应的类，然后在类的methodList中搜索方法，如果没有找到就使用supper_class指针到父类的methodLists中查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也有可能忽略它。但是这种查找方式效率太低，往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用chache来缓存经常调用的方法，在调用方法时，首先在cache中查找，再到methodLists查找。</p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">		class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    const class_ro_t *safe_ro() &#123;</span><br><span class="line">    	……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint32_t index;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/image-20200311170751822.png" alt="image-20200311170751822"></p>
<p>class_data_bits_t 相当于class_rw_t 指针加上r r/alloc的标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br></pre></td></tr></table></figure>

<p>class_rw_t中存放着类的属性、方法和遵循的协议，class_ro_t是一个指向了常量的指针，存放着编译器决定了的属性、方法和遵循的协议。</p>
<h3 id="realizeClassWithoutSwift"><a href="#realizeClassWithoutSwift" class="headerlink" title="realizeClassWithoutSwift"></a>realizeClassWithoutSwift</h3><p>在运行时调用<code>realizeClassWithoutSwift</code>方法，会进行以下几件事情：</p>
<ol>
<li>对类cls执行首次初始化</li>
<li>分配读写数据，初始化一个class_rw_t结构体</li>
<li>设置ro的指和<code>rw-&gt;flags = RW_REALIZED|RW_REALIZING</code></li>
<li>设置supperCls和meta-cls</li>
<li>调用<code>methodizeClass</code>，加载类的属性、协议和方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">tatic void methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line">    auto ro &#x3D; rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Methodizing for the first time</span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: methodizing class &#39;%s&#39; %s&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Install methods and properties that the class implements itself.</span><br><span class="line">    method_list_t *list &#x3D; ro-&gt;baseMethods();</span><br><span class="line">    if (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *proplist &#x3D; ro-&gt;baseProperties;</span><br><span class="line">    if (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protocol_list_t *protolist &#x3D; ro-&gt;baseProtocols;</span><br><span class="line">    if (protolist) &#123;</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Root classes get bonus method implementations if they don&#39;t have </span><br><span class="line">    &#x2F;&#x2F; them already. These apply before category replacements.</span><br><span class="line">    if (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        &#x2F;&#x2F; root metaclass</span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach categories.</span><br><span class="line">    category_list *cats &#x3D; unattachedCategoriesForClass(cls, true &#x2F;*realizing*&#x2F;);</span><br><span class="line">    attachCategories(cls, cats, false &#x2F;*don&#39;t flush caches*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        if (cats) &#123;</span><br><span class="line">            for (uint32_t i &#x3D; 0; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </span><br><span class="line">                             isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (cats) free(cats);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; Debug: sanity-check all SELs; log method list contents</span><br><span class="line">    for (const auto&amp; meth : rw-&gt;methods) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</span><br><span class="line">        &#125;</span><br><span class="line">        assert(sel_registerName(sel_getName(meth.name)) &#x3D;&#x3D; meth.name); </span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在runtime初始化之前，<code>realizeClassWithoutSwift</code>之前，在class_data_bits_t结构体中获取到的data，并不是class_rw_t结构体，而是class_ro_t</p>
<ol>
<li>类的一些方法、属性、遵守协议是在编译期决定的（baseMethods等成员在以及类在内存中的位置都是在编译器决定的），之后在修改代码也不会改变内存中的位置</li>
<li>类的方法、属性、遵守协议在编译期被存放在只读区域class_ro_t中，直到<code>realizeClassWithoutSwift</code>执行后被加载存放到class_rw_t中</li>
<li>class_ro_t中成员变量列表用指向常量的指针<code>const ivar_list_t * ivars;</code>，class_rw_t结构中无此成员</li>
<li>运行时采用category添加方法时，会修改class_rw_t的methods列表，而不会影响到class_ro_t中的baseMethods</li>
</ol>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法method_t结构体中有三个成员，SEL是方法的name，types是Type Encoding类型编码，类型可参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a>，IMP是一个指针，指向的是函数的具体实现，runtime中的消息传递和消息转发的目的就是为了找到IMP，并执行函数</p>
<h3 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ivar_t &#123;</span><br><span class="line">    int32_t *offset;&#x2F;&#x2F;偏移</span><br><span class="line">    const char *name;&#x2F;&#x2F; 变量名</span><br><span class="line">    const char *type;&#x2F;&#x2F; Type Encoding</span><br><span class="line">    uint32_t alignment_raw;&#x2F;&#x2F; 对齐</span><br><span class="line">    uint32_t size;&#x2F;&#x2F; 大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化类函数<code>realizeClassWithoutSwift</code>中有这么一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reconcile instance variable offsets &#x2F; layout.</span><br><span class="line">&#x2F;&#x2F; This may reallocate class_ro_t, updating our ro variable.</span><br><span class="line">if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br></pre></td></tr></table></figure>

<p>根据官方注释，<code>reconcileInstanceVariables</code>这个方法很有可能就是用来重新分配class_ro_t以及调整Ivar的offset的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void reconcileInstanceVariables(Class cls, Class supercls, const class_ro_t*&amp; ro)</span><br><span class="line">&#123;</span><br><span class="line">    class_rw_t *rw &#x3D; cls-&gt;data();</span><br><span class="line">    </span><br><span class="line">    if (ro-&gt;instanceStart &gt;&#x3D; super_ro-&gt;instanceSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; Superclass has not overgrown its space. We&#39;re done here.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    if (ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; Superclass has changed size. This class&#39;s ivars must move.</span><br><span class="line">        &#x2F;&#x2F; Also slide layout bits in parallel.</span><br><span class="line">        &#x2F;&#x2F; This code is incapable of compacting the subclass to</span><br><span class="line">        &#x2F;&#x2F;   compensate for a superclass that shrunk, so don&#39;t do that.</span><br><span class="line">        class_ro_t *ro_w &#x3D; make_ro_writeable(rw);</span><br><span class="line">        ro &#x3D; rw-&gt;ro;</span><br><span class="line">        moveIvars(ro_w, super_ro-&gt;instanceSize);</span><br><span class="line">        gdb_objc_class_changed(cls, OBJC_CLASS_IVARS_CHANGED, ro-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>instanceStart</code>代表当前类的成员变量开始的偏移量，<code>instanceSize</code>表示当前类的成员变量（包括父类）的大小。发现当子类的开始偏移量小于父类的变量大小的时候，也就是说此事两个类的变量地址有可能是重叠的，这个时候需要<code>moveIvars</code>来调整子类的开始偏移量</p>
<p><code>static void moveIvars(class_ro_t *ro, uint32_t superSize)</code></p>
<ol>
<li><p>获取最大的对齐字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Find maximum alignment in this class&#39;s ivars</span><br><span class="line">uint32_t maxAlignment &#x3D; 1;</span><br><span class="line">for (const auto&amp; ivar : *ro-&gt;ivars) &#123;</span><br><span class="line">    if (!ivar.offset) continue;  &#x2F;&#x2F; anonymous bitfield</span><br><span class="line"></span><br><span class="line">    uint32_t alignment &#x3D; ivar.alignment();</span><br><span class="line">    if (alignment &gt; maxAlignment) maxAlignment &#x3D; alignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整所有变量的偏移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Compute a slide value that preserves that alignment</span><br><span class="line">uint32_t alignMask &#x3D; maxAlignment - 1;</span><br><span class="line">diff &#x3D; (diff + alignMask) &amp; ~alignMask;&#x2F;&#x2F; 通过该位操作可得到应该在diff的位置以maxAlignment 对齐时偏移的字节数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Slide all of this class&#39;s ivars en masse</span><br><span class="line">&#x2F;&#x2F; 调整所有的offset</span><br><span class="line">for (const auto&amp; ivar : *ro-&gt;ivars) &#123;</span><br><span class="line">    if (!ivar.offset) continue;  &#x2F;&#x2F; anonymous bitfield</span><br><span class="line"></span><br><span class="line">    uint32_t oldOffset &#x3D; (uint32_t)*ivar.offset;</span><br><span class="line">    uint32_t newOffset &#x3D; oldOffset + diff;</span><br><span class="line">    *ivar.offset &#x3D; newOffset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整子类的的instanceStart和instanceSize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(uint32_t *)&amp;ro-&gt;instanceStart +&#x3D; diff;</span><br><span class="line">*(uint32_t *)&amp;ro-&gt;instanceSize +&#x3D; diff;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>NSObject</code>只有一个变量<code>isa</code>，作为根类，<code>instanceSize</code>为0，<code>instanceSize</code>则为8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface TestIvar : NSObject&#123;</span><br><span class="line">  NSString *_ivarStr;</span><br><span class="line">&#125;</span><br><span class="line">@property(nonatomic, assign) NSInteger propertyInt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/23.12.png" alt="23.12"></p>
<p><code>TestIvar</code>中有两个变量，<code>instanceStart</code>刚好接在父类的后面， <code>instanceSize</code>为两个变量的大小+父类的<code>instanceSize</code>。这样类的内存布局就很清晰了，<code>isa</code>变量放在第一位，接下来先是父类的按顺序排放，最后子类的接在后面。</p>
<h4 id="IvarLayout"><a href="#IvarLayout" class="headerlink" title="IvarLayout"></a>IvarLayout</h4><p><code>class_ro_t</code>中有两个变量<code>ivarLayout</code>和<code>weakIvarLayout</code>，是用来记录变量那些是<code>strong</code>的，哪些是<code>weak</code>的，在<code>object_getIvar</code>中有通过<code>_class_lookUpIvar</code>获取变量的<code>objc_ivar_memory_management_t</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_class_lookUpIvar(Class cls, Ivar ivar, ptrdiff_t&amp; ivarOffset, </span><br><span class="line">                  objc_ivar_memory_management_t&amp; memoryManagement)</span><br><span class="line">&#123;</span><br><span class="line">    ivarOffset &#x3D; ivar_getOffset(ivar);</span><br><span class="line">		Class ivarCls &#x3D; _class_getClassForIvar(cls, ivar);</span><br><span class="line">    if (ivarCls-&gt;hasAutomaticIvars()) &#123;</span><br><span class="line">        &#x2F;&#x2F; ARC layout bitmaps encode the class&#39;s own ivars only.</span><br><span class="line">        &#x2F;&#x2F; Use alignedInstanceStart() because unaligned bytes at the start</span><br><span class="line">        &#x2F;&#x2F; of this class&#39;s ivars are not represented in the layout bitmap.</span><br><span class="line">        ptrdiff_t localOffset &#x3D; </span><br><span class="line">            ivarOffset - ivarCls-&gt;alignedInstanceStart();</span><br><span class="line"></span><br><span class="line">        if (isScanned(localOffset, class_getIvarLayout(ivarCls))) &#123;</span><br><span class="line">            memoryManagement &#x3D; objc_ivar_memoryStrong;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isScanned(localOffset, class_getWeakIvarLayout(ivarCls))) &#123;</span><br><span class="line">            memoryManagement &#x3D; objc_ivar_memoryWeak;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Unretained is only for true ARC classes.</span><br><span class="line">        if (ivarCls-&gt;isARC()) &#123;</span><br><span class="line">            memoryManagement &#x3D; objc_ivar_memoryUnretained;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memoryManagement &#x3D; objc_ivar_memoryUnknown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断变量的偏移量<code>localOffset</code>跟<code>ivarLayout</code>和<code>weakIvarLayout</code>来对比，来判断是<code>strong</code>还是<code>weak</code>的。</p>
<h4 id="为什么不能动态的添加Ivar"><a href="#为什么不能动态的添加Ivar" class="headerlink" title="为什么不能动态的添加Ivar"></a>为什么不能动态的添加Ivar</h4><p>假设我们已经有上面的类<code>TestIvar</code>,之后我们在运行期给类NSObject动态的添加了一个变量a，此时a的内存地址就会紧接着isa，由于此时没有调整所有变量的offset，那么TestIvar._ivarStr和NSObject.A就会有内存重叠，导致出现错误。这样NSObject所有子类都有可能出现这个问题</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>变量Ivar都是在编译期生成的，并且所有子类的变量都排在父类的后面</li>
<li>ivarLayout和weakIvarLayout分别代表着strong和weak变量的分布</li>
<li>运行期不能动态添加Ivar，如果在运行期动态添加Ivar，可能会导致所有子类无法正常使用</li>
</ol>
<h3 id="property-t"><a href="#property-t" class="headerlink" title="property_t"></a>property_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>property在iOS中由ivar+setter+getter组成，也就是说当声明一个属性，编译器会自动生成一个ivar和两个Method</p>
<p>关于<code>attributes</code>具体参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW24" target="_blank" rel="noopener">Declared Properties</a>。</p>
<h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><h4 id="self-class-和-supper-class"><a href="#self-class-和-supper-class" class="headerlink" title="[self class]和[supper class]"></a>[self class]和[supper class]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)clickCell_3 &#123;   </span><br><span class="line">    NSLog(@&quot;%@&quot;,[self class]);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[super class]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里被啪啪打脸，本来以为输出的应该是MMViewController 和 UIViewController，但是实际输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MMViewController</span><br><span class="line">MMViewController</span><br></pre></td></tr></table></figure>

<p>self：是类的一个隐藏参数</p>
<p>supper：是预编译指令，它告诉编译器，当调用方法时，去调用父类的方法，而不是本类的方法</p>
<p>当调用<code>[supper class]</code>时，runtime会去调用objc_msgSendSuper方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在objc_msgSendSuper方法中，第一个参数是objc_super结构体，这个结构体中有两个变量，一个是</p>
<p>接收消息的receiver也就是当前类（子类），另外一个是当前类的父类super_class</p>
<p>objc_msgSendSuper的工作原理：</p>
<p>从objc_supper结构体指向的supperClass父类的方法列表开始查找selector，找到后以objc-receiver去调用父类的这个selector。</p>
<p>那么<code>objc_msgSendSuper</code>会转换成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(objc_super-&gt;receiver, @selector(class))</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是当[supper class]执行完毕了，也就相当于是objc_supper-&gt;receiver(self) 执行IMP，这里[self class] 和 [supper class]执行完毕后输出一样。</p>
<h4 id="isKindOfClass-与-isMemberOfClass"><a href="#isKindOfClass-与-isMemberOfClass" class="headerlink" title="isKindOfClass 与 isMemberOfClass"></a>isKindOfClass 与 isMemberOfClass</h4><h5 id="isKindOfClass"><a href="#isKindOfClass" class="headerlink" title="isKindOfClass"></a>isKindOfClass</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    return self-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    return [self class]-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; object_getClass((id)self); tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>+ (BOOL)isKindOfClass:(Class)cls</code> 方法会先通过<code>object_getClass</code>获取当前类的meta-class,判断cls是否与当前类的meta-class相等，接着会遍历当前类的supperClass的meta-class，再去判断cls是否与supperClass的meta-class相等</p>
<p>根据前面对于meta-class的了解，我们知道，只有当cls为[NSObject class]时，当前类的meta-class才能获取到cls==meta-class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanItemModel isKindOfClass:[MMDoubanModel class]]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanItemModel isKindOfClass:[NSObject class]]);</span><br><span class="line">&#x2F;&#x2F;打印如下</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>- (BOOL)isKindOfClass:(Class)cls</code>实例方法会通过<code>- (Class)class</code>获取当前的对象的class，判断cls是否与当前对象的类相等，接着遍历类的supperclass，再对比当前类是否与cls相同，通过这种方法一旦发现当前对象的类 或者 其父类中有一个能与cls匹配，那么认定校验为YES。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface MMDoubanItemModel : MMDoubanModel</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">MMDoubanItemModel *doubanModel &#x3D; [MMDoubanItemModel new];</span><br><span class="line">NSLog(@&quot;%d&quot;,[doubanModel isKindOfClass:[MMDoubanModel class]]);</span><br><span class="line">&#x2F;&#x2F; 打印如下</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="isMemberOfClass"><a href="#isMemberOfClass" class="headerlink" title="isMemberOfClass"></a>isMemberOfClass</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return object_getClass((id)self) &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>+ (BOOL)isMemberOfClass:(Class)cls</code>方法通过<code>object_getClass</code>获取当前类的meta-class，与当前cls进行对比，根据前面对于meta-class的了解，只有当前当前类为基类（NSObject）,并且cls也为NSObject才会返回YES，这个方法其实是meta-class对比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanModel isMemberOfClass:objc_getMetaClass([NSStringFromClass([MMDoubanModel class]) UTF8String])]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanItemModel isMemberOfClass:[MMDoubanModel class]]);</span><br><span class="line">&#x2F;&#x2F; 打印如下</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><code>- (BOOL)isMemberOfClass:(Class)cls</code>对象方法获取当前对象的isa指针，与传进来的类的isa进行对比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MMDoubanItemModel *doubanModel &#x3D; [MMDoubanItemModel new];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%d&quot;,[doubanModel isMemberOfClass:[MMDoubanModel class]]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[doubanModel isMemberOfClass:[MMDoubanItemModel class]]);</span><br><span class="line">&#x2F;&#x2F; 打印</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="Class与内存地址"><a href="#Class与内存地址" class="headerlink" title="Class与内存地址"></a>Class与内存地址</h4><blockquote>
<p>举个🌰，下面的代码会？Compile Error/Runtime Crash/NSLog…？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface MMDoubanModel : NSObject</span><br><span class="line">- (void)douban;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MMDoubanModel</span><br><span class="line">- (void)douban &#123;</span><br><span class="line">    NSLog(@&quot;my name&#39;s %@&quot;, self.title);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)clickCell_5 &#123;</span><br><span class="line">    id cls &#x3D; [MMDoubanModel class];</span><br><span class="line">    void *obj &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)obj douban];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>疑问一，能不能调用douban方法？会不会出现Runtime Crash？</p>
<p>答案是可以的。cls使用id转换成objc_object类型，<code>void *obj = &amp;cls;</code>表示obj指向的是一个objc_object类型的对象地址，obj可以说已经是一个MMDoubanModel类型的实例对象了。</p>
<p>疑问二，调用douban方法，会输出什么呢？()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一次打印</span><br><span class="line">my name&#39;s (null)--&lt;MMDoubanModel: 0x7ffee4382898&gt;</span><br><span class="line">&#x2F;&#x2F; 第二次打印</span><br><span class="line">my name&#39;s MMViewController--&lt;MMDoubanModel: 0x7ffee4382898&gt;</span><br></pre></td></tr></table></figure>

<p>未完待续，这个结果有点懵！！！</p>
<p>至此，Objc中的对象到底是什么呢？</p>
<p>实质：Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N)</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/06/jekins-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="prev" title="jekins+单元测试">
      <i class="fa fa-chevron-left"></i> jekins+单元测试
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/12/Objective-C-Runtime%E2%80%94%E2%80%94objc-msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/" rel="next" title="Objective-C Runtime——objc_msgSend消息发送和转发">
      Objective-C Runtime——objc_msgSend消息发送和转发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-object"><span class="nav-number">1.</span> <span class="nav-text">objc_object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Meta-Class"><span class="nav-number">2.</span> <span class="nav-text">Meta-Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isa-t"><span class="nav-number">3.</span> <span class="nav-text">isa_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tagged-Pointer"><span class="nav-number">4.</span> <span class="nav-text">Tagged Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#改进"><span class="nav-number">4.1.</span> <span class="nav-text">改进</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-t"><span class="nav-number">5.</span> <span class="nav-text">cache_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-data-bits-t"><span class="nav-number">6.</span> <span class="nav-text">class_data_bits_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#realizeClassWithoutSwift"><span class="nav-number">7.</span> <span class="nav-text">realizeClassWithoutSwift</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#method-t"><span class="nav-number">8.</span> <span class="nav-text">method_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ivar-t"><span class="nav-number">9.</span> <span class="nav-text">ivar_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IvarLayout"><span class="nav-number">9.1.</span> <span class="nav-text">IvarLayout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么不能动态的添加Ivar"><span class="nav-number">9.2.</span> <span class="nav-text">为什么不能动态的添加Ivar</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">9.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property-t"><span class="nav-number">10.</span> <span class="nav-text">property_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实例"><span class="nav-number">11.</span> <span class="nav-text">具体实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#self-class-和-supper-class"><span class="nav-number">11.1.</span> <span class="nav-text">[self class]和[supper class]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isKindOfClass-与-isMemberOfClass"><span class="nav-number">11.2.</span> <span class="nav-text">isKindOfClass 与 isMemberOfClass</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#isKindOfClass"><span class="nav-number">11.2.1.</span> <span class="nav-text">isKindOfClass</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isMemberOfClass"><span class="nav-number">11.2.2.</span> <span class="nav-text">isMemberOfClass</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class与内存地址"><span class="nav-number">11.3.</span> <span class="nav-text">Class与内存地址</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doris AI</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doris AI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
