<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorisgit.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="泡泡茶壶">
<meta property="og:url" content="https://dorisgit.github.io/page/2/index.html">
<meta property="og:site_name" content="泡泡茶壶">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Doris AI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dorisgit.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>泡泡茶壶</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泡泡茶壶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/08/28/ios-%E6%A3%80%E6%B5%8B%E6%97%A0%E7%94%A8%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/28/ios-%E6%A3%80%E6%B5%8B%E6%97%A0%E7%94%A8%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">ios 检测无用类、方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-28 15:13:18" itemprop="dateCreated datePublished" datetime="2020-08-28T15:13:18+08:00">2020-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-17 21:18:19" itemprop="dateModified" datetime="2020-09-17T21:18:19+08:00">2020-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/05/30/Http%E4%B8%8EHttps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Http%E4%B8%8EHttps/" class="post-title-link" itemprop="url">Http与Https</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-30 01:14:06" itemprop="dateCreated datePublished" datetime="2020-05-30T01:14:06+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-05 19:48:37" itemprop="dateModified" datetime="2020-06-05T19:48:37+08:00">2020-06-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h2><p>HTTP有什么问题？</p>
<ol>
<li>使用明文（没有加密）通信，内容可能会被窃听</li>
<li>不会验证通信双方的身份，通信方的身份可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能会被篡改</li>
</ol>
<p>由于HTTP在设计的时候都没有考虑到这些，所以基于HTTP的应用都可能存在安全问题</p>
<h4 id="数据没有加密"><a href="#数据没有加密" class="headerlink" title="数据没有加密"></a>数据没有加密</h4><p>基于TCP/IP的网络，网络各处都会存在被窃听的风险，如果用HTTP协议进行通信，HTTP本身没有加密的功能，所有无法做到对通信整体（使用HTTP协议通讯的请求和响应内容）进行加密，HTTP报文采用明文传输。</p>
<p>即使使用加密内容进行通信，也能被窃听到内容，只不过拿到的是密文，而且HTTP头部是没有加密的，头部信息也会导致信息不安全。</p>
<p>要解决HTTP的3的安全问题，第一步就是先进行加密通信，于是在传输层增加了一层SSL（Secure Sockets Layer安全套机接层）/TLS（Transport Layer Security安全层传输协议）来加密HTTP的通信内容</p>
<p>HTTPS并不是新的协议，而是HTTP先和SSL/TLS通信，再由SSL/TLS和TCP通信，也就是说HTTPS使用隧道进行通信。</p>
<h4 id="无法验证对方身份"><a href="#无法验证对方身份" class="headerlink" title="无法验证对方身份"></a>无法验证对方身份</h4><p>基于TCP的HTTP虽然可以保证数据能完整的传输给对方，但是无法验证对方的身份。HTTP也由于协议的灵活性，应用的非常广泛。通信双方无需验证身份，服务器只要接收到能识别的请求，就会返回一个响应，一个request就会有一个response。由于不确认对方，就会导致一些隐患：</p>
<ol>
<li>服务器无法验证请求来自于谁，是否是合法的客户端</li>
<li>客户端收到响应，无法验证是否来自合法的服务器</li>
<li>无法阻止海量请求下的Dos拒绝攻击（Denial of Service,拒绝服务攻击）</li>
</ol>
<h4 id="无法防止数据被篡改"><a href="#无法防止数据被篡改" class="headerlink" title="无法防止数据被篡改"></a>无法防止数据被篡改</h4><p>HTTP协议是无法保证数据的完整性的，这里的完整性值得是信息的准确度，若无法证明信息的完整行，也就是意味着无法判断信息的准确性。</p>
<p>客户端和服务端对于收到的请求和响应，都只能无条件的接受，HTTP也无妨知道请求或响应过程中数据是否被篡改了，例如中间人攻击（Main-in-the-Middle attack,MITM）</p>
<p>HTTP也有验证报文完整性的方法，但是不是很可靠。比如利用MD5和SHA-1等散列值校验的方法用来确认文件的数字签名（MD5和SHA-1低位数的已经不再安全，会遭到碰撞攻击）</p>
<p>在下载i服务的web网站也会提供PGP（Pertty Good Privacy,完美隐私）创建的数字签名及MD5算法生成的散列值。PGP用来证明创建文件的数字签名，MD5是由单向函数生成的散列值。在HTTP协议下，浏览器是无法知晓数据是否被篡改了，还是需要用户自己查看。如果PGP和MD5在传输钱就被篡改了，用户拿到以后验证发现是一致的，这种情况下也没法保证数据的完整正确性</p>
<p>跳过TLS，HTTPS不仅能保证密文传输，重要的是还可以验证对方身份，保证报文传输的完整性，完全解决了HTTP上的三大安全问题。</p>
<h2 id="部署HTTPS的好处"><a href="#部署HTTPS的好处" class="headerlink" title="部署HTTPS的好处"></a>部署HTTPS的好处</h2><h4 id="使用HTTP-2获得更高的性能"><a href="#使用HTTP-2获得更高的性能" class="headerlink" title="使用HTTP/2获得更高的性能"></a>使用HTTP/2获得更高的性能</h4><p>内容交付和网络托管服务提供商正在开始推广HTTP/2。在Velocity的一次会议上，Load Impact和Mozilla报告说，互联网用户可以通过HTTP/2优化比HTTP/1.1上的网站性能要好50-70%。但是想用HTTP/2的性能优势，必须先部署HTTPS，这个规定也是对HTTPS的一个推广。</p>
<h4 id="提高SEO排名"><a href="#提高SEO排名" class="headerlink" title="提高SEO排名"></a>提高SEO排名</h4><p>谷歌在2014年宣布，支持HTTPS的网站会有排名靠前的较大比重</p>
<h4 id="更好的推荐数据"><a href="#更好的推荐数据" class="headerlink" title="更好的推荐数据"></a>更好的推荐数据</h4><p>如果采用的谷歌的Analytics库，他目前是强制允许在HTTPS上的，如果还是使用HTTP，会犹豫Analytics不会获取HTTP网站的Referral信息而导致数据不准确</p>
<h4 id="更高的安全性"><a href="#更高的安全性" class="headerlink" title="更高的安全性"></a>更高的安全性</h4><p>主流浏览器都会针对HTTPS网站增加小绿锁标志，没有小绿锁的网站，给用户的第一印象不是很安全</p>
<h4 id="提高网站的信任和信誉"><a href="#提高网站的信任和信誉" class="headerlink" title="提高网站的信任和信誉"></a>提高网站的信任和信誉</h4><p>在Chrome62版本后，如果网页上有输入框，没有HTTPS的网页一律视为不安全</p>
<h4 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h4><p>在Chrome 50版本后，地理位置，音频视频接口必须要求运行在HTTPS上，目的是能保证数据传输安全</p>
<h4 id="iOS-ATS要求"><a href="#iOS-ATS要求" class="headerlink" title="iOS ATS要求"></a>iOS ATS要求</h4><p>苹果为了推广HTTPS，在WWDC2017上也宣布新的App必须要开启ATS（App Transport Security）安全特性</p>
<h2 id="HTTPS中的密码"><a href="#HTTPS中的密码" class="headerlink" title="HTTPS中的密码"></a>HTTPS中的密码</h2><h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><p>对称密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快</li>
<li>缺点：密钥容易被获取</li>
</ul>
<h4 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h4><p>公开密钥加密（Public-key Encryption）,也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送发获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥进行解密。</p>
<ul>
<li>优点：更为安全</li>
<li>缺点：运算速度慢</li>
</ul>
<h4 id="HTTPS采用的加密方式"><a href="#HTTPS采用的加密方式" class="headerlink" title="HTTPS采用的加密方式"></a>HTTPS采用的加密方式</h4><p>HTTPS采用混合的加密机制，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。</p>
<ul>
<li>客户端请求连接，服务端生成公钥和私钥</li>
<li>使用公开加密方式传输公钥，同时生成一个Session Key传输给客户端</li>
<li>客户端使用公钥对Session Key进行对称加密，传输给服务端</li>
<li>服务端通过私钥进行解密</li>
</ul>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>HTTPS通过使用证书来对通信双方进行认证</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务端双方都可信赖的第三方机构。服务器的运营人员向CA提出公开密钥申请，CA在判明提出申请者的身份后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将公开密钥放入公开证书后绑定在一起。</p>
<p>进行HTTPS通信时，服务器会将证书发送给客户端，客户端获取其中的公开密钥后，先进行验证，如果验证通过，就可以开始通信了。具体的证书内容，可查看<a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTPS-digital-certificate.md" target="_blank" rel="noopener">《随处可见的公钥证书》</a></p>
<p>使用openSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告信息。</p>
<h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><p>SSL/TLS提供内容摘要功能来验证完整性。</p>
<h2 id="HTTPS中的SSL-TLS协议"><a href="#HTTPS中的SSL-TLS协议" class="headerlink" title="HTTPS中的SSL/TLS协议"></a>HTTPS中的SSL/TLS协议</h2><table>
<thead>
<tr>
<th></th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>HTTP</td>
<td>HTTP</td>
</tr>
<tr>
<td>安全层</td>
<td></td>
<td>SSL/TLS</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP</td>
<td>TCP</td>
</tr>
<tr>
<td>网络层</td>
<td>IP</td>
<td>IP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>网络接口</td>
<td>网络接口</td>
</tr>
</tbody></table>
<p>能让HTTP安全的就是其中的安全层，也就是其背后的TLS协议。它源于九十年代中期在Netscape上开发称为安全套接字层（SSL）层协议，到20世纪90年代末，Netscape将SSL移交给IETF，IETF将其重命名为TLS，并从此成为该协议的管理者。许多人仍将web加密称作SSL，即使绝大多数服务已经切换为仅支持TLS。</p>
<p>SSL/TLS位于应用层和传输层TCP协议的中间，TLS粗略划分可以分为两层：</p>
<ul>
<li>靠近应用层的握手协议TLS Handshaking Protocol</li>
<li>靠近TCP的记录层协议TLS Record Protocol</li>
</ul>
<p>TLS握手协议可细分为5个子协议：</p>
<ul>
<li>Change_cipher_spec：密码切换协议</li>
<li>alert：警告协议</li>
<li>handshake：握手协议</li>
<li>Application_data：应用数据协议</li>
<li>Heartbeat：心跳协议</li>
</ul>
<img src="https://img.halfrost.com/Blog/ArticleImage/95_11_.png" alt="img" style="zoom:30%;" />

<h4 id="1、TLS记录层协议"><a href="#1、TLS记录层协议" class="headerlink" title="1、TLS记录层协议"></a>1、TLS记录层协议</h4><p>记录层将上层的信息库分段为TLSPlaintext记录，TLSPlaintext中包含2^14字节或更少子节块数据。根据底层ContentType的不同，消息的边界的处理方式不同，TLS1.3中的规则比TLS1.2中强制执行的规则更加严格。</p>
<p>握手消息可以合并为单个TLSPlaintext记录，或者在几个记录中分段，前提是：</p>
<ul>
<li>握手消息不得与其他记录类型交错。也就是说，如果握手消息被分为两个或多个记录，则他们之间不能有任务其他记录</li>
<li>握手消息绝不能跨越密钥更改，实现方必须验证密钥更改之前的所有消息是否与记录边界对其；如果没有，你们他们必须用“unexperted_message”alert消息终止连接。因为ClientHello，EndOfEarlyData,ServerHello,Finished和KeyUpdate消息可以在密钥更改之前立即发生，所以实现方必须将这些消息与记录边界对齐。</li>
</ul>
<p>实现方绝不能发生握手类型的零长度片段，即使这些片段包含填充</p>
<p>另外Alert消息禁止在记录之间进行分段，并且多条alert消息不得合并为单个TLSPlaintext记录。换句话说，具有alert类型的记录必须只包含一条消息。</p>
<p>应用数据消息包含对TLS不透明的数据。应用数据消息应该始终受到保护，可以发生应用数据的零长度片段，因为他们可能作为流量分析对策使用。应用数据片段可以拆分为多个记录，也可以合并为一个记录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ContentType type;</span><br><span class="line">  ProtocolVersion legacy_record_version;</span><br><span class="line">  uint16 length;</span><br><span class="line">  opaque fragment[TLSPlaintext.length];</span><br><span class="line">&#125; TLSPlaintext;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>type</p>
<p>用户处理TLS握手层的高级协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">          invalid(0),</span><br><span class="line">          change_cipher_spec(20),</span><br><span class="line">          alert(21),</span><br><span class="line">          handshake(22),</span><br><span class="line">          application_data(23),</span><br><span class="line">          heartbeat(24),  &#x2F;* RFC 6520 *&#x2F;</span><br><span class="line">          (255)</span><br><span class="line">      &#125; ContentType;</span><br></pre></td></tr></table></figure>

<p>ContentType是对握手协议的封装，消息头类型和握手层子协议编号的对应关系如下：</p>
<table>
<thead>
<tr>
<th>消息头类型</th>
<th>ContentType</th>
</tr>
</thead>
<tbody><tr>
<td>invalid</td>
<td>0x00</td>
</tr>
<tr>
<td>change_cipher_spec</td>
<td>0x14</td>
</tr>
<tr>
<td>alert</td>
<td>0x15</td>
</tr>
<tr>
<td>handshake</td>
<td>0x16</td>
</tr>
<tr>
<td>application_data</td>
<td>0x17</td>
</tr>
<tr>
<td>heartbeat</td>
<td>0x18</td>
</tr>
</tbody></table>
</li>
<li><p>legacy_record_version</p>
<p>除初始化ClientHello之外的TLS1.3实现生成的所有记录（即，在HelloRetryRequest之后未生成的记录），必须将其设置为0x0303,其中处于兼容性目的，他也可以是0x0301。该字段在TLS1.3中已经弃用，必须忽略它。在某些情况下，以前版本的TLS将在此字段中使用其他值。</p>
<table>
<thead>
<tr>
<th>协议版本</th>
<th>Version</th>
</tr>
</thead>
<tbody><tr>
<td>TLS1.3</td>
<td>0x0304</td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>0x0303</td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>0x0302</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>0x0301</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>0x0300</td>
</tr>
</tbody></table>
</li>
<li><p>Length</p>
<p>TLSPlaintext.frament的长度（以字节为单位）。长度不超过2^14字节。接收超过此长度的记录的端点必须使用”record_overflow”alert 消息终止连接</p>
</li>
<li><p>fragment</p>
<p>正在传输的数据，此字段的值是透明的，它被视为一个独立的块，由类型字段指定的更高级别协议处理</p>
</li>
</ul>
<p>当尚未使用密码保护时，TLSPlaintext结构是直接写入传输线路中。一旦记录保护开始，TLSPlaintext记录将受到密码保护。请注意，应用数据不得写入未受保护的连接中。所以在握手成功之前，是不能发送应用数据的。</p>
<p>TLS记录层协议在整个TLS协议中的定位如下：</p>
<ul>
<li>封装处理TLS上层（握手层）中的平行子协议（TLS1.3中是5个子协议，TLS1.2及更老的版本是4个子协议），加上消息头，打包往下传递给TCP处理</li>
<li>对应用数据进行密码保护，对其他子协议只是简单封装（不加密）</li>
</ul>
<h4 id="2、密码切换协议（Change-cipher-spec）"><a href="#2、密码切换协议（Change-cipher-spec）" class="headerlink" title="2、密码切换协议（Change_cipher_spec）"></a>2、密码切换协议（Change_cipher_spec）</h4><p>Change_cipher_spec协议，是TLS记录层对应用是否进行加密的分割线，客户端或服务端一旦收到对端发来的CSS协议，就表明接下来传输数据过程中可以对应用数据协议进行加密了。</p>
<p>TLS记录层在处理上层5个协议（密码切换协议、警告协议、握手协议、心跳协议、应用数据协议）的时候，TLS不同版本对不同协议的加密情况不同，具体情况如下：</p>
<table>
<thead>
<tr>
<th align="left">协议版本</th>
<th>密码切换协议</th>
<th>警告协议</th>
<th>握手协议</th>
<th>心跳协议</th>
<th>应用数据协议</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TLS 1.3</td>
<td>无</td>
<td>根据连接状态不同进行加密，即一部分会密码</td>
<td>一部分加密</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td align="left">TLS 1.2</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>无</td>
<td>✅</td>
</tr>
</tbody></table>
<p>协议数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123;change_cipher_spec(<span class="number">1</span>), (<span class="number">255</span>)&#125; type</span><br><span class="line">&#125; ChangeCipherSpec</span><br></pre></td></tr></table></figure>

<h4 id="3、警告协议（alert）"><a href="#3、警告协议（alert）" class="headerlink" title="3、警告协议（alert）"></a>3、警告协议（alert）</h4><p>TLS提供alert内容类型用来表示关闭信息和错误。与其他信息一样，alert消息也会根据当前连接状态进行加密。在TLS 1.3中，错误的严重性隐含在正在发送的警报类型中，并且可以安全地忽略“level”字段。“close_notify”alert用户表示连接从一个方向开始有序的关闭。收到这样的警报后，TLS实现方应该表明程序的数据结束。</p>
<p>收到错误警告后，TLS实现方应该向应用程序表示出现了错误，并且不允许在连接上发送或接收任何其他数据。</p>
<p>协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum&#123;warning(1),fatal(2), (255)&#125; AlertLevel;</span><br><span class="line">struct &#123;</span><br><span class="line">	AlertLevel level;</span><br><span class="line">	AlertDescription description;</span><br><span class="line">&#125;Alert;</span><br></pre></td></tr></table></figure>

<p>TLS 1.3和TLS 1.2在这个协议上的改动很小，只是新增了几个枚举类型。</p>
<p>TLS 1.2的所有警告信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	close_notify(<span class="number">0</span>),</span><br><span class="line">	unexpected_message(<span class="number">10</span>),</span><br><span class="line">	bad_record_mac(<span class="number">20</span>),</span><br><span class="line">	decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">	record_overflow(<span class="number">22</span>),</span><br><span class="line">	decompression_failure(<span class="number">30</span>),</span><br><span class="line">	handshake_failure(<span class="number">40</span>),</span><br><span class="line">	no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">	bad_certificate(<span class="number">42</span>),</span><br><span class="line">	unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">	certificate_revoked(<span class="number">44</span>),</span><br><span class="line">	certificate_unknow(<span class="number">46</span>),</span><br><span class="line">	illegal_paramter(<span class="number">47</span>),</span><br><span class="line">	unknow_ca(<span class="number">48</span>),</span><br><span class="line">	access_denied(<span class="number">49</span>),</span><br><span class="line">	decode_error(<span class="number">50</span>),</span><br><span class="line">	decrypt_error(<span class="number">51</span>),</span><br><span class="line">	export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">	protocol_version(<span class="number">70</span>),</span><br><span class="line">	internal_error(<span class="number">80</span>),</span><br><span class="line">	user_canceled(<span class="number">90</span>),</span><br><span class="line">	no_renegotiation(<span class="number">100</span>),</span><br><span class="line">	unsupported_extension(<span class="number">110</span>),</span><br><span class="line">	(<span class="number">255</span>)</span><br><span class="line">&#125;AlertDescription;</span><br></pre></td></tr></table></figure>

<p>TLS 1.3 在TLS 1.2基础上新增了9个警告描述信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inapporopriate_fallback(<span class="number">86</span>),</span><br><span class="line">missing_extension(<span class="number">109</span>),</span><br><span class="line">certificate_unobtainable_RESERVED(<span class="number">111</span>),</span><br><span class="line">bad_certificate_status_response(<span class="number">113</span>),</span><br><span class="line">bad_certificate_hash_value_RESERVED(<span class="number">114</span>),</span><br><span class="line">unkonwn_psk_identity(<span class="number">115</span>),</span><br><span class="line">centificate_required(<span class="number">116</span>),</span><br><span class="line">no_application_protocol(<span class="number">120</span>),</span><br></pre></td></tr></table></figure>

<h4 id="4、握手协议（handshake）"><a href="#4、握手协议（handshake）" class="headerlink" title="4、握手协议（handshake）"></a>4、握手协议（handshake）</h4><p>握手协议是整个TLS协议簇中最核心的协议，HTTPS能保证安全也是因为它的功劳。</p>
<p>握手协议由多个子消息构成，服务端和客户端第一次完成握手需要2-RTT。</p>
<p>握手协议的目的是为了双方协商出密码块，这个密码块会交给TLS记录层进行密钥加密，也就是说握手协议达成的“共识”（密码块）就是整个TLS和HTTPS安全的基础。</p>
<p>握手协议在TLS1.2 和 TLS1.3中发生了很大的变化。TLS1.3的0-RTT是一个全新的概念。两个版本在密钥协商上，密码套件选择上都有很大的不同。</p>
<p>TLS 1.2协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	hello_request(0),</span><br><span class="line">	client_hello(1),</span><br><span class="line">	server_hello(2),</span><br><span class="line">	certificate(11),</span><br><span class="line">	server_key_exchange(12),</span><br><span class="line">	certificate_request(13),</span><br><span class="line">	server_hello_done(14),</span><br><span class="line">	certificate_verify(15),</span><br><span class="line">	client_key_exchange(16),</span><br><span class="line">	finished(20),</span><br><span class="line">	(255)</span><br><span class="line">&#125;HandshakeType;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">	HandshakeType msg_type;</span><br><span class="line">	unit24 length;</span><br><span class="line">	select(HandshakeType) &#123;</span><br><span class="line">		case hello_request:	HelloRequest;</span><br><span class="line">		case client_hello:	ClientHello;</span><br><span class="line">		case server_hello:	ServerHello;</span><br><span class="line">		case certificate:		Certificate;</span><br><span class="line">		case server_key_exchange:	ServerKeyExchange;</span><br><span class="line">		case certificate_request:	CertifiCateRequest;</span><br><span class="line">		case server_hello_done:		ServerHelloDone;</span><br><span class="line">		case certificate_request:	CertificateRequest;</span><br><span class="line">		case client_key_exchange:	ClientKeyExchange;</span><br><span class="line">		case finished:						Finished;</span><br><span class="line">	&#125; body;</span><br><span class="line">&#125;Handshake;</span><br></pre></td></tr></table></figure>

<p>TSL 1.3协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	hello_request_RESERVERD(0);</span><br><span class="line">	client_hello(1),</span><br><span class="line">	server_hello(2),</span><br><span class="line">	hello_verify_request_RESERVED(3),</span><br><span class="line">	new_session_ticket(4),</span><br><span class="line">	end_of_early_data(5),</span><br><span class="line">	hello_retry_request_RESERVED(6),</span><br><span class="line">	encrypted_extensions(8),</span><br><span class="line">	certificate(11),</span><br><span class="line">	server_key_exchange_RESERVED(14),</span><br><span class="line">	certifycate_verify(15),</span><br><span class="line">	client_key_exchange_RESERVED(16),</span><br><span class="line">	finished(20),</span><br><span class="line">	certificate_url_RESERVED(21),</span><br><span class="line">	ceritificate_status_RESERVED(22),</span><br><span class="line">	supplemental_data_RESERVED(23),</span><br><span class="line">	key_update(24),</span><br><span class="line">	message_hash(254),</span><br><span class="line">	(255)</span><br><span class="line">&#125;HandshakeType;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">	HandshakeType msg_type;</span><br><span class="line">	unit24 length;</span><br><span class="line">	select(HandshakeType) &#123;</span><br><span class="line">		case client_hello:	ClientHello;</span><br><span class="line">    case server_hello:	ServerHello;</span><br><span class="line">    case end_of_early_data:	EndOfEarlyData;</span><br><span class="line">    case encrypted_extensions:	EncryptedExtensions;</span><br><span class="line">    case certificate_request:		CertificateRequest;</span><br><span class="line">    case certificate:						Certificate;</span><br><span class="line">    case certificate_verify:		CertificateVerify;</span><br><span class="line">    case finished:							Finished;</span><br><span class="line">    case new_session_ticket:		NewSessionTicket;</span><br><span class="line">    case key_update:						KeyUpdate</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、应用数据协议（application-data）"><a href="#5、应用数据协议（application-data）" class="headerlink" title="5、应用数据协议（application_data）"></a>5、应用数据协议（application_data）</h4><p>应用数据洗衣就是TLS上层的各种协议，TLS主要保护的数据就是应用数据协议的数据。</p>
<p>TLS记录层灰根据加密模式不同在应用数据的末尾加上MAC校验数据。</p>
<h4 id="6、TLS心跳协议（heartbeat）"><a href="#6、TLS心跳协议（heartbeat）" class="headerlink" title="6、TLS心跳协议（heartbeat）"></a>6、TLS心跳协议（heartbeat）</h4><p>TLS 1.3新增协议。</p>
<p>协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/05/16/RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/16/RunLoop/" class="post-title-link" itemprop="url">RunLoop</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-16 00:45:42" itemprop="dateCreated datePublished" datetime="2020-05-16T00:45:42+08:00">2020-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-18 15:25:36" itemprop="dateModified" datetime="2020-05-18T15:25:36+08:00">2020-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/05/13/load%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/13/load%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">+ Load vs + initialize</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-13 15:08:05" itemprop="dateCreated datePublished" datetime="2020-05-13T15:08:05+08:00">2020-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-14 17:29:55" itemprop="dateModified" datetime="2020-05-14T17:29:55+08:00">2020-05-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Load-vs-initialize"><a href="#Load-vs-initialize" class="headerlink" title="+ Load vs + initialize"></a><code>+ Load</code> vs <code>+ initialize</code></h3><h3 id="load"><a href="#load" class="headerlink" title="+ load"></a><code>+ load</code></h3><ul>
<li>load`方法的调用顺序</li>
</ul>
<p>首先通过<code>+ load</code>方法的调用栈，分析一下是如何被调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; insert code here...</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">@implementation MMPerson</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;MMPerson&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation MMPerson (BB)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;BB&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end </span><br><span class="line">  </span><br><span class="line">@implementation MMPerson (AA)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;AA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>文件编译顺序</p>
<img src="/Users/mikasa/Library/Application Support/typora-user-images/image-20200513152750308.png" alt="image-20200513152717723" style="zoom:50%;" />

<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-05-13 15:18:04.667822+0800 Load_initialize[66907:805301] MMPerson</span><br><span class="line">2020-05-13 15:18:09.267336+0800 Load_initialize[66907:805301] AA</span><br><span class="line">2020-05-13 15:18:09.267430+0800 Load_initialize[66907:805301] BB</span><br><span class="line">2020-05-13 15:18:09.267577+0800 Load_initialize[66907:805301] Hello, World!</span><br></pre></td></tr></table></figure>

<p>虽然在主函数中什么方法都没有调用，但是运行之后仍调用了MMPerson中的<code>+ load</code>方法，并且<code>+load</code>方法的调用在<code>main</code>函数之前</p>
<p>断点调试</p>
<p>在<code>MMPerson load</code>方法内加上断点，获取当前代码执行</p>
<p>![image-20200513154759631](/Users/mikasa/Library/Application Support/typora-user-images/image-20200513154759631.png)</p>
<h4 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h4><p><code>load_images</code>方法在objc-os.mm文件的<code>_objc_init</code>中找到调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br></pre></td></tr></table></figure>

<p>dyld是the dynamic link editor的缩写，它是苹果的动态链接器，在系统内核做好程序准备工作之后，剩下的交由dyld负责</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized &#x3D; false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h4><p>每当有新的镜像加载之后<code>_objc_init</code>，都会执行<code>_dyld_objc_notify_register</code>调用<code>load_images</code>方法，并传入最新镜像的<code>mach_header</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h4><p>调用<code>prepare_load_methods</code>查找当前类、父类、分类中的<code>+ load</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist &#x3D; </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist &#x3D; _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat &#x3D; categorylist[i];</span><br><span class="line">        Class cls &#x3D; remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  &#x2F;&#x2F; category for ignored weak-linked class</span><br><span class="line">        if (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(&quot;Swift class extensions and categories on Swift &quot;</span><br><span class="line">                        &quot;classes are not allowed to have +load methods&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="schedule-class-load"><a href="#schedule-class-load" class="headerlink" title="schedule_class_load"></a>schedule_class_load</h4><p><code>schedule_class_load</code>会获取当前类中实现了+ load方法的类，优先递归获取父类的load方法，保证父类调用load方法在子类之前，并将查找到的实现了 <code>+ load</code>方法的类存入loadable_classes列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会读取当前类的分类列表，按照编译顺序读取，依次获取分类中<code>+ load</code>方法的实现imp将其存入loadable_classes列表中</p>
<h4 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h4><p>call_load_methods方法会从待加载的列表loadable_classes中找到cls，然后找到imp并执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading &#x3D; NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading &#x3D; YES;</span><br><span class="line"></span><br><span class="line">    void *pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. Repeatedly call class +loads until there aren&#39;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. Call category +loads ONCE</span><br><span class="line">        more_categories &#x3D; call_category_loads();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading &#x3D; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、准备调用当前中loadable_classes中所有类，并执行+ load</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class="line">    int used &#x3D; loadable_classes_used;</span><br><span class="line">    loadable_classes &#x3D; nil;</span><br><span class="line">    loadable_classes_allocated &#x3D; 0;</span><br><span class="line">    loadable_classes_used &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls &#x3D; classes[i].cls;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、调用一次call_category_loads加载分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">static bool call_category_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, shift;</span><br><span class="line">    bool new_categories_added &#x3D; NO;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取当前可以加载的分类列表</span><br><span class="line">    struct loadable_category *cats &#x3D; loadable_categories;</span><br><span class="line">    int used &#x3D; loadable_categories_used;</span><br><span class="line">    int allocated &#x3D; loadable_categories_allocated;</span><br><span class="line">    loadable_categories &#x3D; nil;</span><br><span class="line">    loadable_categories_allocated &#x3D; 0;</span><br><span class="line">    loadable_categories_used &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat &#x3D; cats[i].cat;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (!cat) continue;</span><br><span class="line"></span><br><span class="line">        cls &#x3D; _category_getClass(cat);</span><br><span class="line">        &#x2F;&#x2F; 如果当前类是可加载的&#96;cls&#96; &amp;&amp; &#96;cls-&gt;isLoadable()&#96;就会调用分类</span><br><span class="line">        if (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            if (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat &#x3D; nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将所有加载过的分类从loadable_categories列表中移除</span><br><span class="line">    shift &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        if (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] &#x3D; cats[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -&#x3D; shift;</span><br><span class="line">    </span><br><span class="line">		&#x2F;&#x2F; 为loadable_categories重新分类内存，并重新设置他的值</span><br><span class="line">    &#x2F;&#x2F; Copy any new +load candidates from the new list to the detached list.</span><br><span class="line">    new_categories_added &#x3D; (loadable_categories_used &gt; 0);</span><br><span class="line">    for (i &#x3D; 0; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        if (used &#x3D;&#x3D; allocated) &#123;</span><br><span class="line">            allocated &#x3D; allocated*2 + 16;</span><br><span class="line">            cats &#x3D; (struct loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  sizeof(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] &#x3D; loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Destroy the new list.</span><br><span class="line">    if (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Reattach the (now augmented) detached list. </span><br><span class="line">    &#x2F;&#x2F; But if there&#39;s nothing left to load, destroy the list.</span><br><span class="line">    if (used) &#123;</span><br><span class="line">        loadable_categories &#x3D; cats;</span><br><span class="line">        loadable_categories_used &#x3D; used;</span><br><span class="line">        loadable_categories_allocated &#x3D; allocated;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (cats) free(cats);</span><br><span class="line">        loadable_categories &#x3D; nil;</span><br><span class="line">        loadable_categories_used &#x3D; 0;</span><br><span class="line">        loadable_categories_allocated &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        if (loadable_categories_used !&#x3D; 0) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取当前可以加载的分类列表</li>
<li>如果当前类是可记载的cls &amp;&amp; cls-&gt;isLoadable 就会调用分类</li>
<li>将所有加载过的分类从loadable_categories列表中移除</li>
<li>为loadable_categories重新分类内存，并重新设置它的值</li>
</ol>
<h3 id="load的应用"><a href="#load的应用" class="headerlink" title="load的应用"></a>load的应用</h3><p>load方法会在main函数之前调用，并且只调用一次，如果类和分类中都实现了这个方法，他都会调用，不像其他分类方法会被覆盖，这也使得+ load成为<strong>Swizzling Method</strong>绝佳方法</p>
<h3 id="initialize"><a href="#initialize" class="headerlink" title="+ initialize"></a><code>+ initialize</code></h3><p>+initialize方法是在类或者子类收到第一条消息之前被调用，这里的消息包括类方法、实例方法的调用，也就是说initialize方法是以懒加载的方式调用的，如果程序一直没有给类发送消息或者调用方法，initialize方法将一直不会被调用，这样做可以节省系统资源、避免浪费</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">    if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, class_initialize will send +initialize and </span><br><span class="line">        &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给某个类发送消息时，runtime会调用这个函数在类中查找相应方法的实现或进行消息转发。上述代码可以看出，当类没有进行初始化时，会调用_class_initialize进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  *  @brief   向任意未初始化的类发送 +initialize 消息。强制先初始化父类</span><br><span class="line">  *&#x2F;</span><br><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 父类</span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    &#x2F;&#x2F; See note about deadlock above.</span><br><span class="line">    &#x2F;&#x2F; 获取父类</span><br><span class="line">    supercls &#x3D; cls-&gt;superclass;</span><br><span class="line">    &#x2F;&#x2F; 父类存在 &amp;&amp; 父类还没有执行 initialized 方法</span><br><span class="line">    &#x2F;&#x2F; 有时候父类的 initialize 方法会被调用多次，这是由于当子类没有实现 initialize 方法时，会先调用父类的 initialize 方法（第一次），然后再调用自己的 initialize 方法，由于是通过 obj_msgSend 消息机制调用，通过 isa 找到类对象，如果没有则去父类中查找，找到再调用（第二次）</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归调用</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        &#x2F;&#x2F; We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Record that we&#39;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (MultithreadedForkChild) &#123;</span><br><span class="line">            &#x2F;&#x2F; LOL JK we don&#39;t really call +initialize methods after fork().</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Send the +initialize message.</span><br><span class="line">        &#x2F;&#x2F; Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        &#x2F;&#x2F; this class doesn&#39;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</span><br><span class="line">                         pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Exceptions: A +initialize call that throws an exception </span><br><span class="line">        &#x2F;&#x2F; is deemed to be a complete and successful +initialize.</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span><br><span class="line">        &#x2F;&#x2F; bootstrapping problem of this versus CF&#39;s call to</span><br><span class="line">        &#x2F;&#x2F; objc_exception_set_functions().</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 +initialize 消息</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</span><br><span class="line">                             &quot;threw an exception&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Done initializing.</span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码对类进行递归调用，确保父类优于子类初始化，标记当前类为正在进行初始化RW_INITIALIZING</p>
<h4 id="callInitialize"><a href="#callInitialize" class="headerlink" title="callInitialize"></a>callInitialize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>callInitialize使用objc_msgSend的方法对<code>+ initialize</code>进行调用，也就是说<code>+ initialize</code>方法的调用方式和普通方法的是一致的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface MMStudent : MMPerson</span><br><span class="line">@end</span><br><span class="line">@interface MMTeacher : MMPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ol>
<li><p>子类没有实现，继承自父类的实现会被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMPerson initialize</span><br><span class="line">MMPerson initialize</span><br><span class="line">MMTeacher initialize</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类有实现<code>+ initialize</code>，会先调用父类的<code>+ initialize</code>，再调用子类<code>+ initialize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMPerson initialize</span><br><span class="line">MMStudent initialize</span><br><span class="line">MMTeacher initialize</span><br></pre></td></tr></table></figure>
</li>
<li><p>分类如果实现了<code>+ initialize</code>，会对这个类的<code>+ initialize</code>进行覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AA-initialize</span><br><span class="line">MMStudent initialize</span><br><span class="line">MMTeacher initialize</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>因此，一个子类如果没有实现<code>+ initialize</code>方法，父类的<code>+ initialize</code>可能会被执行多次，为了避免代码的执行不是我们想要了，可以进行类判断</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>+ load</code>和<code>+ initialize</code></p>
<table>
<thead>
<tr>
<th></th>
<th>+ load</th>
<th>+ initialize</th>
</tr>
</thead>
<tbody><tr>
<td>调用时机</td>
<td>加载镜像时，main函数执行之前</td>
<td>收到方法调用（实例方法或者对象方法），否则也可能永远也不会调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类 &gt; 子类 &gt; 分类，编译顺序靠前的分类会被优先调用</td>
<td>父类 &gt; 子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>系统调用一次，手动调用多次，如果是父类，子类没有实现的情况下，会被多次调用</td>
</tr>
<tr>
<td>是否需要显示调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中实现</td>
<td>类和分类都会执行</td>
<td>分类会覆盖执行</td>
</tr>
</tbody></table>
<p>Q：<strong><code>load</code> 方法是如何被调用的？</strong></p>
<p>A：当 Objective-C 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入<em>运行时</em>的时候，进行回调。执行 <code>load_images</code> 将所有包含 <code>load</code> 方法的文件加入列表 <code>loadable_classes</code> ，然后从这个列表中找到对应的 <code>load</code> 方法的实现，调用 <code>load</code> 方法。</p>
<p>Q：<code>load</code>方法的调用顺序</p>
<p>A：main方法执行之前，父类优于子类，子类优于分类，分类取决于编译顺序</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/17/Cocoapods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/Cocoapods/" class="post-title-link" itemprop="url">Cocoapods</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-17 21:13:05" itemprop="dateCreated datePublished" datetime="2020-03-17T21:13:05+08:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-24 11:02:19" itemprop="dateModified" datetime="2020-07-24T11:02:19+08:00">2020-07-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Cocoapods升级"><a href="#Cocoapods升级" class="headerlink" title="Cocoapods升级"></a>Cocoapods升级</h2><h3 id="升级Cocoapods到最新版本"><a href="#升级Cocoapods到最新版本" class="headerlink" title="升级Cocoapods到最新版本"></a>升级Cocoapods到最新版本</h3><p>1、先切换gem源</p>
<p>gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></p>
<p>gem source -a <a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a></p>
<p>查看是否切换成功</p>
<p>gem source -l</p>
<p>打印出<strong>* CURRENT SOURCES *</strong></p>
<p>​      <a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a></p>
<p>就说明切换成功，如果还是官方的源, 请手动重启电脑尝试</p>
<p>2、接下来就可以开始升级了Cocoapods了</p>
<p>sudo gem install -n /usr/local/bin cocoapods –pre</p>
<p>3、然后敲下</p>
<p>pod –version</p>
<p>出现</p>
<p>1.2.0.beta.1</p>
<p>恭喜你, 安装成功</p>
<p>4、剩下的就是设置pod仓库了</p>
<p>pod setup</p>
<p>至此, 已经升级到Cocoapods1.1.1了, 可以愉快的把玩Swift3.0的一些三方库了</p>
<h3 id="升级Cocoapods到指定版本"><a href="#升级Cocoapods到指定版本" class="headerlink" title="升级Cocoapods到指定版本"></a>升级Cocoapods到指定版本</h3><p>a、在终端输入：sudo gem uninstall cocoapods输出下面</p>
<p>Select gem to uninstall:</p>
<p>\1. cocoapods-1.1.0.rc.2</p>
<p>\2. cocoapods-1.2.0.beta.1</p>
<p>\3. All versions</p>
<p>&gt;‘在此处输入要删除的版本，如：2’会输出下面</p>
<p>Successfully uninstalled cocoapods-1.1.1</p>
<p>b、在终端输入：sudo gem install cocoapods -v 1.1.1</p>
<p>输出：Fetching: cocoapods-1.1.1.gem (100%)</p>
<p>ERROR: While executing gem … (Errno::EPERM)</p>
<p>Operation not permitted - /usr/bin/pod</p>
<p>c、上面的方法不行，那咱们就换一种输入：sudo gem install -n /usr/local/bin cocoapods -v 1.1.1</p>
<p>输出：Successfully installed cocoapods-1.1.1</p>
<p>Parsing documentation for cocoapods-1.1.1</p>
<p>Installing ri documentation for cocoapods-1.1.1</p>
<p>1 gem installed</p>
<p>d、输入pod –version查看一下版本号</p>
<p>输出：1.1.1</p>
<p>成功解决ERROR: While executing gem … (Errno::EPERM) Operation not permitted - /usr/bin/pod问题，就可以使用1.1.1版本了</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="执行-pod-install-出现-“Failed-to-connect-to-github-com-port-443-Operation-timed-out”解决方案"><a href="#执行-pod-install-出现-“Failed-to-connect-to-github-com-port-443-Operation-timed-out”解决方案" class="headerlink" title="执行 pod install 出现 “Failed to connect to github.com port 443: Operation timed out”解决方案"></a>执行 pod install 出现 “Failed to connect to github.com port 443: Operation timed out”解决方案</h3><p>升级Cocoapods到1.9.0后执行pod install出现以下错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[!] Error installing Bugly</span><br><span class="line">[!] /usr/bin/curl -f -L -o /var/folders/2d/klrwscg57tsb6t7qpsc18fpm0000gn/T/d20200317-99220-1t7nt4g/file.zip https://raw.githubusercontent.com/BuglyDevTeam/Bugly-iOS/master/release/Bugly-2.5.2.zip --create-dirs --netrc-optional --retry 2</span><br><span class="line"></span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0</span><br><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>ping gitHub.com</code>出现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PING github.com (52.74.223.119): 56 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br></pre></td></tr></table></figure>

<p>一直处于超时状态，丢包率100%，但是网络没什么问题</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p>打开终端，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /private/etc/hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>将如下IP-域名映射信息复制到最后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">151.101.184.133 assets-cdn.github.com</span><br><span class="line">151.101.184.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.112.133 avatars1.githubusercontent.com</span><br><span class="line">199.232.4.133  raw.githubusercontent.com</span><br><span class="line">13.229.188.59 github.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次 ping github.com</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PING github.com (192.30.253.112): 56 data bytes</span><br><span class="line">64 bytes from 192.30.253.112: icmp_seq=0 ttl=48 time=308.088 ms</span><br><span class="line">64 bytes from 192.30.253.112: icmp_seq=1 ttl=48 time=302.332 ms</span><br><span class="line">64 bytes from 192.30.253.112: icmp_seq=2 ttl=48 time=301.365 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 pod install,顺利安装</p>
</li>
</ol>
<h3 id="pod-install时CDN-trunk-URL-couldn’t-be-downloaded-https-raw-githubusercontent-com-CocoaPods-Specs-master-Specs"><a href="#pod-install时CDN-trunk-URL-couldn’t-be-downloaded-https-raw-githubusercontent-com-CocoaPods-Specs-master-Specs" class="headerlink" title="pod install时CDN: trunk URL couldn’t be downloaded: https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/"></a>pod install时CDN: trunk URL couldn’t be downloaded: <a href="https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/" target="_blank" rel="noopener">https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/</a></h3><p>执行pod install一直出现 “CDN: trunk URL couldn’t be downloaded: <a href="https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/0/f/b/MJRefresh/3.4.3/MJRefresh.podspec.json" target="_blank" rel="noopener">https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/0/f/b/MJRefresh/3.4.3/MJRefresh.podspec.json</a> Response: Couldn’t connect to server”</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1.不替换cdn源：</p>
<p>步骤：1.终端执行sudo vim /private/etc/hosts</p>
<p>　　　2.在hosts文件中添加199.232.4.133  raw.githubusercontent.com的映射，重新执行pod install</p>
<p>2.用source ‘<a href="https://github.com/CocoaPods/Specs.git&#39;替换到cdn源" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git&#39;替换到cdn源</a></p>
<p>步骤：1.在podfile里面添加source ‘<a href="https://github.com/CocoaPods/Specs.git&#39;" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git&#39;</a></p>
<p>　　　2.终端下执行 pod repo remove trunk来移除trunk，重新pod install</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>进入 vi ~/.ssh/known_hosts，把  git.wanmeizhensuo.com 对应的那一行删除掉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/12/Objective-C-Runtime%E2%80%94%E2%80%94objc-msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/Objective-C-Runtime%E2%80%94%E2%80%94objc-msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/" class="post-title-link" itemprop="url">Objective-C Runtime——objc_msgSend消息发送和转发</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 22:45:43" itemprop="dateCreated datePublished" datetime="2020-03-12T22:45:43+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-06 15:43:08" itemprop="dateModified" datetime="2020-05-06T15:43:08+08:00">2020-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Objective-C作为基于Runtime的语言，它有着非常强大的动态特性，可以在运行期间自省、进行方法调剂、为类添加属性、方法、修改消息转发链路，在代码运行期间可以通过Runtime修改Objective-C层的一切类、属性、方法。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在很多语言中，比如C，调用一个方法就是跳到内存中的某一个点并开始执行一段代码。没有任何的动态的特性，因为这在编译时就决定好了，而在Object-C中，<code>[person run]</code>并不会立即执行run这个方法的代码，它在运行时给person发送一条run的消息，这个消息，也许会由person来处理，也许会被转发给另外一个对象，或者不予理睬假装没有收到这个消息。多条不同的消息也可以对应同一个方法的实现。</p>
<p>需要提前获知的信息：</p>
<ol>
<li>在Object-C中“方法调用”其实应该叫做“消息传递”</li>
<li><code>[person run]</code>会被翻译为objc_msgSend(person,@selector(run))</li>
<li>在消息的响应链路中可能会调用 <code>- resolveInstanceMethod:</code>或者<code>- forwardInvocation:</code>等方法</li>
</ol>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Sends a message with a simple return value to an instance of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param self A pointer to the instance of the class that is to receive the message.</span><br><span class="line"> * @param op The selector of the method that handles the message.</span><br><span class="line"> * @param ... </span><br><span class="line"> *   A variable argument list containing the arguments to the method.</span><br><span class="line"> * </span><br><span class="line"> * @return The return value of the method.</span><br><span class="line"> * </span><br><span class="line"> * @note When it encounters a method call, the compiler generates a call to one of the</span><br><span class="line"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</span><br><span class="line"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; </span><br><span class="line"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</span><br><span class="line"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</span><br><span class="line"> *&#x2F;</span><br><span class="line">objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure>

<p>当编译器遇到一个方法调用时，它会将方法的调用翻译成一下函数中的一个<code>objc_msgSend</code> <code>objc_msgSend_stret</code> <code>objc_msgSendSuper</code> <code>objc_msgSendSuper_stret</code>，发送给对象的父类的消息会使用会使用<code>objc_msgSendSuper</code>，有数据结构作为返回值的方法会调用<code>objc_msgSendSuper_stret</code> 或者<code>objc_msgSend_stret</code>，其他消息都是使用<code>objc_msgSend</code>发送</p>
<p><code>objc_msgSend</code>有两个参数，一个是对象结构成员中的receiver，一个是SEL</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents a method selector.</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>

<p>要传递的消息都会通过@selector()转换成<code>objc_msgSend</code>的一个参数传递进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person run] ——&gt; objc_msgSend(person, @selector(run))</span><br></pre></td></tr></table></figure>

<p>objc_selector是一个映射到方法的C字符串，需要注意的是：</p>
<ol>
<li>使用selector()生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了，也就是说向不同的类发送相同的消息时，生成的选择子是一样的，选择子只与方法名相关，即使方法相同参数变量类型不同也会导致他们具有相同的选择子。这也是OC不支持重栽的原因</li>
<li>Objective-C为我们维护了一个巨大的选择子表</li>
<li>在使用@selector()时，会从这个选择子表中根据选择子的名称查找对应的SEL，如果没有找到，则会生成一个SEL并添加到表中</li>
<li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用的@selector()生成的选择子添加到选择子表中</li>
</ol>
<h4 id="objc-msgSend源码解析"><a href="#objc-msgSend源码解析" class="headerlink" title="objc_msgSend源码解析"></a><a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html" target="_blank" rel="noopener">objc_msgSend源码解析</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/objc-runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">id  <span class="title">c_objc_msgSend</span><span class="params">( struct objc_class <span class="comment">/* ahem */</span> *self, SEL _cmd, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span>    *<span class="title">cls</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span>    *<span class="title">cache</span>;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>         hash;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span>   *<span class="title">method</span>;</span>   </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>         index;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>( self)</span><br><span class="line">   &#123;</span><br><span class="line">      cls   = self-&gt;isa;</span><br><span class="line">      cache = cls-&gt;cache;</span><br><span class="line">      hash  = cache-&gt;mask;</span><br><span class="line">      index = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) _cmd &amp; hash;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">         method = cache-&gt;buckets[ index];</span><br><span class="line">         <span class="keyword">if</span>( ! method)</span><br><span class="line">            <span class="keyword">goto</span> recache;</span><br><span class="line">         index = (index + <span class="number">1</span>) &amp; cache-&gt;mask;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>( method-&gt;method_name != _cmd);</span><br><span class="line">      <span class="keyword">return</span>( (*method-&gt;method_imp)( (id) self, _cmd));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>( (id) self);</span><br><span class="line"></span><br><span class="line">recache:</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">   <span class="keyword">return</span>( <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中的方法do-while循环就是在当前类中的方法分发表中查找method的过程</p>
<p>另外在objc-msg-x86_64.s文件中有一段相关的汇编代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * id objc_msgSend(id self, SEL	_cmd,...);</span></span><br><span class="line"><span class="comment"> * IMP objc_msgLookup(id self, SEL _cmd, ...);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * objc_msgLookup ABI:</span></span><br><span class="line"><span class="comment"> * IMP returned in r11</span></span><br><span class="line"><span class="comment"> * Forwarding returned in Z flag</span></span><br><span class="line"><span class="comment"> * r10 reserved for our use but not used</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line">	</span><br><span class="line">	.data</span><br><span class="line">	.align <span class="number">3</span></span><br><span class="line">	.globl _objc_debug_taggedpointer_classes</span><br><span class="line">_objc_debug_taggedpointer_classes:</span><br><span class="line">	.<span class="built_in">fill</span> <span class="number">16</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line">	.globl _objc_debug_taggedpointer_ext_classes</span><br><span class="line">_objc_debug_taggedpointer_ext_classes:</span><br><span class="line">	.<span class="built_in">fill</span> <span class="number">256</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		<span class="comment">// r10 = self-&gt;isa</span></span><br><span class="line">	CacheLookup NORMAL, CALL	<span class="comment">// calls IMP on success</span></span><br><span class="line"></span><br><span class="line">	NilTestReturnZero NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache miss: go search the method lists</span></span><br><span class="line">LCacheMiss:</span><br><span class="line">	<span class="comment">// isa still in r10</span></span><br><span class="line">	jmp	__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgLookup</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		<span class="comment">// r10 = self-&gt;isa</span></span><br><span class="line">	CacheLookup NORMAL, LOOKUP	<span class="comment">// returns IMP on success</span></span><br><span class="line"></span><br><span class="line">	NilTestReturnIMP NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache miss: go search the method lists</span></span><br><span class="line">LCacheMiss:</span><br><span class="line">	<span class="comment">// isa still in r10</span></span><br><span class="line">	jmp	__objc_msgLookup_uncached</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgLookup</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgSend_fixup</span><br><span class="line">	int3</span><br><span class="line">	END_ENTRY _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	STATIC_ENTRY _objc_msgSend_fixedup</span><br><span class="line">	<span class="comment">// Load _cmd from the message_ref</span></span><br><span class="line">	movq	<span class="number">8</span>(%a2), %a2</span><br><span class="line">	jmp	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_fixedup</span><br></pre></td></tr></table></figure>

<p>拆开来看，objc_msgSend首先会去尝试查找缓存CacheLookup，当缓存中无法找到时候会去执行MethodTableLookup方法查找，MethodTableLookup可以算是一个接口层宏，主要用户保存环境和准备参数，调用__class_lookupMethodAndLoadCache3方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _class_lookupMethodAndLoadCache.</span><br><span class="line">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</span><br><span class="line">* This lookup avoids optimistic cache scan because the dispatcher </span><br><span class="line">* already tried that.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES&#x2F;*initialize*&#x2F;, NO&#x2F;*cache*&#x2F;, YES&#x2F;*resolver*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_class_lookupMethodAndLoadCache3函数也是个接口层，此函数提供相应的参数配置，实际功能在lookUpImpOrForward中</p>
<h5 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span></span><br><span class="line"><span class="comment">* Most callers should use initialize==YES and cache==YES.</span></span><br><span class="line"><span class="comment">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span></span><br><span class="line"><span class="comment">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span></span><br><span class="line"><span class="comment">* May return _objc_msgForward_impcache. IMPs destined for external use </span></span><br><span class="line"><span class="comment">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span></span><br><span class="line"><span class="comment">*   If you don't want forwarding at all, use lookUpImpOrNil() instead.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">/*…… 中间为查找过程 ……*/</span></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐行解析一下</p>
<ol>
<li><p>runtimeLock.assertUnlocked();这是加一个读写锁，保证线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.assertUnlocked();</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否查找缓存的IMP，如果传入YES，则调用cache_getImp方法去查找缓存中IMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">if (cache) &#123;</span><br><span class="line">    imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cache_getImp的具体实现也是具体的编译指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> * IMP cache_getImp(Class cls, SEL sel)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On entry:	a1 = class whose cache is to be searched</span></span><br><span class="line"><span class="comment"> *		a2 = selector to search for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If found, returns method implementation.</span></span><br><span class="line"><span class="comment"> * If not found, returns NULL.</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY _cache_getImp</span><br><span class="line"></span><br><span class="line"><span class="comment">// do lookup</span></span><br><span class="line">	movq	%a1, %r10		<span class="comment">// move class to r10 for CacheLookup</span></span><br><span class="line">	CacheLookup NORMAL, GETIMP	<span class="comment">// returns IMP on success</span></span><br><span class="line"></span><br><span class="line">LCacheMiss:</span><br><span class="line"><span class="comment">// cache miss, return nil</span></span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY _cache_getImp</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验当前类是否已被加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* isKnownClass</span><br><span class="line">* Return true if the class is known to the runtime (located within the</span><br><span class="line">* shared cache, within the data segment of a loaded image, or has been</span><br><span class="line">* allocated with obj_allocateClassPair).</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static bool isKnownClass(Class cls) &#123;</span><br><span class="line">    &#x2F;&#x2F; The order of conditionals here is important for speed. We want to</span><br><span class="line">    &#x2F;&#x2F; put the most common cases first, but also the fastest cases</span><br><span class="line">    &#x2F;&#x2F; first. Checking the shared region is both fast and common.</span><br><span class="line">    &#x2F;&#x2F; Checking allocatedClasses is fast, but may not be common,</span><br><span class="line">    &#x2F;&#x2F; depending on what the program is doing. Checking if data segments</span><br><span class="line">    &#x2F;&#x2F; contain the address is slow, so do it last.</span><br><span class="line">    return (sharedRegionContains(cls) ||</span><br><span class="line">            NXHashMember(allocatedClasses, cls) ||</span><br><span class="line">            dataSegmentsContain(cls));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断当前类是否被初始化，进行首次初始化，分配读写数据，返回真实类结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        cls &#x3D; realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化类的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, class_initialize will send +initialize and </span><br><span class="line">        &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为在运行时中会动态的添加方法，为了保证线程安全，所有加了一个读锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试从缓存列表IMP中获取IMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Try this class&#39;s cache.</span><br><span class="line">imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试从类的方法列表中获取方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Try this class&#39;s method lists.</span><br><span class="line">&#123;</span><br><span class="line">    Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    if (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp &#x3D; meth-&gt;imp;</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试从父类及层次结构链中查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line">&#123;</span><br><span class="line">    unsigned attempts &#x3D; unreasonableClassCount();</span><br><span class="line">    for (Class curClass &#x3D; cls-&gt;superclass;</span><br><span class="line">         curClass !&#x3D; nil;</span><br><span class="line">         curClass &#x3D; curClass-&gt;superclass)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">        if (--attempts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass cache.</span><br><span class="line">        imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            if (imp !&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">                log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass method list.</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果都没有找到IMP实现，尝试进行一次方法决议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    resolveMethod(cls, sel, inst);</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    &#x2F;&#x2F; Don&#39;t cache the result; we don&#39;t hold the lock so it may have </span><br><span class="line">    &#x2F;&#x2F; changed already. Re-do the search from scratch instead.</span><br><span class="line">    triedResolver &#x3D; YES;</span><br><span class="line">    goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开读锁，因为在此开发者可能会动态增加方法实现，不需要缓存结果，但是此处锁被打开可能会出现线程问题，所以执行结束后会<code>goto retry;</code>，重新执行一边之前的查找过程</p>
</li>
<li><p>如果在<code>resolveMethod</code>方法结束后仍没有找到IMP的实现，method resolver也失效了，那么只能进行消息转发阶段了，在进入这个阶段之前，imp变成了<code>_objc_msgForward_impcache</code>，加入到缓存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help. </span><br><span class="line">&#x2F;&#x2F; Use forwarding.</span><br><span class="line"></span><br><span class="line">    imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="消息转发Message-Forwarding阶段"><a href="#消息转发Message-Forwarding阶段" class="headerlink" title="消息转发Message Forwarding阶段"></a>消息转发Message Forwarding阶段</h4><ol>
<li><p>当<code>_objc_msgForward_impcache</code>被存储在方法缓存中时，会调用<code>id _objc_msgForward(id self, SEL _cmd,...);</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line">*</span><br><span class="line">* id _objc_msgForward(id self, SEL _cmd,...);</span><br><span class="line">*</span><br><span class="line">* _objc_msgForward is the externally-callable</span><br><span class="line">*   function returned by things like method_getImplementation().</span><br><span class="line">* _objc_msgForward_impcache is the function pointer actually stored in</span><br><span class="line">*   method caches.</span><br><span class="line">*</span><br><span class="line">********************************************************************/</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	// No stret specialization.</span><br><span class="line">	b	__objc_msgForward</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">	adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">	TailCallFunctionPointer x17</span><br><span class="line">	</span><br><span class="line">	END_ENTRY __objc_msgForward</span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgSend_noarg</span><br><span class="line">	b	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_noarg</span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend_debug</span><br><span class="line">	b	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_debug</span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSendSuper2_debug</span><br><span class="line">	b	_objc_msgSendSuper2</span><br><span class="line">	END_ENTRY _objc_msgSendSuper2_debug</span><br><span class="line"></span><br><span class="line">	ENTRY _method_invoke</span><br><span class="line">	// x1 is method triplet instead of SEL</span><br><span class="line">	add	p16, p1, #METHOD_IMP</span><br><span class="line">	ldr	p17, [x16]</span><br><span class="line">	ldr	p1, [x1, #METHOD_NAME]</span><br><span class="line">	TailCallMethodListImp x17, x16</span><br><span class="line">	END_ENTRY _method_invoke</span><br></pre></td></tr></table></figure>

<p>执行<code>__objc_msgForward</code>方法后，会调用<code>__objc_forward_handler</code>函数</p>
</li>
<li><p>在objc-runtime文件中，<code>void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</code>,<code>objc_defaultForwardHandler</code>函数中可以看到我们常见的报错信息unrecognized selector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Default forward handler halts the process.</span><br><span class="line">__attribute__((noreturn)) void </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler &#x3D; (void*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要设置转发只要重写<code>_objc_forward_handler</code>函数即可，在<code>objc_setForwardHandler</code>函数中可以设置forward_handler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void objc_setForwardHandler(void *fwd, void *fwd_stret)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_forward_handler &#x3D; fwd;</span><br><span class="line">#if SUPPORT_STRET</span><br><span class="line">    _objc_forward_stret_handler &#x3D; fwd_stret;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>等等</li>
</ol>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Check for ignored selectors (GC) and short-circuit.</span><br><span class="line"> 2. Check for nil target.</span><br><span class="line">    If nil &amp; nil receiver handler configured, jump to handler</span><br><span class="line">    If nil &amp; no handler (default), cleanup and return.</span><br><span class="line"> 3. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache)</span><br><span class="line">    -1. If found, jump to it.</span><br><span class="line">    -2. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain.</span><br><span class="line">        If found, load it into cache and jump to it.</span><br><span class="line">        If not found, jump to forwarding mechanism.</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查选择子selector是不是要忽略</p>
</li>
<li><p>检查target是否为nil</p>
</li>
<li><p>在该类class的方法缓存列表中查找方法对呀的IMP实现，如果找到就跳转进去执行</p>
<p>如果没有找到，就在当前类及层次结构链中的方法列表中查找方法的IMP实现</p>
</li>
<li><p>如果还是没有找到，跳转进入消息转发机智</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/10/Objective-C%20Runtime%E2%80%94%E2%80%94objc_object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/Objective-C%20Runtime%E2%80%94%E2%80%94objc_object/" class="post-title-link" itemprop="url">Objective-C Runtime——objc_object</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-10 16:36:42" itemprop="dateCreated datePublished" datetime="2020-03-10T16:36:42+08:00">2020-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-12 22:43:14" itemprop="dateModified" datetime="2020-03-12T22:43:14+08:00">2020-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Object-c中我们知道，所有类均继承自NSObject，那么NSObject具体是什么呢？</p>
<h3 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直观看到的是NSObject类中只有一个类型为Class的isa指针，那么我们重点关注一下Class类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; initIsa() should be used to init the isa of new objects only.</span><br><span class="line">    &#x2F;&#x2F; If this object already has an isa, use changeIsa() for correctness.</span><br><span class="line">    &#x2F;&#x2F; initInstanceIsa(): objects with no custom RR&#x2F;AWZ</span><br><span class="line">    &#x2F;&#x2F; initClassIsa(): class objects</span><br><span class="line">    &#x2F;&#x2F; initProtocolIsa(): protocol objects</span><br><span class="line">    &#x2F;&#x2F; initIsa(): other objects</span><br><span class="line">    void initIsa(Class cls &#x2F;*nonpointer&#x3D;false*&#x2F;);</span><br><span class="line">    void initClassIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">    void initProtocolIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">    void initInstanceIsa(Class cls, bool hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line">  </span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>objc_object结构体中包含一个<code>isa_t</code>类型的结构体isa，而<code>objc_class</code>继承自<code>objc_object</code>，表明<code>objc_class</code>也会包含isa_t类型的结构体isa。</p>
<p>objc_class除了isa之外还有三个成员，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法列表。</p>
<p>![image-20200310221249637](/Users/mikasa/Library/Application Support/typora-user-images/image-20200310221249637.png)</p>
<p>当对象的实例方法被调用时，会通过isa找到对应的Class，然后在该类的bits中查找对应的方法，<code>bits.data()</code>获取类对象的数据区域，在该区域中可以查找对应的方法和对应的实现。</p>
<p>当类的类方法被调用时，会通过isa找到对应的元类（meta-class）,查找方法的机制与对象一致</p>
<p>总结：</p>
<p>对象方法被调用时，通过对象的isa在类中获取方法的实现</p>
<p>类方法被调用时，通过类的isa在元类中获取方法的实现</p>
<h3 id="Meta-Class"><a href="#Meta-Class" class="headerlink" title="Meta-Class"></a><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">Meta-Class</a></h3><p>每个类都会有一个单独的meta-class，meta-class中存储着这个类的所有方法</p>
<blockquote>
<p>The meta-class, like the <code>Class</code> before it, is also an object. This means that you can invoke methods on it too. Naturally, this means that it must also have a class.</p>
<p>All meta-classes use the base class’ meta-class (the meta-class of the top <code>Class</code> in their inheritance hierarchy) as their class. This means that for all classes that descend from <code>NSObject</code> (most classes), the meta-class has the <code>NSObject</code> meta-class as its class.</p>
<p>Following the rule that all meta-classes use the base class’ meta-class as their class, any base meta-classes will be its own class (their <code>isa</code> pointer points to themselves). This means that the <code>isa</code> pointer on the <code>NSObject</code> meta-class points to itself (it is an instance of itself).</p>
</blockquote>
<p>This means that the <code>isa</code> pointer on the <code>NSObject</code> meta-class points to itself (it is an instance of itself).这也意味着NSObject元类上的isa指针指向着元类它自己</p>
<p>如下对应图，描述了基类、元类、对象三者之间的关系</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23_7.png" alt="23_7"></p>
<p>添加代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)clickCell_1 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]);</span><br><span class="line">    </span><br><span class="line">    Class currentClass &#x3D; [self class];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;%@ the isa pointer %d times gives %p&quot;, currentClass,i, currentClass);</span><br><span class="line">        currentClass &#x3D; object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;NSObject&#39;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&#39;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This object is 0x7fa88fd05280.</span><br><span class="line">Class is MMViewController, and super is MMBaseViewController.</span><br><span class="line">MMViewController the isa pointer 1 times gives 0x10087daf0</span><br><span class="line">MMViewController the isa pointer 2 times gives 0x10087db18</span><br><span class="line">NSObject the isa pointer 3 times gives 0x1027e61d8</span><br><span class="line">NSObject the isa pointer 4 times gives 0x1027e61d8</span><br><span class="line"></span><br><span class="line">NSObject&#39;s class is 0x1027e6200</span><br><span class="line">NSObject&#39;s meta class is 0x1027e61d8</span><br></pre></td></tr></table></figure>

<ol>
<li>基类（NSObject）没有超类，所以基类的supperClass指向nil</li>
<li>每个Class都有唯一的isa指针指向meta-class，意味着每个类都有自己唯一的方法列表，同时意味着每个类对象本身并不是同一个类</li>
<li>meta-class的supperClass指向NSObject，形成回路</li>
<li>每个meta-class的isa指针都指向基类的meta-class，基类的meta-class的isa指针也指向自身</li>
</ol>
<p>objc_object关系图：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image-20200311232447574.png" alt="image-20200311232447574"></p>
<h3 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t"></a>isa_t</h3><p>isa_t是一个union联合体，联合体的所有成员会占用同一段内存，修改一个成员会影响其余所有成员，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Objc_object结构体中三个初始化个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void initIsa(Class cls &#x2F;*nonpointer&#x3D;false*&#x2F;);</span><br><span class="line">void initClassIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">void initProtocolIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">void initInstanceIsa(Class cls, &#x2F;*nonpointer&#x3D;true*&#x2F;bool hasCxxDtor);</span><br></pre></td></tr></table></figure>

<p>最终都会调到<code>objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa.cls &#x3D; cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line">        isa &#x3D; newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SUPPORT_INDEXED_ISA</p>
<blockquote>
<p>表示 isa_t 中存放的 Class 信息是 Class 的地址，还是一个索引(根据该索引可在类信息表中查找该类结构地址)。经测试，iOS 设备上 SUPPORT_INDEXED_ISA 是 0。 </p>
</blockquote>
<p>ISA_MAGIC_VALUE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                      \</span><br><span class="line">      uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">      uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">      uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">      uintptr_t deallocating      : 1;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">      uintptr_t extra_rc          : 19</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line"></span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                        \</span><br><span class="line">      uintptr_t nonpointer        : 1;                                         \</span><br><span class="line">      uintptr_t has_assoc         : 1;                                         \</span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                         \</span><br><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                         \</span><br><span class="line">      uintptr_t weakly_referenced : 1;                                         \</span><br><span class="line">      uintptr_t deallocating      : 1;                                         \</span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                         \</span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</span><br></pre></td></tr></table></figure>

<p>has_cxx_dtor</p>
<blockquote>
<p>表示对象是否有C++或者Objc的析构器</p>
</blockquote>
<p>has_assoc</p>
<blockquote>
<p>对象含有或者曾经含有关联音乐，没有关联引用的可以更快的释放内存</p>
</blockquote>
<p>shiftcls</p>
<blockquote>
<p>类的指针，源码中<code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</code>表示将当前地址右移三位，用于将Class指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8bits）对其内存，其指针后三位都是没有意义的0。</p>
</blockquote>
<p>magic</p>
<blockquote>
<p>判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间</p>
</blockquote>
<p>weakly_referenced</p>
<blockquote>
<p>对象被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以被尽快释放</p>
</blockquote>
<p>deallocating</p>
<blockquote>
<p>对象是否正在释放内存</p>
</blockquote>
<p>has_sidetable_rc</p>
<blockquote>
<p>判断该对象的引用计数器是否过大，如果过大则需要其他的散列表来存储</p>
</blockquote>
<p>extra_rc</p>
<blockquote>
<p>存放该对象的引用计数值减1后的结果。对象引用计数超过1，会存在这个里面，如果引用计数为10，extra_rc为9</p>
</blockquote>
<p>ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23_8.png" alt="23_8"></p>
<p>ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001，结构如下图：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23_9.png" alt="23_9"></p>
<p>参数说明：</p>
<p>第一位index，代表是否开启isa指针优化，1表示开启</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">Tagged Pointer</a></h3><p>关于taggerPointer，在 2013 年 9 月，苹果推出了<a href="http://en.wikipedia.org/wiki/IPhone_5S" target="_blank" rel="noopener"> iPhone5s </a>，与此同时，iPhone5s 配备了首个采用 64 位架构的<a href="http://en.wikipedia.org/wiki/Apple_A7" target="_blank" rel="noopener"> A7 双核处理器</a>，为了节省内存和提高执行效率，苹果提出了<code>Tagged Pointer</code>的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p>
<p>为什么能减少近一半的内存占用呢？假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。</p>
<p>所以一个普通的 iOS 程序，如果没有<code>Tagged Pointer</code>对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23-10.png" alt="23-10"></p>
<p>从效率上来看，为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>为了改进上面提到的内存占用和效率问题，苹果提出了taggedPointer对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：2^31=2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。</p>
<p>所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了<code>Tagged Pointer</code>对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/23-11.png" alt="23-11"></p>
<p>可见，当 8 字节可以承载用于表示的数值时，系统就会以<code>Tagged Pointer</code>的方式生成指针，如果 8 字节承载不了时，则又用以前的方式来生成普通的指针。关于以上关于<code>Tag Pointer</code>的存储细节，我们也可以在<a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">这里</a>找到相应的讨论，但是其中关于<code>Tagged Pointer</code>的实现细节与我们的实验并不相符，笔者认为可能是苹果更改了具体的实现细节，并且这并不影响<code>Tagged Pointer</code>我们讨论<code>Tagged Pointer</code>本身的优点</p>
<p>taggedPointer特点：</p>
<ol>
<li><code>Tagged Pointer</code>专门用来存储小的对象，例如<code>NSNumber</code>和<code>NSDate</code></li>
<li><code>Tagged Pointer</code>指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free。</li>
<li>在内存读取上有着 3 倍的效率，创建时比以前快 106 倍。</li>
<li>Tagged Pointer并不是真正的对象，直接访问其isa指针会有编译警告问题，实际使用过程中也不要直接访问</li>
</ol>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    &#x2F;&#x2F; IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    &#x2F;&#x2F; SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__</span><br><span class="line">    uintptr_t _imp;</span><br><span class="line">    SEL _sel;</span><br><span class="line">#else</span><br><span class="line">    SEL _sel;</span><br><span class="line">    uintptr_t _imp;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;  &#x2F;&#x2F; x86_64 &amp; arm64 asm are less efficient with 16-bits</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/image-20200311164228160.png" alt="image-20200311164228160"></p>
<p>cache_t结构中有三个成员，一个bucket_t的结构体和两个unsigned int的变量</p>
<p>_mask ：分配缓存bucket的总数</p>
<p>_occupied：表示目前实际占用的缓存buckets的个数</p>
<p>bucket_t结构体中存储了一个unsigned long和一个IMP(unsigned long)。IMP是一个函数指针，指向了一个方法的具体实现</p>
<p>_buckets其实就是一个散列表，用来存储Method的链表。</p>
<p>cache_t的主要作用是为了优化方法调用的性能，当对象receiver调用方法message时，首先根据对象receiver的isa指针找到他对应的类，然后在类的methodList中搜索方法，如果没有找到就使用supper_class指针到父类的methodLists中查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也有可能忽略它。但是这种查找方式效率太低，往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用chache来缓存经常调用的方法，在调用方法时，首先在cache中查找，再到methodLists查找。</p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">		class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    const class_ro_t *safe_ro() &#123;</span><br><span class="line">    	……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint32_t index;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/image-20200311170751822.png" alt="image-20200311170751822"></p>
<p>class_data_bits_t 相当于class_rw_t 指针加上r r/alloc的标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br></pre></td></tr></table></figure>

<p>class_rw_t中存放着类的属性、方法和遵循的协议，class_ro_t是一个指向了常量的指针，存放着编译器决定了的属性、方法和遵循的协议。</p>
<h3 id="realizeClassWithoutSwift"><a href="#realizeClassWithoutSwift" class="headerlink" title="realizeClassWithoutSwift"></a>realizeClassWithoutSwift</h3><p>在运行时调用<code>realizeClassWithoutSwift</code>方法，会进行以下几件事情：</p>
<ol>
<li>对类cls执行首次初始化</li>
<li>分配读写数据，初始化一个class_rw_t结构体</li>
<li>设置ro的指和<code>rw-&gt;flags = RW_REALIZED|RW_REALIZING</code></li>
<li>设置supperCls和meta-cls</li>
<li>调用<code>methodizeClass</code>，加载类的属性、协议和方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">tatic void methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line">    auto ro &#x3D; rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Methodizing for the first time</span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: methodizing class &#39;%s&#39; %s&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Install methods and properties that the class implements itself.</span><br><span class="line">    method_list_t *list &#x3D; ro-&gt;baseMethods();</span><br><span class="line">    if (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *proplist &#x3D; ro-&gt;baseProperties;</span><br><span class="line">    if (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protocol_list_t *protolist &#x3D; ro-&gt;baseProtocols;</span><br><span class="line">    if (protolist) &#123;</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Root classes get bonus method implementations if they don&#39;t have </span><br><span class="line">    &#x2F;&#x2F; them already. These apply before category replacements.</span><br><span class="line">    if (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        &#x2F;&#x2F; root metaclass</span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach categories.</span><br><span class="line">    category_list *cats &#x3D; unattachedCategoriesForClass(cls, true &#x2F;*realizing*&#x2F;);</span><br><span class="line">    attachCategories(cls, cats, false &#x2F;*don&#39;t flush caches*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        if (cats) &#123;</span><br><span class="line">            for (uint32_t i &#x3D; 0; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </span><br><span class="line">                             isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (cats) free(cats);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; Debug: sanity-check all SELs; log method list contents</span><br><span class="line">    for (const auto&amp; meth : rw-&gt;methods) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</span><br><span class="line">        &#125;</span><br><span class="line">        assert(sel_registerName(sel_getName(meth.name)) &#x3D;&#x3D; meth.name); </span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在runtime初始化之前，<code>realizeClassWithoutSwift</code>之前，在class_data_bits_t结构体中获取到的data，并不是class_rw_t结构体，而是class_ro_t</p>
<ol>
<li>类的一些方法、属性、遵守协议是在编译期决定的（baseMethods等成员在以及类在内存中的位置都是在编译器决定的），之后在修改代码也不会改变内存中的位置</li>
<li>类的方法、属性、遵守协议在编译期被存放在只读区域class_ro_t中，直到<code>realizeClassWithoutSwift</code>执行后被加载存放到class_rw_t中</li>
<li>class_ro_t中成员变量列表用指向常量的指针<code>const ivar_list_t * ivars;</code>，class_rw_t结构中无此成员</li>
<li>运行时采用category添加方法时，会修改class_rw_t的methods列表，而不会影响到class_ro_t中的baseMethods</li>
</ol>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法method_t结构体中有三个成员，SEL是方法的name，types是Type Encoding类型编码，类型可参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a>，IMP是一个指针，指向的是函数的具体实现，runtime中的消息传递和消息转发的目的就是为了找到IMP，并执行函数</p>
<h3 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ivar_t &#123;</span><br><span class="line">    int32_t *offset;&#x2F;&#x2F;偏移</span><br><span class="line">    const char *name;&#x2F;&#x2F; 变量名</span><br><span class="line">    const char *type;&#x2F;&#x2F; Type Encoding</span><br><span class="line">    uint32_t alignment_raw;&#x2F;&#x2F; 对齐</span><br><span class="line">    uint32_t size;&#x2F;&#x2F; 大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化类函数<code>realizeClassWithoutSwift</code>中有这么一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reconcile instance variable offsets &#x2F; layout.</span><br><span class="line">&#x2F;&#x2F; This may reallocate class_ro_t, updating our ro variable.</span><br><span class="line">if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br></pre></td></tr></table></figure>

<p>根据官方注释，<code>reconcileInstanceVariables</code>这个方法很有可能就是用来重新分配class_ro_t以及调整Ivar的offset的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void reconcileInstanceVariables(Class cls, Class supercls, const class_ro_t*&amp; ro)</span><br><span class="line">&#123;</span><br><span class="line">    class_rw_t *rw &#x3D; cls-&gt;data();</span><br><span class="line">    </span><br><span class="line">    if (ro-&gt;instanceStart &gt;&#x3D; super_ro-&gt;instanceSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; Superclass has not overgrown its space. We&#39;re done here.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    if (ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; Superclass has changed size. This class&#39;s ivars must move.</span><br><span class="line">        &#x2F;&#x2F; Also slide layout bits in parallel.</span><br><span class="line">        &#x2F;&#x2F; This code is incapable of compacting the subclass to</span><br><span class="line">        &#x2F;&#x2F;   compensate for a superclass that shrunk, so don&#39;t do that.</span><br><span class="line">        class_ro_t *ro_w &#x3D; make_ro_writeable(rw);</span><br><span class="line">        ro &#x3D; rw-&gt;ro;</span><br><span class="line">        moveIvars(ro_w, super_ro-&gt;instanceSize);</span><br><span class="line">        gdb_objc_class_changed(cls, OBJC_CLASS_IVARS_CHANGED, ro-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>instanceStart</code>代表当前类的成员变量开始的偏移量，<code>instanceSize</code>表示当前类的成员变量（包括父类）的大小。发现当子类的开始偏移量小于父类的变量大小的时候，也就是说此事两个类的变量地址有可能是重叠的，这个时候需要<code>moveIvars</code>来调整子类的开始偏移量</p>
<p><code>static void moveIvars(class_ro_t *ro, uint32_t superSize)</code></p>
<ol>
<li><p>获取最大的对齐字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Find maximum alignment in this class&#39;s ivars</span><br><span class="line">uint32_t maxAlignment &#x3D; 1;</span><br><span class="line">for (const auto&amp; ivar : *ro-&gt;ivars) &#123;</span><br><span class="line">    if (!ivar.offset) continue;  &#x2F;&#x2F; anonymous bitfield</span><br><span class="line"></span><br><span class="line">    uint32_t alignment &#x3D; ivar.alignment();</span><br><span class="line">    if (alignment &gt; maxAlignment) maxAlignment &#x3D; alignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整所有变量的偏移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Compute a slide value that preserves that alignment</span><br><span class="line">uint32_t alignMask &#x3D; maxAlignment - 1;</span><br><span class="line">diff &#x3D; (diff + alignMask) &amp; ~alignMask;&#x2F;&#x2F; 通过该位操作可得到应该在diff的位置以maxAlignment 对齐时偏移的字节数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Slide all of this class&#39;s ivars en masse</span><br><span class="line">&#x2F;&#x2F; 调整所有的offset</span><br><span class="line">for (const auto&amp; ivar : *ro-&gt;ivars) &#123;</span><br><span class="line">    if (!ivar.offset) continue;  &#x2F;&#x2F; anonymous bitfield</span><br><span class="line"></span><br><span class="line">    uint32_t oldOffset &#x3D; (uint32_t)*ivar.offset;</span><br><span class="line">    uint32_t newOffset &#x3D; oldOffset + diff;</span><br><span class="line">    *ivar.offset &#x3D; newOffset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整子类的的instanceStart和instanceSize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(uint32_t *)&amp;ro-&gt;instanceStart +&#x3D; diff;</span><br><span class="line">*(uint32_t *)&amp;ro-&gt;instanceSize +&#x3D; diff;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>NSObject</code>只有一个变量<code>isa</code>，作为根类，<code>instanceSize</code>为0，<code>instanceSize</code>则为8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface TestIvar : NSObject&#123;</span><br><span class="line">  NSString *_ivarStr;</span><br><span class="line">&#125;</span><br><span class="line">@property(nonatomic, assign) NSInteger propertyInt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/23.12.png" alt="23.12"></p>
<p><code>TestIvar</code>中有两个变量，<code>instanceStart</code>刚好接在父类的后面， <code>instanceSize</code>为两个变量的大小+父类的<code>instanceSize</code>。这样类的内存布局就很清晰了，<code>isa</code>变量放在第一位，接下来先是父类的按顺序排放，最后子类的接在后面。</p>
<h4 id="IvarLayout"><a href="#IvarLayout" class="headerlink" title="IvarLayout"></a>IvarLayout</h4><p><code>class_ro_t</code>中有两个变量<code>ivarLayout</code>和<code>weakIvarLayout</code>，是用来记录变量那些是<code>strong</code>的，哪些是<code>weak</code>的，在<code>object_getIvar</code>中有通过<code>_class_lookUpIvar</code>获取变量的<code>objc_ivar_memory_management_t</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_class_lookUpIvar(Class cls, Ivar ivar, ptrdiff_t&amp; ivarOffset, </span><br><span class="line">                  objc_ivar_memory_management_t&amp; memoryManagement)</span><br><span class="line">&#123;</span><br><span class="line">    ivarOffset &#x3D; ivar_getOffset(ivar);</span><br><span class="line">		Class ivarCls &#x3D; _class_getClassForIvar(cls, ivar);</span><br><span class="line">    if (ivarCls-&gt;hasAutomaticIvars()) &#123;</span><br><span class="line">        &#x2F;&#x2F; ARC layout bitmaps encode the class&#39;s own ivars only.</span><br><span class="line">        &#x2F;&#x2F; Use alignedInstanceStart() because unaligned bytes at the start</span><br><span class="line">        &#x2F;&#x2F; of this class&#39;s ivars are not represented in the layout bitmap.</span><br><span class="line">        ptrdiff_t localOffset &#x3D; </span><br><span class="line">            ivarOffset - ivarCls-&gt;alignedInstanceStart();</span><br><span class="line"></span><br><span class="line">        if (isScanned(localOffset, class_getIvarLayout(ivarCls))) &#123;</span><br><span class="line">            memoryManagement &#x3D; objc_ivar_memoryStrong;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isScanned(localOffset, class_getWeakIvarLayout(ivarCls))) &#123;</span><br><span class="line">            memoryManagement &#x3D; objc_ivar_memoryWeak;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Unretained is only for true ARC classes.</span><br><span class="line">        if (ivarCls-&gt;isARC()) &#123;</span><br><span class="line">            memoryManagement &#x3D; objc_ivar_memoryUnretained;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memoryManagement &#x3D; objc_ivar_memoryUnknown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断变量的偏移量<code>localOffset</code>跟<code>ivarLayout</code>和<code>weakIvarLayout</code>来对比，来判断是<code>strong</code>还是<code>weak</code>的。</p>
<h4 id="为什么不能动态的添加Ivar"><a href="#为什么不能动态的添加Ivar" class="headerlink" title="为什么不能动态的添加Ivar"></a>为什么不能动态的添加Ivar</h4><p>假设我们已经有上面的类<code>TestIvar</code>,之后我们在运行期给类NSObject动态的添加了一个变量a，此时a的内存地址就会紧接着isa，由于此时没有调整所有变量的offset，那么TestIvar._ivarStr和NSObject.A就会有内存重叠，导致出现错误。这样NSObject所有子类都有可能出现这个问题</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>变量Ivar都是在编译期生成的，并且所有子类的变量都排在父类的后面</li>
<li>ivarLayout和weakIvarLayout分别代表着strong和weak变量的分布</li>
<li>运行期不能动态添加Ivar，如果在运行期动态添加Ivar，可能会导致所有子类无法正常使用</li>
</ol>
<h3 id="property-t"><a href="#property-t" class="headerlink" title="property_t"></a>property_t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>property在iOS中由ivar+setter+getter组成，也就是说当声明一个属性，编译器会自动生成一个ivar和两个Method</p>
<p>关于<code>attributes</code>具体参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW24" target="_blank" rel="noopener">Declared Properties</a>。</p>
<h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><h4 id="self-class-和-supper-class"><a href="#self-class-和-supper-class" class="headerlink" title="[self class]和[supper class]"></a>[self class]和[supper class]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)clickCell_3 &#123;   </span><br><span class="line">    NSLog(@&quot;%@&quot;,[self class]);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[super class]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里被啪啪打脸，本来以为输出的应该是MMViewController 和 UIViewController，但是实际输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MMViewController</span><br><span class="line">MMViewController</span><br></pre></td></tr></table></figure>

<p>self：是类的一个隐藏参数</p>
<p>supper：是预编译指令，它告诉编译器，当调用方法时，去调用父类的方法，而不是本类的方法</p>
<p>当调用<code>[supper class]</code>时，runtime会去调用objc_msgSendSuper方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在objc_msgSendSuper方法中，第一个参数是objc_super结构体，这个结构体中有两个变量，一个是</p>
<p>接收消息的receiver也就是当前类（子类），另外一个是当前类的父类super_class</p>
<p>objc_msgSendSuper的工作原理：</p>
<p>从objc_supper结构体指向的supperClass父类的方法列表开始查找selector，找到后以objc-receiver去调用父类的这个selector。</p>
<p>那么<code>objc_msgSendSuper</code>会转换成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(objc_super-&gt;receiver, @selector(class))</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是当[supper class]执行完毕了，也就相当于是objc_supper-&gt;receiver(self) 执行IMP，这里[self class] 和 [supper class]执行完毕后输出一样。</p>
<h4 id="isKindOfClass-与-isMemberOfClass"><a href="#isKindOfClass-与-isMemberOfClass" class="headerlink" title="isKindOfClass 与 isMemberOfClass"></a>isKindOfClass 与 isMemberOfClass</h4><h5 id="isKindOfClass"><a href="#isKindOfClass" class="headerlink" title="isKindOfClass"></a>isKindOfClass</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    return self-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    return [self class]-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; object_getClass((id)self); tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>+ (BOOL)isKindOfClass:(Class)cls</code> 方法会先通过<code>object_getClass</code>获取当前类的meta-class,判断cls是否与当前类的meta-class相等，接着会遍历当前类的supperClass的meta-class，再去判断cls是否与supperClass的meta-class相等</p>
<p>根据前面对于meta-class的了解，我们知道，只有当cls为[NSObject class]时，当前类的meta-class才能获取到cls==meta-class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanItemModel isKindOfClass:[MMDoubanModel class]]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanItemModel isKindOfClass:[NSObject class]]);</span><br><span class="line">&#x2F;&#x2F;打印如下</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>- (BOOL)isKindOfClass:(Class)cls</code>实例方法会通过<code>- (Class)class</code>获取当前的对象的class，判断cls是否与当前对象的类相等，接着遍历类的supperclass，再对比当前类是否与cls相同，通过这种方法一旦发现当前对象的类 或者 其父类中有一个能与cls匹配，那么认定校验为YES。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface MMDoubanItemModel : MMDoubanModel</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">MMDoubanItemModel *doubanModel &#x3D; [MMDoubanItemModel new];</span><br><span class="line">NSLog(@&quot;%d&quot;,[doubanModel isKindOfClass:[MMDoubanModel class]]);</span><br><span class="line">&#x2F;&#x2F; 打印如下</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="isMemberOfClass"><a href="#isMemberOfClass" class="headerlink" title="isMemberOfClass"></a>isMemberOfClass</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return object_getClass((id)self) &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>+ (BOOL)isMemberOfClass:(Class)cls</code>方法通过<code>object_getClass</code>获取当前类的meta-class，与当前cls进行对比，根据前面对于meta-class的了解，只有当前当前类为基类（NSObject）,并且cls也为NSObject才会返回YES，这个方法其实是meta-class对比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanModel isMemberOfClass:objc_getMetaClass([NSStringFromClass([MMDoubanModel class]) UTF8String])]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[MMDoubanItemModel isMemberOfClass:[MMDoubanModel class]]);</span><br><span class="line">&#x2F;&#x2F; 打印如下</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><code>- (BOOL)isMemberOfClass:(Class)cls</code>对象方法获取当前对象的isa指针，与传进来的类的isa进行对比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MMDoubanItemModel *doubanModel &#x3D; [MMDoubanItemModel new];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%d&quot;,[doubanModel isMemberOfClass:[MMDoubanModel class]]);</span><br><span class="line">NSLog(@&quot;%d&quot;,[doubanModel isMemberOfClass:[MMDoubanItemModel class]]);</span><br><span class="line">&#x2F;&#x2F; 打印</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="Class与内存地址"><a href="#Class与内存地址" class="headerlink" title="Class与内存地址"></a>Class与内存地址</h4><blockquote>
<p>举个🌰，下面的代码会？Compile Error/Runtime Crash/NSLog…？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface MMDoubanModel : NSObject</span><br><span class="line">- (void)douban;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MMDoubanModel</span><br><span class="line">- (void)douban &#123;</span><br><span class="line">    NSLog(@&quot;my name&#39;s %@&quot;, self.title);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)clickCell_5 &#123;</span><br><span class="line">    id cls &#x3D; [MMDoubanModel class];</span><br><span class="line">    void *obj &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)obj douban];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>疑问一，能不能调用douban方法？会不会出现Runtime Crash？</p>
<p>答案是可以的。cls使用id转换成objc_object类型，<code>void *obj = &amp;cls;</code>表示obj指向的是一个objc_object类型的对象地址，obj可以说已经是一个MMDoubanModel类型的实例对象了。</p>
<p>疑问二，调用douban方法，会输出什么呢？()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一次打印</span><br><span class="line">my name&#39;s (null)--&lt;MMDoubanModel: 0x7ffee4382898&gt;</span><br><span class="line">&#x2F;&#x2F; 第二次打印</span><br><span class="line">my name&#39;s MMViewController--&lt;MMDoubanModel: 0x7ffee4382898&gt;</span><br></pre></td></tr></table></figure>

<p>未完待续，这个结果有点懵！！！</p>
<p>至此，Objc中的对象到底是什么呢？</p>
<p>实质：Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/06/jekins-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/jekins-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">jekins+单元测试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-06 23:39:58 / Modified: 23:49:17" itemprop="dateCreated datePublished" datetime="2020-03-06T23:39:58+08:00">2020-03-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Jekins环境我们已经有了，单元测试可以参考[XCTest]相关的，这里简单说下如何创建单元测试job以及利用Jekins生成Junit的单元测试报告</p>
<h3 id="1、和之前持续化集成的步骤相同，新建一个MMTest-Test的Job"><a href="#1、和之前持续化集成的步骤相同，新建一个MMTest-Test的Job" class="headerlink" title="1、和之前持续化集成的步骤相同，新建一个MMTest_Test的Job"></a>1、和之前持续化集成的步骤相同，新建一个MMTest_Test的Job</h3><h3 id="2、增加构建Execute-shell"><a href="#2、增加构建Execute-shell" class="headerlink" title="2、增加构建Execute shell"></a>2、增加构建Execute shell</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild test -workspace MMTest.xcworkspace -scheme MMTest -sdk iphonesimulator13.0 -destination OS=13.0,name="iPhone 11" -configuration Debug 2&gt;&amp;1 | ocunit2junit</span><br></pre></td></tr></table></figure>

<p>这里设置的单元测试是在模拟器上上进行的，如果测试服务器连接着iOS设备，也可以设置在iOS设备中进行，只需修改上述shell的参数即可</p>
<h4 id="2-1-查看当前项目信息，执行命令"><a href="#2-1-查看当前项目信息，执行命令" class="headerlink" title="2.1 查看当前项目信息，执行命令"></a>2.1 查看当前项目信息，执行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -list</span><br></pre></td></tr></table></figure>

<p>可以看到当前MMTest项目Targets、Build、Schemes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Information about project &quot;MMTest&quot;:</span><br><span class="line">    Targets:</span><br><span class="line">        MMTest</span><br><span class="line">        MMTestTests</span><br><span class="line">        MMTestUITests</span><br><span class="line">        GMServiceExtension</span><br><span class="line"> </span><br><span class="line">    Build Configurations:</span><br><span class="line">        Debug</span><br><span class="line">        UnitTest</span><br><span class="line">        Release</span><br><span class="line">        AppStore</span><br><span class="line"> </span><br><span class="line">    If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.</span><br><span class="line"> </span><br><span class="line">    Schemes:</span><br><span class="line">        MMTest</span><br><span class="line">        MMTest-AppStore</span><br><span class="line">        GMServiceExtension</span><br></pre></td></tr></table></figure>



<h4 id="2-2-查看当前服务器Xcode-sdk版本"><a href="#2-2-查看当前服务器Xcode-sdk版本" class="headerlink" title="2.2 查看当前服务器Xcode sdk版本"></a>2.2 查看当前服务器Xcode sdk版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -showsdks</span><br></pre></td></tr></table></figure>

<p>在没有真机连接的情况下，测试服务器上版本如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iOS SDKs:</span><br><span class="line">    iOS 13.0                        -sdk iphoneos13.0</span><br><span class="line"> </span><br><span class="line">iOS Simulator SDKs:</span><br><span class="line">    Simulator - iOS 13.0            -sdk iphonesimulator13.0</span><br><span class="line"> </span><br><span class="line">macOS SDKs:</span><br><span class="line">    DriverKit 19.0                  -sdk driverkit.macosx19.0</span><br><span class="line">    macOS 10.15                     -sdk macosx10.15</span><br><span class="line"> </span><br><span class="line">tvOS SDKs:</span><br><span class="line">    tvOS 13.0                       -sdk appletvos13.0</span><br><span class="line"> </span><br><span class="line">tvOS Simulator SDKs:</span><br><span class="line">    Simulator - tvOS 13.0           -sdk appletvsimulator13.0</span><br><span class="line"> </span><br><span class="line">watchOS SDKs:</span><br><span class="line">    watchOS 6.0                     -sdk watchos6.0</span><br><span class="line"> </span><br><span class="line">watchOS Simulator SDKs:</span><br><span class="line">    Simulator - watchOS 6.0         -sdk watchsimulator6.0</span><br></pre></td></tr></table></figure>



<h4 id="2-3-通过指定schema获取当前支持的destination"><a href="#2-3-通过指定schema获取当前支持的destination" class="headerlink" title="2.3 通过指定schema获取当前支持的destination"></a>2.3 通过指定schema获取当前支持的destination</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -showdestinations -scheme MMTest</span><br></pre></td></tr></table></figure>

<p>打印如下，有真机连接的情况，这里应该也可以获取到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Available destinations for the "MMTest" scheme:</span><br><span class="line">        &#123; platform:iOS Simulator, id:A1E89E7A-D771-49DC-B593-2C30B3C04A6D, OS:13.0, name:iPad Air (3rd generation) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:DAAF8FA0-7FF7-47E4-B93B-7FA3A0367043, OS:13.0, name:iPad Pro (9.7-inch) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:41FFCDB7-460E-4B01-A18F-BAE4049476B5, OS:13.0, name:iPad Pro (11-inch) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:F7133775-46B4-4C21-896E-4296F2179FDA, OS:13.0, name:iPad Pro (12.9-inch) (3rd generation) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:B28FB262-94CA-40AD-9118-20F8BAFFAC88, OS:13.0, name:iPhone 8 &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:5E62CB73-DC9D-4E36-A055-DE900078E51E, OS:13.0, name:iPhone 8 Plus &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:4B700323-428C-447D-8D6A-3E672C4F9F22, OS:13.0, name:iPhone 11 &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:24BEE8EB-CC92-40BD-B416-6C011777F7AE, OS:13.0, name:iPhone 11 Pro &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:7D982993-8383-461F-9CBB-553AEF1A7C9D, OS:13.0, name:iPhone 11 Pro Max &#125;</span><br><span class="line"> </span><br><span class="line">    Ineligible destinations for the "MMTest" scheme:</span><br><span class="line">        &#123; platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Generic iOS Device &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Generic iOS Simulator Device &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-4-2-gt-amp-1"><a href="#2-4-2-gt-amp-1" class="headerlink" title="2.4  2&gt;&amp;1"></a>2.4  2&gt;&amp;1</h4><p>2&gt;&amp;1  意思是把 标准错误输出 重定向到 标准输出</p>
<p>这里的测试输出结果既有正常输出内容又有错误输出内容</p>
<h3 id="3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本"><a href="#3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本" class="headerlink" title="3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本"></a>3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本</h3><p>安装OCUnit2JUnit，执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install ocunit2junit</span><br></pre></td></tr></table></figure>



<h3 id="4、测试报告"><a href="#4、测试报告" class="headerlink" title="4、测试报告"></a>4、测试报告</h3><p>点击“Add post-build action”选择“Publish JUnit test result report”，输入内容test-reports/*.xml保存设置</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/06/%E6%90%AD%E5%BB%BAJekins-Sonarqube%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/%E6%90%AD%E5%BB%BAJekins-Sonarqube%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">搭建Jekins+Sonarqube环境</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-06 17:30:37 / Modified: 18:22:09" itemprop="dateCreated datePublished" datetime="2020-03-06T17:30:37+08:00">2020-03-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Jekins环境已有，那么就直接准备Sonarqube吧</p>
<ol>
<li><p>安装<a href="https://www.sonarqube.org/downloads/" target="_blank" rel="noopener">Sonarqube</a>)</p>
<p>解压到/usr/local/下</p>
</li>
<li><p>安装<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdownloads%2Fmysql%2F" target="_blank" rel="noopener">MySql</a></p>
<p>虽然SonarQube自带了H2数据库，但是为了方便管理数据推荐使用Mysql数据库</p>
</li>
</ol>
<ol start="3">
<li>首先确保安装了jdk1.8 +</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/05/%E9%A6%96%E9%A1%B5%E4%BC%98%E5%8C%96%E4%B9%8B%E2%80%94%E2%80%94%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/%E9%A6%96%E9%A1%B5%E4%BC%98%E5%8C%96%E4%B9%8B%E2%80%94%E2%80%94%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">首页优化之——离屏渲染</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-05 21:13:25 / Modified: 21:29:36" itemprop="dateCreated datePublished" datetime="2020-03-05T21:13:25+08:00">2020-03-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首页作为最大访问量的页面，页面流畅度怎么样？会不会存在多余的CPU计算、GPU渲染占用额外资源问题？视图图层还有没有可优化的空间？App体验很重要，一款流畅的app会给用户带来不一样的使用感受。</p>
<h1 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenGL中，GPU屏幕渲染方式中有两种，一种当前屏幕渲染，一种为离屏渲染</p>
<p>On-Screen Rendering（当前屏幕渲染）</p>
<p>GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行</p>
<p>Off-Screen Rendering（离屏渲染）</p>
<p>GPU的渲染操作是在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作，处理不好离屏渲染往往会对APP的性能产生较大的影响</p>
<h3 id="为什么离屏渲染往往会对APP的性能产生较大的影响"><a href="#为什么离屏渲染往往会对APP的性能产生较大的影响" class="headerlink" title="为什么离屏渲染往往会对APP的性能产生较大的影响?"></a>为什么离屏渲染往往会对APP的性能产生较大的影响?</h3><p>想要进行离屏渲染，首先得创建一个屏幕外缓冲区，屏幕渲染会有一个上下文环境的概念，离屏渲染的整个过程需要切换上下文环境，先从当前屏幕切换到离屏，等渲染完成后又需要再切换回来，触发离屏渲染后，这样的转换发生在每一帧，在页面发生滚动的过程中出现大量离屏渲染，会严重影响帧率；</p>
<p>由于垂直同步机制的机制，如果一个ASync时间内容GPU没有完成渲染任务，提交到帧缓冲区，那么这一帧就会被丢弃，等到下一次机会再显示，而屏幕则依旧展示上一次内容，也就是我们看到的界面卡顿。</p>
<h3 id="既然离屏渲染这么耗性能，为什么有这套机制呢？"><a href="#既然离屏渲染这么耗性能，为什么有这套机制呢？" class="headerlink" title="既然离屏渲染这么耗性能，为什么有这套机制呢？"></a><strong>既然离屏渲染这么耗性能，为什么有这套机制呢？</strong></h3><p>有些效果被认为不能直接显示在屏幕上，而需要在别的地方做预合成。图层属性的混合体在没有被预合成之前不能直接在屏幕上绘制，这时就需要离屏渲染。离屏渲染并不意味着软件绘制，但是它意味着图层在被绘制到屏幕上前必须在一个屏幕外上下文环境中被渲染合成（不论是CPU 还是GPU）</p>
<h3 id="怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？"><a href="#怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？" class="headerlink" title="怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？"></a>怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？</h3><p>1、缓存已经合成的纹理图，复用缓存位图，但这样只能在位图不会发生变化的前提下使用，在一些场景下位图的失效，或者还需要被使用的位图也有可能被GPU丢弃的情况下，需要额外的计算来校验位图的是否可用情况；</p>
<p>2、既然离屏渲染的关键点在于两次昂贵的环境切换（转换环境到屏幕外缓冲区，再转换环境到帧缓冲区），文章<a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕</a>中也有提到“直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多”</p>
<h2 id="哪些情况会引发离屏渲染"><a href="#哪些情况会引发离屏渲染" class="headerlink" title="哪些情况会引发离屏渲染"></a>哪些情况会引发离屏渲染</h2><ul>
<li>为图层设置遮罩（layer.mask）</li>
<li>将图层的layer.masksToBounds / view.clipsToBounds属性设置为true</li>
<li>将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0</li>
<li>为图层设置阴影（layer.shadow *）</li>
<li>为图层设置layer.shouldRasterize=true（光栅化）</li>
<li>具有layer.cornerRadius，layer.edgeAntialiasingMask（抗锯齿），layer.allowsEdgeAntialiasing的图层</li>
<li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）</li>
<li>使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅只是一个空的实现</li>
</ul>
<h2 id="检测项目中离屏渲染"><a href="#检测项目中离屏渲染" class="headerlink" title="检测项目中离屏渲染"></a>检测项目中离屏渲染</h2><h3 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h3><p>模拟器的 debug -&gt; 选取 Color Off-screen Rendered</p>
<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_15-58-38.png?version=1&amp;modificationDate=1583395119000&amp;api=v2" alt="img" style="zoom:80%;" />

<p>打开后会把需要离屏渲染的部分高亮为黄色，表明这些黄色图层可能存在性能问题</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_15-59-8.png" alt="img"></p>
<p>可以看出搜索栏、Banner设置圆角、卡片设置圆角的图层出现了离屏渲染的问题</p>
<p>1、搜索栏、Banner圆角设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.layer.masksToBounds &#x3D; YES;</span><br><span class="line">self.layer.cornerRadius &#x3D; self.height &#x2F; 2;</span><br></pre></td></tr></table></figure>

<p>取消圆角设置，卡片上的黄色图层随机消失，可以看出图层的layer.masksToBounds / view.clipsToBounds属性设置为true会引发离屏渲染</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-17-35.png" alt="img"></p>
<p>2、卡片圆角设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)containerRectCorner:(CGSize)cornerRadii byRoundingCorners:(UIRectCorner)corners &#123;</span><br><span class="line">    UIBezierPath *maskPath &#x3D; [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:corners cornerRadii:cornerRadii];</span><br><span class="line">    CAShapeLayer *maskLayer &#x3D; [[CAShapeLayer alloc] init];</span><br><span class="line">    maskLayer.frame &#x3D; self.bounds;</span><br><span class="line">    maskLayer.path &#x3D; maskPath.CGPath;</span><br><span class="line">    self.layer.mask &#x3D; maskLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当把卡片圆角设置取消掉，卡片上的黄色图层随机消失，表明当我们直接为图层设置遮罩（layer.mask），是会引发离屏渲染的</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-17-16.png" alt="img"></p>
<p>3、更改View的Alpha小于1</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-13-58.png" alt="img"></p>
<p>在这里，其实我们是在滑动过程中更新segment的Alpha值，当Alpha&lt;1时，可以看出出现离屏渲染的情况，而当alpha=1时，则黄色消失</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-16-11.png" alt="img"></p>
<h3 id="Instrument检测"><a href="#Instrument检测" class="headerlink" title="Instrument检测"></a>Instrument检测</h3><p>Instrument 的 Core Animation 工具检查 <em>Color Hits Green and Misses Red</em> 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>
<h2 id="方案优化"><a href="#方案优化" class="headerlink" title="方案优化"></a>方案优化</h2><h3 id="圆角优化"><a href="#圆角优化" class="headerlink" title="圆角优化"></a>圆角优化</h3><p><strong>1、设置shouldRasterize=true（光栅化）</strong></p>
<p>缓存可以使离屏渲染的结果缓存到内存中存为位图， 使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新 创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.layer.shouldRasterize &#x3D; YES; </span><br><span class="line">self.layer.rasterizationScale &#x3D; [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>



<p><strong>2、使用Core Graphics 绘制圆角</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)mm_addRounderCornerWithRadius:(CGFloat)radius &#123;</span><br><span class="line"> </span><br><span class="line">    CGSize size &#x3D; self.bounds.size;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, 0);</span><br><span class="line">    CGContextRef cxt &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSetFillColorWithColor(cxt, [UIColor whiteColor].CGColor);</span><br><span class="line">    CGContextSetStrokeColorWithColor(cxt, [UIColor redColor].CGColor);</span><br><span class="line">    CGContextSetLineWidth(cxt, 0.5);</span><br><span class="line">    CGContextMoveToPoint(cxt, 0, radius);</span><br><span class="line">    CGContextAddArcToPoint(cxt, 0, 0, radius, 0, radius);&#x2F;&#x2F; 左上角</span><br><span class="line">    CGContextAddArcToPoint(cxt, size.width, 0, size.width, radius, radius);&#x2F;&#x2F; 右上角</span><br><span class="line">    CGContextAddArcToPoint(cxt, size.width, size.height ,size.width-radius, size.height, radius);&#x2F;&#x2F; 右下角</span><br><span class="line">    CGContextAddArcToPoint(cxt, 0, size.height, 0, size.height-radius, radius);&#x2F;&#x2F; 左下角</span><br><span class="line">    CGContextSetLineCap(cxt, kCGLineCapRound);</span><br><span class="line">    CGContextSetLineJoin(cxt, kCGLineJoinRound);</span><br><span class="line">    CGContextClosePath(cxt);</span><br><span class="line">    CGContextDrawPath(cxt, kCGPathFillStroke);</span><br><span class="line">    UIImage *image &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"> </span><br><span class="line">    UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, size.width, size.height)];</span><br><span class="line">    [imageView setImage:image];</span><br><span class="line">    [self insertSubview:imageView atIndex:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2、使用贝塞尔曲线UIBezierPath和Core Graphics框架画出一个圆角</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawImageRoundedCorners:(UIRectCorner)corners</span><br><span class="line">                      withRadii:(CGSize)radii &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;开始对imageView进行画图</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(rect.size, NO, 1);</span><br><span class="line">    &#x2F;&#x2F;使用贝塞尔曲线画出一个圆形图</span><br><span class="line">    CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    [[UIColor redColor] setStroke];</span><br><span class="line">    [[UIColor whiteColor] setFill];</span><br><span class="line">    UIBezierPath *bezierPath &#x3D; [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</span><br><span class="line">    [bezierPath addClip];</span><br><span class="line">    CGContextAddPath(ctx, bezierPath.CGPath);</span><br><span class="line">    CGContextDrawPath(ctx, kCGPathFillStroke);</span><br><span class="line">    UIImage *image &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    &#x2F;&#x2F;结束画图</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"> </span><br><span class="line">    UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:self.bounds];</span><br><span class="line">    imageView.image &#x3D; image;</span><br><span class="line">    [self insertSubview:imageView atIndex:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_16-49-19.png?version=1&modificationDate=1583398160000&api=v2" alt="img"></p>
<p><strong>左1 右2</strong></p>
<p><strong>3、使用CAShapeLayer和UIBezierPath设置圆角</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)addRoundedCorners:(UIRectCorner)corners</span><br><span class="line">                withRadii:(CGSize)radii</span><br><span class="line">                fillColor:(CGColorRef)fillColor</span><br><span class="line">              borderColor:(CGColorRef)borderColor</span><br><span class="line">              borderWidth:(CGFloat)borderWidth &#123;</span><br><span class="line">     </span><br><span class="line">    UIBezierPath *rounded &#x3D; [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:corners cornerRadii:radii];</span><br><span class="line">    CAShapeLayer *shape &#x3D; [[CAShapeLayer alloc] init];</span><br><span class="line">    shape.frame &#x3D; self.bounds;</span><br><span class="line">    shape.strokeColor &#x3D; borderColor;</span><br><span class="line">    shape.fillColor &#x3D; fillColor;</span><br><span class="line">    shape.lineWidth &#x3D; borderWidth;</span><br><span class="line">    shape.path &#x3D; rounded.CGPath;</span><br><span class="line">    [self.layer addSublayer:shape];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><p><strong>以上2、3、4无论哪一种方法，都不能为View设置背景颜色</strong></p>
<p>因为我们没有设置masksToBounds，超出圆角的部分仍然会显示</p>
<p><strong>在使用UIGraphicsGetCurrentContext()尝试获取当前上下文进行绘制时，发现拿到的一直是nil</strong></p>
<p>原因是，在调用 drawRect前，视图对象会先往栈上压入一个有效的上下文并使它成为当前上下文。所以在drawRect方法中可以通过UIGraphicsGetCurrentContext()获取到上下文。但是在其他地方可能会获取到为nil,需要自己创建一个上下文如果</p>
<p>能够只用 <code>cornerRadius</code> 解决问题，就不用优化。 </p>
<p>如果必须设置 <code>masksToBounds</code>，可以参考圆角视图的数量，如果数量较少（一页只有几个）也可以考虑不用优化。 </p>
<p><code>UIImageView</code> 的圆角通过直接截取图片实现，其它视图的圆角可以通过 Core Graphics 画出圆角矩形实现。</p>
<p><a href="http://www.cocoachina.com/articles/12873" target="_blank" rel="noopener">layer.mask与layer.cornerRadius测试对比</a></p>
<p>实现圆角cornerRadius要比mask高效很多。</p>
<p>Rasterize在大部分情况下极大减少GPU工作。在有空间的情况下，大部分情况下缓存总能帮到你</p>
<p>后台预处理图片也能很简单帮上你很大的忙。</p>
<h4 id="关于cornerRadius属性的解释"><a href="#关于cornerRadius属性的解释" class="headerlink" title="关于cornerRadius属性的解释"></a><code>关于cornerRadius属性的解释</code></h4><blockquote>
<p>By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to true causes the content to be clipped to the rounded corners.</p>
</blockquote>
<p>也就是说在默认情况下，cornerRadius这个属性只会影响背景颜色和layer的border属性，而不会影响View的contents属性，只有当设置masksToBounds为True的时候，才会影响View的content</p>
<h3 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h3><p>通常设置阴影的方式为,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.layer.shadowColor &#x3D; shadowColor.CGColor;</span><br><span class="line">self.layer.shadowOffset &#x3D; shadowOffset;</span><br><span class="line">self.layer.shadowOpacity &#x3D; shadowOpacity;</span><br><span class="line">self.layer.shadowRadius &#x3D; shadowRadius;</span><br></pre></td></tr></table></figure>

<p>另外一种设置阴影的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)addShadow:(UIColor *)shadowColor shadowOpacity:(CGFloat)shadowOpacity shadowRadius:(CGFloat)shadowRadius shadowOffset:(CGSize)shadowOffset shadowFrame:(CGRect)shadowFrame &#123;</span><br><span class="line">    self.layer.shadowColor &#x3D; shadowColor.CGColor;</span><br><span class="line">    self.layer.shadowOffset &#x3D; shadowOffset;</span><br><span class="line">    self.layer.shadowOpacity &#x3D; shadowOpacity;</span><br><span class="line">    self.layer.shadowRadius &#x3D; shadowRadius;</span><br><span class="line">    self.layer.masksToBounds &#x3D; NO;</span><br><span class="line">    UIBezierPath *path &#x3D; [UIBezierPath bezierPathWithRect:shadowFrame];</span><br><span class="line">    self.layer.shadowPath &#x3D; path.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们看下效果</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_18-24-47.png?version=1&modificationDate=1583403888000&api=v2" alt="img"></p>
<p>左侧出现了我们的Off-Screen Render Yellow，也就是检测出来离屏渲染，这里的区别就是，默认shadowPath为nil，仅开启阴影(没有指定路径，同屏数量10个以上)在滚动时帧率会大幅下降，检测到离屏渲染的黄色特征；指定一个与边界相同的简单路径后离屏渲染特征消失，帧率恢复正常。</p>
<p><strong>测试结果（结果来源于 <a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a>）</strong></p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_18-27-27.png?version=1&modificationDate=1583404048000&api=v2" alt="img"></p>
<p>为阴影指定路径确实可以作为阴影优化的一点，“除了指定路径，实现良好性能阴影的方法还有：用圆角优化里混合图层的方法模拟阴影的效果：放一个同样效果的视图在要添加阴影程度的视图的下方；使用 Core Graphics 绘制阴影，不过除非万不得已没人想碰 Core Graphics API。从实现成本来讲，都不如指定路径方便。这两种方法实现简单形状的阴影比较方便，比如图中左侧和中间的效果，面对右侧的阴影效果就不好弄了，用指定路径的方法实现也比较麻烦。</p>
<h3 id="Mask"><a href="#Mask" class="headerlink" title="Mask"></a>Mask</h3><p>一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和它下面包含的像素合并之前都会把 mask 应用到图层的像素上去，当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板</p>
<p>前面看到过，当我们为一个View设置圆角时，同样也可以通过Mask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)addRoundedCorners:(UIRectCorner)corners</span><br><span class="line">                withRadii:(CGSize)radii &#123;</span><br><span class="line">    UIBezierPath* rounded &#x3D; [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:corners cornerRadii:radii];</span><br><span class="line">    CAShapeLayer* shape &#x3D; [[CAShapeLayer alloc] init];</span><br><span class="line">    [shape setPath:rounded.CGPath];</span><br><span class="line">    self.layer.mask &#x3D; shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是显然Mask仍然会有离屏渲染</p>
<p>同样的 mask 效果使用 CAShapeLayer 时相比直接使用 maskView 在帧率上稍低，CPU 利用率无明显变化，但是 GPU 利用率也低一些。</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2014/419/" target="_blank" rel="noopener">WWDC 2014: Advanced Graphics and Animations for iOS Apps</a></p>
<h3 id="GroupOpacity"><a href="#GroupOpacity" class="headerlink" title="GroupOpacity"></a>GroupOpacity</h3><p><img src="http://q6luryr3j.bkt.clouddn.com/37334-ea98e568f4748d39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1045" alt="img"></p>
<p>GroupOpacity 是指 CALayer 的<code>allowsGroupOpacity</code>属性，UIView 的<code>alpha</code>属性等同于 CALayer <code>opacity</code>属性。开启 GroupOpacity 后，子 layer 在视觉上的透明度的上限是其父 layer 的<code>opacity；</code></p>
<p>从 iOS 7 以后默认全局开启了这个功能，这样做是为了让子视图与其容器视图保持同样的透明度。</p>
<p>这个触发条件并不需要subLayer.opacity != 1.0，非常容易满足。然而在 TableView 这样的视图里设置 cell 的alpha属性小于1并不能检测离屏渲染的黄色特征，性能上也没有明显差别。经过摸索发现：只有设置cell.contentView, tableView 的alpha小于1时会触发离屏渲染，对性能无明显影响；设置 cell 的alpha属性并不会对整体的透明度产生影响，只有设置 cell.contentView 才有效</p>
<p>设置cell的alpha属性小于1，无离屏渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.alpha &#x3D; 0.3;</span><br></pre></td></tr></table></figure>

<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_19-49-52.png" alt="img" style="zoom:80%;" />

<p>设置cell.contentView的属性小于1，有离屏渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.contentView.alpha &#x3D; 0.3;</span><br></pre></td></tr></table></figure>

<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_19-48-46.png" alt="img" style="zoom:80%;" />

<h3 id="开启layer-edgeAntialiasingMask、layer-allowsEdgeAntialiasing的图层"><a href="#开启layer-edgeAntialiasingMask、layer-allowsEdgeAntialiasing的图层" class="headerlink" title="开启layer.edgeAntialiasingMask、layer.allowsEdgeAntialiasing的图层"></a>开启layer.edgeAntialiasingMask、layer.allowsEdgeAntialiasing的图层</h3><p>经过测试，开启设置<code>layer.allowsEdgeAntialiasing=true、layer.</code>edgeAntialiasingMask=true并不会触发离屏渲染，对性能也没有什么影响</p>
<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_19-55-32.png" alt="img" style="zoom:80%;" />



<h2 id="其他一些优化建议"><a href="#其他一些优化建议" class="headerlink" title="其他一些优化建议"></a>其他一些优化建议</h2><ul>
<li>当我们需要圆角效果时，可以使用一张中间透明图片蒙上去</li>
<li>使用ShadowPath指定layer阴影效果路径</li>
<li>使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit）</li>
<li>设置layer的opaque值为YES，减少复杂图层合成</li>
<li>尽量使用不包含透明（alpha）通道的图片资源</li>
<li>尽量设置layer的大小值为整形值</li>
<li>直接让美工把图片切成圆角进行显示，这是效率最高的一种方案</li>
<li>很多情况下用户上传图片进行显示，可以让服务端处理圆角</li>
<li>使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>RoundedCorner 在仅指定<code>cornerRadius</code>时不会触发离屏渲染，仅适用于特殊情况：<code>contents</code>为 nil 或者<code>contents</code>不会遮挡背景色圆角；</li>
<li>Shawdow 可以通过指定路径来取消离屏渲染；</li>
<li>Mask 无法取消离屏渲染；</li>
</ol>
<p>以上效果在同等数量的规模下，对性能的影响等级：Shadow &gt; RoundedCorner &gt; Mask &gt; GroupOpacity</p>
<p>任何时候优先考虑避免触发离屏渲染，无法避免时优化方案有两种：</p>
<ol>
<li>Rasterization：适用于静态内容的视图，也就是内部结构和内容不发生变化的视图，对上面的所有效果而言，在实现成本以及性能上最均衡的。即使是动态变化的视图，开启 Rasterization 后能够有效降低 GPU 的负荷，不过在动态视图里是否启用还是看 Instruments 的数据。</li>
<li>规避离屏渲染，用其他手法来模拟效果，混合图层是个性能最好、耗能最少的通用优化方案，尤其对于 rounded corer 和 mask。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a></p>
<p><a href="http://www.cocoachina.com/articles/12873" target="_blank" rel="noopener">layer.mask与layer.cornerRadius测试对比</a></p>
<p><a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕上</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doris AI</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doris AI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
