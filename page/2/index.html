<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorisgit.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="泡泡茶壶">
<meta property="og:url" content="https://dorisgit.github.io/page/2/index.html">
<meta property="og:site_name" content="泡泡茶壶">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Doris AI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dorisgit.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>泡泡茶壶</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泡泡茶壶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-alloc%E3%80%81retainCount%E3%80%81retain%E3%80%81release%E3%80%81dealloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-alloc%E3%80%81retainCount%E3%80%81retain%E3%80%81release%E3%80%81dealloc/" class="post-title-link" itemprop="url">内存管理-alloc、retainCount、retain、release、dealloc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-30 10:32:42" itemprop="dateCreated datePublished" datetime="2020-10-30T10:32:42+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-17 15:58:41" itemprop="dateModified" datetime="2020-11-17T15:58:41+08:00">2020-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接下来继续从源码角度，分析<code>alloc</code>、<code>retainCount</code>、<code>retain</code>、<code>release</code>、<code>dealloc</code>等方法的实现。</p>
<p>源码地址：<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a></p>
<h3 id="slowpath-amp-fastpath"><a href="#slowpath-amp-fastpath" class="headerlink" title="slowpath &amp; fastpath"></a>slowpath &amp; fastpath</h3><blockquote>
<p>宏定义如下：</p>
<p>#define fastpath(x) (__builtin_expect(bool(x), 1))</p>
<p>#define slowpath(x) (__builtin_expect(bool(x), 0))</p>
</blockquote>
<p>他们都是用了__builtin_expect函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __builtin_expect(<span class="keyword">long</span> <span class="built_in">exp</span>, <span class="keyword">long</span> c);</span><br></pre></td></tr></table></figure>

<p><code>__builtin_expect()</code>函数是GCC提供给程序员是用的，由于大部分程序员在分支预测上都非常糟糕，所以GCC提供这个内建函数来帮助程序员处理分支预测，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。它的意思是: <code>exp == c</code>的概率很大。</p>
<p><code>fastpath(x)</code> 表示  <code>x</code> 是1的概率很大，<code>slowpath(x)</code>表示 <code>x</code> 是0的概率很大。它和if一起使用，<code>if (fastpath(x))</code>表示执行<code>if</code>语句的可能性大，<code>if (slowpath(x))</code>表示执行<code>if</code>语句的可能性小。</p>
<h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>alloc方法的函数调用栈</p>
<h4 id="callAlloc"><a href="#callAlloc" class="headerlink" title="callAlloc"></a>callAlloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="comment">// 调用[cls alloc] or [cls allocWithZone:nil]函数的时候会来到这里，使用适当的快捷方式优化</span></span><br><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">  	<span class="comment">// 校验（checkNil &amp; !cls）</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  	<span class="comment">// 如果cls没有实现默认的allocWithZone，调用_objc_rootAllocWithZone</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">  	<span class="comment">// 给cls 发送 allocWithZone:消息</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="keyword">@selector</span>(allocWithZone:), <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 否则发送alloc消息</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callAlloc()</code>函数主要执行了一下步骤：</p>
<ul>
<li>判断类有没有实现自定义的<code>allocWithZone</code>方法，如果没有，就调用<code>_objc_rootAllocWithZone</code>函数（快捷方式）</li>
<li>如果没有快捷方式，根据<code>allocWithZone</code>的值，true 给<code>cls</code>类发送<code>allocWithZone</code>消息，false则给<code>cls</code>类发送<code>alloc</code>消息</li>
</ul>
<h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Replaced by ObjectAlloc</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>allocWithZone</code>其实现也是调用<code>_objc_rootAllocWithZone</code>函数</p>
<h4 id="alloc-1"><a href="#alloc-1" class="headerlink" title="alloc"></a>alloc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootAlloc"><a href="#objc-rootAlloc" class="headerlink" title="_objc_rootAlloc"></a>_objc_rootAlloc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc</code>函数会调用<code>_objc_rootAlloc</code>函数，最终会再次来到<code>callAlloc</code>函数，传参不再进行nil检查</p>
<h4 id="objc-rootAllocWithZone"><a href="#objc-rootAllocWithZone" class="headerlink" title="_objc_rootAllocWithZone"></a>_objc_rootAllocWithZone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_class_createInstanceFromZone</code>函数，参数<code>zone</code>已经被忽略直接传nil</p>
<h4 id="class-createInstanceFromZone"><a href="#class-createInstanceFromZone" class="headerlink" title="_class_createInstanceFromZone"></a>_class_createInstanceFromZone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();<span class="comment">// 获取cls是否有构造函数</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();<span class="comment">// 获取cls是否有析构函数</span></span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();<span class="comment">// 获取cls是否进行了isa指针优化</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">		<span class="comment">// 获取需要申请的空间大小</span></span><br><span class="line">    <span class="built_in">size</span> = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = <span class="built_in">size</span>;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 如果zone为nil，调用malloc_zone_calloc申请内存空间</span></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (id)malloc_zone_calloc((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果内存空间申请失败，调用_objc_callBadAllocHandler</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 初始化 isa 如果 zone == nil &amp;&amp; isa进行了指针优化，调用initInstanceIsa</span></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">      	<span class="comment">// 否则使用initIsa进行初始化isa指针</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果没有构造函数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 进行构造函数处理，在返回</span></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数_class_createInstanceFromZone中，通过C函数calloc申请内存空间，并初始化对象的isa</p>
<h4 id="initInstanceIsa"><a href="#initInstanceIsa" class="headerlink" title="initInstanceIsa"></a>initInstanceIsa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    ASSERT(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initIsa"><a href="#initIsa" class="headerlink" title="initIsa"></a>initIsa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">  	&#x2F;&#x2F; 未开启isa指针优化，直接将isa指针指向cls类对象</span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa &#x3D; isa_t((uintptr_t)cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ASSERT(!DisableNonpointerIsa);</span><br><span class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA		&#x2F;&#x2F; 对于64位系统，该值为0</span><br><span class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">      	&#x2F;&#x2F; 设置nonpointer 和 magic值位1 和 1101</span><br><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">      	&#x2F;&#x2F; 设置是否有析构函数</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">      	&#x2F;&#x2F; 设置class&#x2F;meta-class对象</span><br><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This write must be performed in a single store in some cases</span><br><span class="line">        &#x2F;&#x2F; (for example when realizing a class because other threads</span><br><span class="line">        &#x2F;&#x2F; may simultaneously try to use the class).</span><br><span class="line">        &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to</span><br><span class="line">        &#x2F;&#x2F; guarantee memory order w.r.t. the class index table</span><br><span class="line">        &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation</span><br><span class="line">        isa &#x3D; newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于ISA指针，具体可见内存管理—ISA指针</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [[cls alloc] init].</span><br><span class="line">id</span><br><span class="line">objc_alloc_init(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return [callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;) init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span><br><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类的init方法什么都没有做，只是将alloc创建的对象返回。因为我们可以重写init方法做一些初始化操作。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calls [cls new]</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_opt_new(Class cls)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(cls &amp;&amp; !cls-&gt;ISA()-&gt;hasCustomCore())) &#123;</span><br><span class="line">        <span class="keyword">return</span> [callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>) init];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(new));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)new &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(<span class="keyword">self</span>, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new方法比较简单，只是嵌套了alloc和init</p>
<h3 id="copy-amp-mutableCopy"><a href="#copy-amp-mutableCopy" class="headerlink" title="copy &amp; mutableCopy"></a>copy &amp; mutableCopy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)copy &#123;</span><br><span class="line">    return [(id)self copyWithZone:nil];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return (id)self;</span><br><span class="line">&#125;</span><br><span class="line">- (id)mutableCopy &#123;</span><br><span class="line">    return [(id)self mutableCopyWithZone:nil];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return (id)self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy和mutableCopy也很简单，只是调用了copyWithZone和mutableCopyWithZone方法。</p>
<h3 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h3><p>获取对象的引用计数器</p>
<h4 id="retainCount-1"><a href="#retainCount-1" class="headerlink" title="retainCount"></a>retainCount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return _objc_rootRetainCount(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRetainCount"><a href="#objc-rootRetainCount" class="headerlink" title="_objc_rootRetainCount"></a>_objc_rootRetainCount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_objc_rootRetainCount(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    return obj-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rootRetainCount"><a href="#rootRetainCount" class="headerlink" title="rootRetainCount"></a>rootRetainCount</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果是taggedpointer 直接返回this</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">  	<span class="comment">// 获取isa指针</span></span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">  	<span class="comment">// 判断isa指针是否开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">      	<span class="comment">// 从extra_rc读取引用计数器 再 +1</span></span><br><span class="line">        uintptr_t rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">      	<span class="comment">// 判断是否使用sidetable额外存储引用计数器</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">  	<span class="comment">// isa指针不是nonpointer, 返回sidetable_retainCount函数获取到的值</span></span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sidetable-getExtraRC-nolock"><a href="#sidetable-getExtraRC-nolock" class="headerlink" title="sidetable_getExtraRC_nolock"></a>sidetable_getExtraRC_nolock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_t </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sidetable-retainCount"><a href="#sidetable-retainCount" class="headerlink" title="sidetable_retainCount"></a>sidetable_retainCount</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数sidetable_getExtraRC_nolock和函数sidetable_retainCount，均是通过哈希查找获取他们的引用计数器表。</p>
<p>不同的是：</p>
<ul>
<li>isa 是 nonpointer会调用sidetable_getExtraRC_nolock函数，它的引用计数器会存在两部分，一部分在isa_t的extra_rc，另一部分存在于SideTable中，不进行加锁</li>
<li>isa不是nonpointer会调用sidetable_retainCount函数，他的引用计数器之存在于SideTable中，需要加锁查找</li>
</ul>
<p>SideTable查找步骤：</p>
<ul>
<li>先根据对象的内存地址，经过哈希查找后从SideTables中获取到它所在的SideTable</li>
<li>再根据当前对象的内存地址，经过哈希查找从SideTable表中的refcnts中取出它的引用计数器表</li>
</ul>
<blockquote>
<p>小结：rootRetainCount函数</p>
<ul>
<li>在arm64之前，isa 不是 nonpointer 对象的引用计数器存储在SideTable中，rootRetainCount获取到的就是1 + SideTable中存储的值</li>
<li>arm64之后，isa如果是nonpointer 对象的引用计数器先存储在extra_rc中，如果19位extra_rc不够存储，你们溢出的部分在存储在SideTable中，rootRetainCount获取到的就是1+ extra_rc的值+SideTable的值</li>
<li>初始化情况下，通过rootRetainCount获取到的1，这是rootRetainCount的功劳，alloc并没有设置对象的引用计数器</li>
</ul>
</blockquote>
<p><strong>Q：alloc方法没有设置对象的引用计数为1，而且内部也没有调用<code>retainCount</code>方法，那<code>alloc</code>创建的对象不会因引用计数器为0，而直接被<code>dealloc</code>吗？</strong></p>
<p>A：dealloc方法是在release方法内部调用的，只有你直接调用了<code>dealloc</code>，或者调用了<code>release</code>方法且在release中判断对象的引用计数器是否为0，才会调用dealloc</p>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p>之前已经说过，持有对象的方式有两种，一种是<code>alloc/new/copy/mutableCopy</code>，一种是<code>retain</code>，<code>retain</code>会将对象的引用计数+1</p>
<h4 id="objc-retain"><a href="#objc-retain" class="headerlink" title="objc_retain"></a>objc_retain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if __OBJC2__</span><br><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">id objc_retain(id obj) &#123; return [obj retain]; &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>如果是<code>__OBJC2__</code>，则调用<code>objc_retain</code>，否则调用<code>retain</code></p>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(id) retain</span><br><span class="line">&#123;</span><br><span class="line">    return _objc_rootRetain(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRetain"><a href="#objc-rootRetain" class="headerlink" title="_objc_rootRetain"></a>_objc_rootRetain</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">id</span></span><br><span class="line">_objc_rootRetain(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRetain"><a href="#objc-object-rootRetain" class="headerlink" title="objc_object::rootRetain()"></a>objc_object::rootRetain()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Base retain implementation, ignoring overrides.</span><br><span class="line">&#x2F;&#x2F; This does not check isa.fast_rr; if there is an RR override then </span><br><span class="line">&#x2F;&#x2F; it was already called and it chose to call [super retain].</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; tryRetain&#x3D;true is the -_tryRetain path.</span><br><span class="line">&#x2F;&#x2F; handleOverflow&#x3D;false is the frameless fast path.</span><br><span class="line">&#x2F;&#x2F; handleOverflow&#x3D;true is the framed slow path including overflow to side table</span><br><span class="line">&#x2F;&#x2F; The code is structured this way to prevent duplication.</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    return rootRetain(false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRetain-bool-tryRetain-bool-handleOverflow"><a href="#objc-object-rootRetain-bool-tryRetain-bool-handleOverflow" class="headerlink" title="objc_object::rootRetain(bool tryRetain, bool handleOverflow)"></a>objc_object::rootRetain(bool tryRetain, bool handleOverflow)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">id</span> </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;<span class="comment">// 是否要将引用计数器存储在SideTable中</span></span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 不去检查isa指针是否fast_rr，因为我们可能会调用重载方法</span></span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">      	<span class="comment">// #   define RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line">      	<span class="comment">// 将引用计数器+1</span></span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">				</span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">          	<span class="comment">// 如果extra_rc上溢</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 设置extra_rc为RC_HALF，同时标记has_sidetable_rc</span></span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;<span class="comment">// #   define RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 如果需要 将溢出的引用计数器存储到sidetable中</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-retain"><a href="#objc-object-sidetable-retain" class="headerlink" title="objc_object::sidetable_retain()"></a>objc_object::sidetable_retain()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage &#x3D; table.refcnts[this];&#x2F;&#x2F; 获取当前引用计数</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; &#x2F;&#x2F; 获取到了 &amp; 未溢出</span><br><span class="line">        refcntStorage +&#x3D; SIDE_TABLE_RC_ONE;&#x2F;&#x2F; 将引用计数+1</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏定义信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The order of these bits is important.</span><br><span class="line">#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)		&#x2F;&#x2F; 标记对象是否有弱引用</span><br><span class="line">#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  	&#x2F;&#x2F; 标记对象是否正在deallocating</span><br><span class="line">#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  	&#x2F;&#x2F; 对象引用计数存储的开始位，引用计数存储在2～63位</span><br><span class="line">#define SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1)) &#x2F;&#x2F; 引用计数 </span><br><span class="line"></span><br><span class="line">#define SIDE_TABLE_RC_SHIFT 2</span><br><span class="line">#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span><br></pre></td></tr></table></figure>

<p>对象引用计数表<code>refcnts</code></p>
<p><img src="/Users/mikasa/Desktop/image_mark/202011032030.png" alt="img"></p>
<h4 id="rootRetain-overflow"><a href="#rootRetain-overflow" class="headerlink" title="rootRetain_overflow"></a>rootRetain_overflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE id </span><br><span class="line">objc_object::rootRetain_overflow(bool tryRetain)</span><br><span class="line">&#123;</span><br><span class="line">    return rootRetain(tryRetain, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果extra_rc存储满了，就会调用rootRetain_overflow，该函数调用了rootRetain，但参数handleOverflow传true</p>
<h4 id="sidetable-addExtraRC-nolock"><a href="#sidetable-addExtraRC-nolock" class="headerlink" title="sidetable_addExtraRC_nolock"></a>sidetable_addExtraRC_nolock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts to the side table from the isa field.</span></span><br><span class="line"><span class="comment">// Returns true if the object is now pinned.</span></span><br><span class="line"><span class="comment">// 将一些引用计数存储在sideTable表中</span></span><br><span class="line"><span class="keyword">bool</span> </span><br><span class="line">objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    size_t oldRefcnt = refcntStorage;</span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    size_t newRefcnt = </span><br><span class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        refcntStorage =</span><br><span class="line">            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        refcntStorage = newRefcnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>extra_rc</code>存储满了，就会调用<code>sidetable_addExtraRC_nolock</code>将<code>extra_rc</code>中的<code>RC_HALF(extra_rc满</code>值的一半)个引用计数转移到<code>sidetable</code>中存储，也是调用<code>addc</code>对<code>refcnt</code>引用计数表进行计数增加操作。</p>
<blockquote>
<p>小结：<code>retain</code>方法：</p>
<ul>
<li>如果<code>isa</code>不是<code>nonpointer</code>，那么就对<code>Sidetable</code>中的引用计数+1</li>
<li>如果isa是nonpointer，就对isa中的<code>extra_rc</code>存储的引用计数进行+1，如果溢出，就将extra_rc中<code>RC_HALF</code>(<code>extra_rc</code>满值的一半)个引用计数转移到<code>sidetable</code>中存储，从<code>rootRetain</code>函数中我们可以看到，如果<code>extra_rc</code>溢出，设置它的值为RC_HALF，这时候又对<code>sidetable</code>中的<code>refcnt</code>增加引用计数。<code>extra_rc</code>是<code>19</code>位，而<code>RC_HALF</code>宏是<code>(1ULL&lt;&lt;18)</code>，实际上相等于进行了 +1 操作</li>
</ul>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>当我们在不需要持有对象的时候，需要调用<code>release</code>方法进行释放，<code>release</code>会将对象的引用计数-1</p>
<h4 id="objc-release"><a href="#objc-release" class="headerlink" title="objc_release"></a>objc_release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span> objc_release(<span class="keyword">id</span> obj) &#123; [obj release]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="objc-object-release"><a href="#objc-object-release" class="headerlink" title="objc_object::release"></a>objc_object::release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::release()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        rootRelease();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(release));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果方法没有被重写，直接调用<code>rootRelease()</code>;，这是快捷方式，否则调用<code>release</code></p>
<h4 id="release-1"><a href="#release-1" class="headerlink" title="release"></a>release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)release</span><br><span class="line">&#123;</span><br><span class="line">    _objc_rootRelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRelease"><a href="#objc-rootRelease" class="headerlink" title="_objc_rootRelease"></a>_objc_rootRelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootRelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootRelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRelease"><a href="#objc-object-rootRelease" class="headerlink" title="objc_object::rootRelease"></a>objc_object::rootRelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base release implementation, ignoring overrides.</span></span><br><span class="line"><span class="comment">// Does not call -dealloc.</span></span><br><span class="line"><span class="comment">// Returns true if the object should now be deallocated.</span></span><br><span class="line"><span class="comment">// This does not check isa.fast_rr; if there is an RR override then </span></span><br><span class="line"><span class="comment">// it was already called and it chose to call [super release].</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// handleUnderflow=false is the frameless fast path.</span></span><br><span class="line"><span class="comment">// handleUnderflow=true is the framed slow path including side table borrow</span></span><br><span class="line"><span class="comment">// The code is structured this way to prevent duplication.</span></span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootReleaseShouldDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">      	<span class="comment">// 不是nonpointer</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">          	<span class="comment">// 如果是meta-class直接return</span></span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">          	<span class="comment">// 调用sidetable_release函数</span></span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">      	<span class="comment">// subc函数对extra_rc--</span></span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">      	<span class="comment">// 如果extra_rc已经溢出了</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don't ClearExclusive()</span></span><br><span class="line">          	<span class="comment">// 执行underflow处理下溢</span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line"> <span class="comment">// 处理下溢</span></span><br><span class="line"> underflow:</span><br><span class="line">    <span class="comment">// newisa.extra_rc-- underflowed: borrow from side table or deallocate</span></span><br><span class="line">		<span class="comment">// 出现extra_rc-- 下溢，sidetable移除或者dealloc对象</span></span><br><span class="line">    <span class="comment">// abandon newisa to undo the decrement</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line">		<span class="comment">// 如果has_sidetable_rc 为true</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">      	<span class="comment">// 没有出现下溢</span></span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">          	<span class="comment">// 执行rootRelease_underflow函数</span></span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></span><br><span class="line">				<span class="comment">// 引用计数从sidetable转移到extra_rc中存储</span></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Need to start over to avoid a race against </span></span><br><span class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 尝试从sidetable中删除一些引用计数，传入RC_HALF，borrowed为实际删除的引用计数</span></span><br><span class="line">        <span class="comment">// Try to remove some retain counts from the side table.        </span></span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line">      </span><br><span class="line">				<span class="comment">// 为了避免竞争，has_sidetable_rc必须设置，即使现在sidetable中的引用计数已经是0了</span></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Side table retain count decreased.</span></span><br><span class="line">            <span class="comment">// Try to add them to the inline count.</span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">          	<span class="comment">// 存储失败，再试一次</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 如果还是失败，就将引用计数重新保存在sidetable中</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed.</span></span><br><span class="line">                <span class="comment">// Put the retains back in the side table.</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果引用计数器为0 dealloc对象</span></span><br><span class="line">    <span class="comment">// Really deallocate.</span></span><br><span class="line">		<span class="comment">// 如果当前对象处于deallocating，保证对象只会deallocating一次</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 设置isa处于deallocating状态</span></span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">  	<span class="comment">// 如果存储失败 继续重试</span></span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line">		<span class="comment">// 如果performDealloc==true,给对象发送一条dealloc消息</span></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-release"><a href="#objc-object-sidetable-release" class="headerlink" title="objc_object::sidetable_release"></a>objc_object::sidetable_release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rdar://20206767</span></span><br><span class="line"><span class="comment">// return uintptr_t instead of bool so that the various raw-isa </span></span><br><span class="line"><span class="comment">// -release paths all return zero in eax</span></span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 设置是否需要执行do_dealloc标记，默认不需要</span></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 获取当前对象是否正在执行deallocating</span></span><br><span class="line">    auto it = table.refcnts.try_emplace(<span class="keyword">this</span>, SIDE_TABLE_DEALLOCATING);</span><br><span class="line">  	<span class="comment">// 获取refcnt</span></span><br><span class="line">    auto &amp;refcnt = it.first-&gt;second;</span><br><span class="line">    <span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">      	<span class="comment">// 如果对象处于deallocating状态</span></span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        refcnt |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;<span class="comment">// 如果引用计数器还有值，作计数器-1</span></span><br><span class="line">        refcnt -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">  	<span class="comment">// 如果对象正在作dealloc 和 performDealloc，对当前对象发送dealloc消息</span></span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>isa</code>不是<code>nonpointer</code>，那么就对<code>SideTable</code>中引用计数-1，如果引用计数为0，发送<code>dealloc</code>消息</p>
<h4 id="subc"><a href="#subc" class="headerlink" title="subc"></a>subc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE uintptr_t </span><br><span class="line">subc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)</span><br><span class="line">&#123;</span><br><span class="line">    return __builtin_subcl(lhs, rhs, carryin, carryout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>subc</code> 就是 <code>addc</code>反向操作，用来减少引用计数</p>
<h4 id="objc-object-rootRelease-underflow"><a href="#objc-object-rootRelease-underflow" class="headerlink" title="objc_object::rootRelease_underflow"></a>objc_object::rootRelease_underflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::rootRelease_underflow(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">    return rootRelease(performDealloc, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>extra_rc</code>下溢，就会调用<code>rootRelease_underflow</code>，该函数会再次调用<code>rootRelease</code>，但是参数<code>handleUnderflow</code>传true</p>
<h4 id="objc-object-sidetable-subExtraRC-nolock"><a href="#objc-object-sidetable-subExtraRC-nolock" class="headerlink" title="objc_object::sidetable_subExtraRC_nolock"></a>objc_object::sidetable_subExtraRC_nolock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts from the side table to the isa field.</span></span><br><span class="line"><span class="comment">// Returns the actual count subtracted, which may be less than the request.</span></span><br><span class="line"><span class="comment">// 尝试从sidetable中移动一些引用计数到isa中，返回真实移动的数量，有可能比请求移动的要少</span></span><br><span class="line">size_t </span><br><span class="line">objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 获取refcnts</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="comment">// 如果当前refcnts为空，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()  ||  it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Side table retain count is zero. Can't borrow.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t oldRefcnt = it-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 减少引用计数器</span></span><br><span class="line">    size_t newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class="line">    ASSERT(oldRefcnt &gt; newRefcnt);  <span class="comment">// shouldn't underflow</span></span><br><span class="line">    it-&gt;second = newRefcnt;</span><br><span class="line">    <span class="keyword">return</span> delta_rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sidetable_subExtraRC_nolock</code>函数将引用计数器转移到<code>isa</code>指针的<code>extra_rc</code>中，有可能比请求要移动的少。</p>
<h4 id="objc-object-overrelease-error"><a href="#objc-object-overrelease-error" class="headerlink" title="objc_object::overrelease_error"></a>objc_object::overrelease_error</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::overrelease_error()</span><br><span class="line">&#123;</span><br><span class="line">    _objc_inform_now_and_on_crash(<span class="string">"%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug"</span>, object_getClassName((<span class="keyword">id</span>)<span class="keyword">this</span>), <span class="keyword">this</span>);</span><br><span class="line">    objc_overrelease_during_dealloc_error();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// allow rootRelease() to tail-call this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前对象正处于dealloc状态，再次release机会执行overrelease_error，该函数用于处理过度调用release的时候使用。</p>
<blockquote>
<p><strong>小结：release方法</strong></p>
<p>如果isa不是nonpointer,那么直接对sidetable中的引用计数-1，如果引用计数==0，调用dealloc</p>
<p>如果isa是nonpointer，就将当前extra_rc存储的引用计数器-1，如果下溢，即extra_rc中的引用计数器为0了，判断has_sidetable_rc是否为true，即是否使用的sidetable进行引用计数存储，如果有的话就申请从Sidetable中申请RC_HALF个引用计数转移到extra_rc中存储，如果不足RC_HALF就有多少转移多少，然后将Sitetable中的引用计数减去RC_HALF（或者实际转移数量）将实际申请的引用计数器-1后存储在extra_rc中，如果extra_rc中引用计数器为0了而且has_sidetable_rc 为false或者sitetable中的引用计数器也为0了，你们就发送dealloc消息</p>
</blockquote>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><h4 id="objc-autorelease"><a href="#objc-autorelease" class="headerlink" title="objc_autorelease"></a>objc_autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">id</span> objc_autorelease(<span class="keyword">id</span> obj) &#123; <span class="keyword">return</span> [obj autorelease]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果是<code>__OBJC2__</code>，则调用autorelease函数，否则调用autorelease方法</p>
<h4 id="objc-object-autorelease"><a href="#objc-object-autorelease" class="headerlink" title="objc_object::autorelease"></a>objc_object::autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) <span class="keyword">return</span> rootAutorelease();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该方法没有被重写，直接调用objc_object::rootAutorelease，这是快捷方式；否则调用autorelease方法。</p>
<h4 id="objc-object-autorelease-1"><a href="#objc-object-autorelease-1" class="headerlink" title="objc_object::autorelease"></a>objc_object::autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootAutorelease2"><a href="#objc-object-rootAutorelease2" class="headerlink" title="objc_object::rootAutorelease2"></a>objc_object::rootAutorelease2</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数中调用了<code>AutoreleasePoolPage</code>中<code>autorelease</code>方法</p>
<h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><h4 id="dealloc-1"><a href="#dealloc-1" class="headerlink" title="dealloc"></a>dealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootDealloc"><a href="#objc-rootDealloc" class="headerlink" title="_objc_rootDealloc"></a>_objc_rootDealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootDealloc"><a href="#objc-object-rootDealloc" class="headerlink" title="objc_object::rootDealloc"></a>objc_object::rootDealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  <span class="comment">// 判断是否有弱引用</span></span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  				 <span class="comment">// 判断是否有关联对象</span></span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  		 <span class="comment">// 没有c++析构函数</span></span><br><span class="line">                 !isa.has_sidetable_rc))		 <span class="comment">// 没有使用sidetable进行引用计数存储</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">      	<span class="comment">// 直接使用free销毁对象</span></span><br><span class="line">        free(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 调用object_dispose函数</span></span><br><span class="line">        object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">object_dispose(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);   <span class="comment">// 调用 objc_destructInstance 函数</span></span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);<span class="comment">// 如果有c++析构函数，调用object_cxxDestruct</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);<span class="comment">// 如果有关联对象，移除关联对象</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-clearDeallocating"><a href="#objc-object-clearDeallocating" class="headerlink" title="objc_object::clearDeallocating"></a>objc_object::clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果 isa 不是 nonpointer</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果 isa 是 nonpointer 或者 isa.has_sidetable_rc == true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-clearDeallocating"><a href="#objc-object-sidetable-clearDeallocating" class="headerlink" title="objc_object::sidetable_clearDeallocating"></a>objc_object::sidetable_clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_object::sidetable_clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 获取SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear any weak table items</span></span><br><span class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></span><br><span class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 获取弱引用散列表</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">      	<span class="comment">// 当前对象是否有弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 调用table.refcnts.erase从引用计数器中</span></span><br><span class="line">        table.refcnts.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-clearDeallocating-slow"><a href="#objc-object-clearDeallocating-slow" class="headerlink" title="objc_object::clearDeallocating_slow"></a>objc_object::clearDeallocating_slow</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Slow path of clearDeallocating() </span></span><br><span class="line"><span class="comment">// for objects with nonpointer isa</span></span><br><span class="line"><span class="comment">// that were ever weakly referenced </span></span><br><span class="line"><span class="comment">// or whose retain count ever overflowed to the side table.</span></span><br><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 是否有弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">      	<span class="comment">// 清理弱引用指针</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果有has_sidetable_rc</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">      	<span class="comment">// 调用table.refcnts.erase从引用计数器中</span></span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结：dealloc方法</strong></p>
<ul>
<li><p>判断条件（1、isa 为nonpointer; 2、没有弱引用；3、没有关联对象；4、没有c++析构函数；5、没有额外使用sidetable进行引用计数器存储）是否成立，均成立的话，使用free函数直接销毁对象，否则调用object_dispose做一些释放对象前的处理</p>
</li>
<li><p>如果有C++析构函数，调用<code>object_cxxDestruct</code>;</p>
</li>
<li><p>如果有关联对象，<code>_object_remove_assocations</code>移除关联对象</p>
</li>
<li><p>如果有弱引用，调用<code>weak_clear_no_lock</code>将指向该对象的弱引用指针置为nil</p>
</li>
<li><p>如果有使用sidetable进行引用计数器存储，调用<code>table.refcnts.erase</code>从引用计数表中擦除该对于的引用计数</p>
</li>
<li><p>调用<code>free</code>函数销毁对象</p>
<p>根据dealloc过程，<code>__weak</code>修饰符的变量在对象被<code>dealloc</code>时，会将该<code>weak</code>置为nil。可见，如果大量使用<code>weak</code>变量的话，是会消耗CPU的资源，所以建议只在需要避免循环引用的时候使用<code>weak</code>修饰符。</p>
</li>
</ul>
</blockquote>
<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><h4 id="清除weak"><a href="#清除weak" class="headerlink" title="清除weak"></a>清除weak</h4><p>以上从dealloc方法实现我们知道了对象在dealloc的时候，会调用weak_clear_no_lock函数将指向该对象的弱引用指针置为nil</p>
<h4 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the </span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 获取weak指向的地址，即当掐对象的地址</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">		<span class="comment">// 找到管理weak_entry_t的容器</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 判断弱引用是否超出定长</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">      	<span class="comment">// 获取entry中的referrers，referrers是一个数组，存储所有指向referent_id的指针</span></span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">      	<span class="comment">// 弱引用数组长度</span></span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果是使用的定长存储</span></span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历弱引用数组，将所有指向referent_id的指针置为nil</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将entry从弱引用表中移除</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结：清除weak</strong></p>
<p>当一个对象销毁是，在<code>dealloc</code>方法内部经过一系列的函数调用栈，通过二次哈希查找，第一次根据对象的地址找到它所在的<code>sidetable</code>，第二次根据对象的地址在Sidetable的<code>weak_table</code>中找打它的弱引用表。弱引用表中存储的是对象的地址（作为<code>key</code>）和weak指针地址的数组（作为<code>value</code>）的映射。<code>weak_clear_no_lock</code>函数中遍历弱引用数组，将指向该对象的地址的<code>weak</code>变量全部置为nil</p>
</blockquote>
<h3 id="添加weak"><a href="#添加weak" class="headerlink" title="添加weak"></a>添加weak</h3><p>一个被声明未__weak的指针，在经过编译之后，通过<code>objc_initWeak</code>函数初始化附有<code>weak</code>修饰符的变量，在变量作用域结束时，通过<code>objc_destroyWeak</code>函数销毁该变量。</p>
<h4 id="objc-moveWeak"><a href="#objc-moveWeak" class="headerlink" title="objc_moveWeak"></a>objc_moveWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Move a weak pointer from one location to another.</span></span><br><span class="line"><span class="comment"> * Before the move, the destination must be uninitialized.</span></span><br><span class="line"><span class="comment"> * After the move, the source is nil.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to either weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_moveWeak(<span class="keyword">id</span> *dst, <span class="keyword">id</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    objc_copyWeak(dst, src);</span><br><span class="line">    objc_destroyWeak(src);</span><br><span class="line">    *src = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-copyWeak"><a href="#objc-copyWeak" class="headerlink" title="objc_copyWeak"></a>objc_copyWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function copies a weak pointer from one location to another,</span></span><br><span class="line"><span class="comment"> * when the destination doesn't already contain a weak pointer. It</span></span><br><span class="line"><span class="comment"> * would be used for code like:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  __weak id src = ...;</span></span><br><span class="line"><span class="comment"> *  __weak id dst = src;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the destination variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param dst The destination variable.</span></span><br><span class="line"><span class="comment"> * @param src The source variable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_copyWeak(<span class="keyword">id</span> *dst, <span class="keyword">id</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = objc_loadWeakRetained(src);</span><br><span class="line">    objc_initWeak(dst, obj);</span><br><span class="line">    objc_release(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Initialize a fresh weak pointer to some object location. </span></span><br><span class="line"><span class="comment"> * It would be used for code like: </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (The nil case) </span></span><br><span class="line"><span class="comment"> * __weak id weakPtr;</span></span><br><span class="line"><span class="comment"> * (The non-nil case) </span></span><br><span class="line"><span class="comment"> * NSObject *o = ...;</span></span><br><span class="line"><span class="comment"> * __weak id weakPtr = o;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param location Address of __weak ptr. </span></span><br><span class="line"><span class="comment"> * @param newObj Object ptr. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)<span class="comment">// location为__weak指针地址，newObj为对象地址</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果对象为nil，那就将__weak指针置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update a weak variable.</span></span><br><span class="line"><span class="comment">// If HaveOld is true, the variable has an existing value </span></span><br><span class="line"><span class="comment">//   that needs to be cleaned up. This value might be nil.</span></span><br><span class="line"><span class="comment">// If HaveNew is true, there is a new value that needs to be </span></span><br><span class="line"><span class="comment">//   assigned into the variable. This value might be nil.</span></span><br><span class="line"><span class="comment">// If CrashIfDeallocating is true, the process is halted if newObj is </span></span><br><span class="line"><span class="comment">//   deallocating or newObj's class does not support weak references. </span></span><br><span class="line"><span class="comment">//   If CrashIfDeallocating is false, nil is stored instead.</span></span><br><span class="line"><span class="comment">// 更新weak变量</span></span><br><span class="line"><span class="comment">// 如果 HaveOld == true，表示变量有旧值，这个值可能为nil</span></span><br><span class="line"><span class="comment">// 如果 HaveNew == true，表示一个新值需要赋值给变量，这个新值可能是nil</span></span><br><span class="line"><span class="comment">// 如果 CrashIfDeallocating == true，表示对象正在销毁 或者 对象不支持弱引用，则停止更新</span></span><br><span class="line"><span class="comment">// 如果 CrashIfDeallocating == false，则存储nil</span></span><br><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) ASSERT(newObj == <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    SideTable *oldTable;<span class="comment">// 旧表，用来存放已有的weak变量</span></span><br><span class="line">    SideTable *newTable;<span class="comment">// 新表，用来存放新的weak变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// 存在旧值，获取旧值对象 和旧值所在的弱引用表</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在新值，创建新表</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 对旧值 新值 分别加锁</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">		<span class="comment">// 判断旧值 和 location指向的值是否相等，即是否同一对象，如果不是就重新获取旧值相关联的对象和表</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="comment">// 存在新值</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">      	<span class="comment">// 判断新值所属的类是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">          	<span class="comment">// 未初始化，先进行初始化，防止 +initialize 内部调用 storeWeak 产生死锁</span></span><br><span class="line">            class_initialize(cls, (<span class="keyword">id</span>)newObj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this class is finished with +initialize then we're good.</span></span><br><span class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">            <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">            <span class="comment">// 标记类已经进行初始化检查</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="comment">// 如果存在旧值，调用weak_unregister_no_lock进行清理</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="comment">// 存在新值，调用weak_register_no_lock方法，将所有weak指针重新指向新的对象</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line">				<span class="comment">// 如果存储成功</span></span><br><span class="line">      	<span class="comment">// 如果对象是 taggedPointer，不做操作</span></span><br><span class="line">      	<span class="comment">// 如果isa 不是 nonpointer,设置Sidetable中弱引用标志位</span></span><br><span class="line">      	<span class="comment">// 如果isa 是 nonpointer，设置isa 的 weakly_referenced弱引用标志位</span></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">      	<span class="comment">// 将location指向新的对象</span></span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：<code>storeWeak</code>函数执行过程：</strong></p>
<ul>
<li>分别获取新旧值相关联的弱引用表；</li>
<li>如果有旧值，就调用<code>weak_unregister_no_lock</code>进行清理</li>
<li>如果有新值，就调用<code>weak_register_no_lock</code>函数分配新值，将所有<code>weak</code>指针重新指向新的对象；</li>
<li>判断<code>isa</code>是否为<code>nonpointer</code> 来设置弱引用标志位，如果不是<code>nonponinter</code>，设置<code>SideTable</code>中的弱引用标志位，否则设置<code>isa</code>的<code>weakly_referenced</code>弱引用标志位。</li>
</ul>
</blockquote>
<h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registers a new (object, weak pointer) pair. Creates a new weak</span></span><br><span class="line"><span class="comment"> * object entry if it does not exist.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object pointed to by the weak reference.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;<span class="comment">// 对象</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;<span class="comment">// 弱引用指针</span></span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 判断对象是否为nil &amp;&amp; 是否是taggedPointer指针，如果是 直接返回当前对象</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">  	<span class="comment">// 确保对象是可用的</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">  	<span class="comment">// 判断当前对象是否正在deallocating</span></span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 当前对象是否支持弱引用</span></span><br><span class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </span><br><span class="line">                                           <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// allowsWeakReference 函数获取的其实就是当前对象! [self _isDeallocating]; </span></span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 正在执行deallocating 不可使用weak指针</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">  	<span class="comment">// 获取弱引用entry</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">  	<span class="comment">// 如果当前entry存在，指向将weak指针追加进去</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果当前entry不存在，先创建一个新的entry，将新的entry存储到weak_table中</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：weak_register_no_lock用于保存弱引用信息，具体实现如下：</strong></p>
<ul>
<li>判断对象是否正在释放，是否支持弱引用，如果实例对象<code>allowsWeakReference</code>返回NO，表明对象正在执行<code>deallocating</code> 不可使用weak指针</li>
<li>查询<code>weak_table</code>表，判断引用表中是否已经保存与对象相关联的弱引用信息；</li>
<li>如果已经有相关弱引用信息，则调用<code>append_referrer</code>函数将弱引用信息添加进现有的entry容器中；如果没有相关联信息，则创建一个<code>entry</code>，判断<code>weak_table</code>是否需要扩容（大小超过<code>3/4，进行2倍扩</code>容），将<code>entry</code>插入到弱引用表中。</li>
</ul>
</blockquote>
<h4 id="weak-unregister-no-lock-1"><a href="#weak-unregister-no-lock-1" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unregister an already-registered weak reference.</span></span><br><span class="line"><span class="comment"> * This is used when referrer's storage is about to go away, but referent</span></span><br><span class="line"><span class="comment"> * isn't dead yet. (Otherwise, zeroing referrer later would be a</span></span><br><span class="line"><span class="comment"> * bad memory access.)</span></span><br><span class="line"><span class="comment"> * Does nothing if referent/referrer is not a currently active weak reference.</span></span><br><span class="line"><span class="comment"> * Does not zero referrer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * FIXME currently requires old referent value to be passed in (lame)</span></span><br><span class="line"><span class="comment"> * FIXME unregistration should be automatic if referrer is collected</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                        <span class="keyword">id</span> *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 是否存在与当前对象相关联的弱引用表</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">      	<span class="comment">// 从entry中移除弱引用指针referrer</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 判断是否超出定长（4），out_of_line_ness为2标记还是通过inline_referrers存储</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 判断inline_referrers中是否存在weak信息</span></span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：<code>weak_unregister_no_lock</code>函数用来移除弱引用信息，具体实现如下：</p>
<ul>
<li>查询<code>weak_table</code>表，获取与当前对象相关联的弱引用信息；</li>
<li>如果有，调用<code>remove_referrer</code>移除相关弱引用信息；接着判断数组是否为空，如果为空，调用<code>weak_entry_remove</code>移除<code>entry</code></li>
</ul>
</blockquote>
<h4 id="objc-destroyWeak"><a href="#objc-destroyWeak" class="headerlink" title="objc_destroyWeak"></a>objc_destroyWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Destroys the relationship between a weak pointer</span></span><br><span class="line"><span class="comment"> * and the object it is referencing in the internal weak</span></span><br><span class="line"><span class="comment"> * table. If the weak pointer is not referencing anything, </span></span><br><span class="line"><span class="comment"> * there is no need to edit the weak table. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param location The weak pointer address. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_destroyWeak(<span class="keyword">id</span> *location)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="keyword">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_initWeak</code> 和 objc_destroyWeak 函数中都调用了storeWeak，但是传入的参数不同</p>
<ul>
<li><code>objc_initWeak</code>将对象地址传入，且DontHaveOld，DoHaveNew，DoCrashIfDeallocating</li>
<li>objc_destroyWeak将nil传入，且DontHaveOld，DoHaveNew，DoCrashIfDeallocating</li>
</ul>
<p>storeWeak函数将参数二的赋值的对象地址作为key，将参数一的附有__weak修饰符的变量的地址注册到weak表中。如果参数二为nil，则将变量的地址从weak表中删除。</p>
<blockquote>
<p><strong>小结：添加`weak</strong>`</p>
<p>一个被标记为<code>weak</code>的指针，在经过编译之后会调用<code>objc_copyWeak</code>函数，在<code>objc_copyWeak</code>函数中调用<code>objc_initWeak</code>函数，<code>objc_initWeak</code>函数中初始化weak变量后调用<code>storeWeak</code>函数。添加weak的过程如下：</p>
<ul>
<li>经过一系列的调用栈，最终在<code>weak_register_no_lock</code>函数中，进行弱引用变量的添加，具体添加的位置是通过哈希算法来查找的，如果对应位置已经存在当前对象的弱引用表（数组），直接将弱引用变量添加进入，如果不存在弱引用表，先创建弱引用表，再判断是否需要对<code>weak_table</code>进行扩容，然后再将弱引用变量添加进去。</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">内存管理方法</th>
<th align="left">具体实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">alloc</td>
<td align="left">经过一系列的函数调用栈，最终通过调用 C 函数<code>calloc</code>来申请内存空间，并初始化对象的<code>isa</code>，但并没有设置对象的引用计数值为 1。</td>
</tr>
<tr>
<td align="left">init</td>
<td align="left">基类的<code>init</code>方法啥都没干，只是将<code>alloc</code>创建的对象返回。我们可以重写<code>init</code>方法来对<code>alloc</code>创建的实例做一些初始化操作。</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left"><code>new</code>方法很简单，只是嵌套了<code>alloc</code>和<code>init</code>。</td>
</tr>
<tr>
<td align="left">copy、mutableCopy</td>
<td align="left">调用了<code>copyWithZone</code>和<code>mutableCopyWithZone</code>方法。</td>
</tr>
<tr>
<td align="left">retainCount</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，引用计数值 = <code>SideTable</code>中的引用计数表中存储的值 + 1； ② 如果<code>isa</code>是<code>nonpointer</code>，引用计数值 = <code>isa</code>中的<code>extra_rc</code>存储的值 + 1 +<code>SideTable</code>中的引用计数表中存储的值。</td>
</tr>
<tr>
<td align="left">retain</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，就对<code>Sidetable</code>中的引用计数进行 +1； ② 如果<code>isa</code>是<code>nonpointer</code>，就将<code>isa</code>中的<code>extra_rc</code>存储的引用计数进行 +1，如果溢出，就将<code>extra_rc</code>中<code>RC_HALF</code>（<code>extra_rc</code>满值的一半）个引用计数转移到<code>sidetable</code>中存储。</td>
</tr>
<tr>
<td align="left">release</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，就对<code>Sidetable</code>中的引用计数进行 -1，如果引用计数 =0，就<code>dealloc</code>对象； ② 如果<code>isa</code>是<code>nonpointer</code>，就将<code>isa</code>中的<code>extra_rc</code>存储的引用计数进行 -1。如果下溢，即<code>extra_rc</code>中的引用计数已经为 0，判断<code>has_sidetable_rc</code>是否为<code>true</code>即是否有使用<code>Sidetable</code>存储。如果有的话就申请从<code>Sidetable</code>中申请<code>RC_HALF</code>个引用计数转移到<code>extra_rc</code>中存储，如果不足<code>RC_HALF</code>就有多少申请多少，然后将<code>Sidetable</code>中的引用计数值减去<code>RC_HALF</code>（或是小于<code>RC_HALF</code>的实际值），将实际申请到的引用计数值 -1 后存储到<code>extra_rc</code>中。如果<code>extra_rc</code>中引用计数为 0 且<code>has_sidetable_rc</code>为<code>false</code>或者<code>Sidetable</code>中的引用计数也为 0 了，那就<code>dealloc</code>对象。</td>
</tr>
<tr>
<td align="left">dealloc</td>
<td align="left">① 判断销毁对象前有没有需要处理的东西（如弱引用、关联对象、<code>C++</code>的析构函数、<code>SideTabel</code>的引用计数表等等）； ② 如果没有就直接调用<code>free</code>函数销毁对象； ③ 如果有就先调用<code>object_dispose</code>做一些释放对象前的处理（置弱引用指针置为<code>nil</code>、移除关联对象、<code>object_cxxDestruct</code>、在<code>SideTabel</code>的引用计数表中擦出引用计数等等），再用<code>free</code>函数销毁对象。</td>
</tr>
<tr>
<td align="left">清除<code>weak</code>，<code>weak</code>指针置为<code>nil</code>的过程</td>
<td align="left">当一个对象被销毁时，在<code>dealloc</code>方法内部经过一系列的函数调用栈，通过两次哈希查找，第一次根据对象的地址找到它所在的<code>Sidetable</code>，第二次根据对象的地址在<code>Sidetable</code>的<code>weak_table</code>中找到它的弱引用表。遍历弱引用数组，将指向对象的地址的<code>weak</code>变量全都置为<code>nil</code>。</td>
</tr>
<tr>
<td align="left">添加<code>weak</code></td>
<td align="left">经过一系列的函数调用栈，最终在<code>weak_register_no_lock()</code>函数当中，进行弱引用变量的添加，具体添加的位置是通过哈希算法来查找的。如果对应位置已经存在当前对象的弱引用表（数组），那就把弱引用变量添加进去；如果不存在的话，就创建一个弱引用表，然后将弱引用变量添加进去。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-ISA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-ISA/" class="post-title-link" itemprop="url">内存管理-ISA & Weak底层</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-28 17:33:31" itemprop="dateCreated datePublished" datetime="2020-10-28T17:33:31+08:00">2020-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-29 23:01:09" itemprop="dateModified" datetime="2020-10-29T23:01:09+08:00">2020-10-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><h4 id="ISA结构体定义"><a href="#ISA结构体定义" class="headerlink" title="ISA结构体定义"></a>ISA结构体定义</h4><p>oc对象的本质其实是就是结构体，类也是对象，每个对象都有isa指针，对象的isa指针指向该对象所属的类，类对象的<code>isa</code>指针指向的是当前类的元类对象。</p>
<p>ARM64位架构之前，<code>isa</code>只是一个指针，<code>arm64</code>之后，<code>isa</code>是一个联合体/共用体(union)，这是苹果对于isa的优化，结合位域的概念以及位运算的方式来存储更多类相关的信息，简单来说isa指针通过一个叫ISA_MASK的值进行二进制&amp;运算，得到真实的<code>class/meta-class</code>对象的地址。</p>
<p><code>arm64</code>架构之前，isa指针直接指向当前类<code>objc_class</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>arm64</code>之后，<code>isa</code>不再是一个普通的<code>isa</code>指针，也是<code>isa_t</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步根据<code>isa_t</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">      <span class="comment">// 截取arm64架构下定义</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      uintptr_t nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      uintptr_t magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过源码发现isa_t是一个union联合体，union看上去跟struct差不多，只是命名不同，但是union的定义是它使得几个不同类型的变量共占一段内存（互相覆盖），每次只有一个能使用，而struct的成员则具备独立的内存空间，在使用时互不影响。</p>
<p>举个例子，假设A类里面声明一个union</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> x &#123;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">bool</span> isRich;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上定义后，系统会为union x分配8个字节的内存空间，因为指针占8位，int占4位，bool占1位，该union的内存大小由其内部占最大自己的成员类型决定，因为后续操作是需要互相覆盖的。</p>
<p>在看Struct的定义，假设B类中声明了一个Struct</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">bool</span> isRich;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上定义后，系统会为这个struct x分配16个字节的内存空间，各成员所占内存跟上述大小一致，各自有独立对应的内存空间，不过这里由于需要内存对齐，导致结构体的内存大小不再是8bit</p>
<p>接着回到上述结构体的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个成员后面都会有一个:x ,其实这个:x就是位域的应用，简单来说，有的信息他所需要的内存不足以填满一个字节的空间，比如开关状态这样的信息，其实只需要一个二进制空间即可存储，这样就达到了节约内存的目的。（<strong>位域概念是C语言里面的一种数据结构，将一个字节中的二进位划分为多个不同的区域，每个区域具备几个位数，每个域给定一个域名，允许程序中按域名进行操作，这样可以把几个不同的对象用一个字节的二进制位域来表示</strong>）</p>
<ul>
<li>nonpointer——0:代表普通指针，存储class/meta-class对象的内存地址；1:代表优化过，使用位域存储更多信息</li>
<li>has_assoc—— 是否设置过关联对象，如果没有，释放时会更快</li>
<li>has_cxx_dtor——是否有c++的析构函数，如果没有，释放时会更快</li>
<li>shiftcls——这个部分存储的是真正的class/meta-class对象的内存地址，因此要通过isa &amp; ISA_MASK才能取出这里的33的值，得到对象真正的地址</li>
<li>magic——用于在调试的时候分辨对象是否完成了初始化</li>
<li>weakly_referenced——是否倍弱引用的指针指向过，如果没有，释放时会更快</li>
<li>deallocating——是否对象正在被释放</li>
<li>has_sidetable_rc——引用计数器是否过大无法存储在isa中，如果是，这里就是1，引用计数就会被存储在一个叫SideTable的散列表中</li>
<li>extra_rc——里面存储的值是引用计数的值（retainCount-1），如果这19位不够存储，has_sidetable_rc就会变为1</li>
</ul>
<p><img src="/Users/mikasa/Desktop/image_mark/23_8.png" alt="23_8"></p>
<h4 id="ISA初始化"><a href="#ISA初始化" class="headerlink" title="ISA初始化"></a>ISA初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initClassIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DisableNonpointerIsa  ||  cls-&gt;instancesRequireRawIsa()) &#123;</span><br><span class="line">        initIsa(cls, <span class="literal">false</span><span class="comment">/*not nonpointer*/</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initIsa(cls, <span class="literal">true</span><span class="comment">/*nonpointer*/</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::initProtocolIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> initClassIsa(cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到不管是类对象、实例对象、协议对象还是其他对象，初始化isa结构体最终都调用了initIsa函数，只是所传参数不同而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> nonpointer, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否进行isa优化</span></span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个新的isa_t结构体</span></span><br><span class="line">        <span class="keyword">isa_t</span> newisa(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ISA_MAGIC_VALUE的值是，0x000001a000000001ULL，转化为二进制是64位，可观察到实际只赋值了nonpointer 和 magic</span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        <span class="comment">// 将当前对象的类指针赋值到shiftcls</span></span><br><span class="line">        <span class="comment">// 类的指针式按照（8bits）对齐的，其指针后三位都是没有意义的，因此可以右移3位</span></span><br><span class="line">        newisa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Obj-C中，类的指针是按照字节（8bits）对齐的，也就是说类指针地址转化为十进制后，都是8的倍数，也就是说类指针地址转化为二进制后，后三位都是0，既然0是没有意义的，你们在存储的时候就可以忽略，用节省下来的空间存储一下其他信息。</p>
<p>因此在赋值shiftcls的时候右移三位是安全的，不会丢失任何指针信息。</p>
<h3 id="SideTables"><a href="#SideTables" class="headerlink" title="SideTables"></a>SideTables</h3><p><code>SideTables</code>是一类型是<code>StripedMap&lt;SideTable&gt;</code>的静态全局哈希表，iPhone下它是一个8个元素长度的<code>hash</code>数组，在Mac下它是一个64个元素长度的hash数组，里面存储了<code>SideTable</code>，<code>SideTable</code>的hash键值就是一个对象obj的address。</p>
<p>因此可以说，一个<code>obj</code>对呀一个<code>SideTable</code>，但是一个SideTable会对应多个<code>objc</code>。因为<code>SideTable</code>的数量只有8个，所以会有很多objc公用同一个<code>SideTable</code>的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alignas</span>(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> <span class="keyword">uint8_t</span> </span><br><span class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SideTableInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (SideTableBuf) StripedMap&lt;SideTable&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看下StripedMap的结构，StripedMap是一个以void *为hash key，T为value的hash表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;<span class="comment">//T value 64字节对齐</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT <span class="built_in">array</span>[StripeCount];<span class="comment">// 所有PaddedT 类型数据被存储在array中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法以void *为key 来获取对应的T</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;<span class="comment">// 防止index越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hash算法计算方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;<span class="comment">// 防止index越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将地址指针右移4位 异或 指针右移9位计算后，进行取余。</p>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><h4 id="SideTable定义"><a href="#SideTable定义" class="headerlink" title="SideTable定义"></a>SideTable定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;<span class="comment">// 自旋锁</span></span><br><span class="line">    RefcountMap refcnts;<span class="comment">// 引用计数器表（散列表）</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table; <span class="comment">// 弱引用表（散列表）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>spinlock_t：自旋锁，用于上锁/解锁<code>SideTable</code>，保证操作<code>SideTable</code>时的线程安全</li>
<li>RefcountMap:以<code>DisguisedPtr&lt;objc_object&gt;</code>为key的hash表，用来存储OC对象的引用计数器（仅在未开启isa指针优化，或isa引用计数器溢出的情况下才会用到）</li>
<li>weak_table_t：存储对象弱引用指针的hash表</li>
</ul>
<p><code>SideTable</code>表存储在<code>SideTables()</code>中，<code>SideTables()</code>本质也是散列表，可以通过对象指针来获取他对应的（引用计数器和弱引用表）在哪一个<code>SideTable</code>中。在非嵌入式系统中，<code>SideTables()</code>有64的<code>SideTable</code></p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><strong>Q：如何找到对象所在的SideTable？</strong></p>
<p>A：通过<code>indexForPointer</code>函数计算hash算法，找到对象应用的<code>SideTable</code></p>
<p><strong>Q：为什么不是用一个SideTable，而是用SideTables去管理多个SideTable？</strong></p>
<p>A：SideTable中有一个自旋锁，如果把所有类都放在同一个<code>SideTable</code>，有任何一个类有改动都会对当前<code>SideTable</code>进行加锁操作，其他操作处于等待状态，这样会导致操作效率和查询效率很低。而多个<code>SideTable</code>的话，操作的都是单个SideTable，并不会影响其他<code>SideTable</code>，这就是分离锁。</p>
<p>​    全局的引用计数器之所以不存在同一个表中，是为了避免资源竞争，解决效率问题。引用计数表中引入了分离锁的概念，将一个表拆分位多个部分，对他们分别加锁，可以实现并发操作，提升执行效率。</p>
<p><strong>Q：如何找到对象的引用计数器？</strong></p>
<p>A：先找到对象所在<code>SideTable</code>，然后根据<code>refcnts</code>查找获取引用计数器值，<code>refcnts</code>也是一个散列表，以当前对象为key，value为引用计数器的值，如果是<code>nonpointer</code>为1的<code>isa</code>指针，还需加上<code>extra_rc</code>的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">inline uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    if (bits.nonpointer) &#123;</span><br><span class="line">        uintptr_t rc &#x3D; 1 + bits.extra_rc;</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc +&#x3D; sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 获取SideTable表中refcnts的值</span><br><span class="line">size_t </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h3><p><code>weak_table_t</code>是全局保存的弱引用的hash表，以<code>object</code> ids为keys，以<code>weak_entry_t</code>为values</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The global weak references table. Stores object ids as keys,</span><br><span class="line"> * and weak_entry_t structs as their values.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct weak_table_t &#123;</span><br><span class="line">  weak_entry_t *weak_entries;&#x2F;&#x2F; 存储weak_entry_t的哈希数组</span><br><span class="line">  size_t    num_entries;&#x2F;&#x2F; 当前weak_entries保存的weak_entry_t的数量，哈希数组内保存的元素个数</span><br><span class="line">  uintptr_t mask;&#x2F;&#x2F; 哈希数组的总长度-1，会参与hash函数计算</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 记录所有项的最大偏移量，即发生hash冲突的最大次数</span><br><span class="line">  &#x2F;&#x2F; 用户判断是否出现了逻辑错误，hash表中的冲突次数绝对不会超过这个值</span><br><span class="line">  &#x2F;&#x2F; 因为会有hash碰撞的情况，而weak_entry_t采用了开放地址寻址法来解决</span><br><span class="line">  &#x2F;&#x2F; 所以某个weak_entry_t时机存储的位置不一定是hash函数计算出来的结果</span><br><span class="line">  uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h4><p><code>weak_entry_t</code>的功能是保存一个对象，然后保存一组对象的弱引用</p>
<p><code>weak_entry_t</code>的哈希存储的数据是<code>weak_referrer_t</code>，实质上是弱引用变量的地址，即objc_object **，通过操作指针的指针，就可以使得弱引用变量在对象析构后指向nil。这里必须保存弱引用变量的地址，才能把它的指向置为nil</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">  <span class="comment">// referent中存放的化身为整数的objec_object的实例的地址，下面保存的弱引用变量都指向这个对象</span></span><br><span class="line">  DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当指向referent的弱引用个数小于等于4时使用inline_referrers数组保存这些弱引用变量的地址</span></span><br><span class="line">  <span class="comment">// 大于4以后用referent这个哈希数组保存</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 公用32个字节内存空间的联合体</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span> *referrers;<span class="comment">//保存weak_referrer_t的哈希数组</span></span><br><span class="line">        <span class="comment">// out_of_line_ness 和 num_refs 构成位域存储，共占64位</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;<span class="comment">// 2，标记当前使用哈希数组还是inline_referrers保存weak_referrer_t</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;<span class="comment">// 62，当前referrers内保存的weak_referrer_t数量</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        mask;<span class="comment">// referrers哈希数组总长度-1，会参与哈希函数计算</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可能会发生hash冲突的最大次数，用于判断是否出现了逻辑错误，（hash表中的冲突次数绝对不会超过该值）</span></span><br><span class="line">        <span class="comment">// 该值在新建weak_entry_t和插入新的weak_referrer_t时会被更新，它一直记录的都是最大偏移量</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">        <span class="comment">// out_of_line_ness和 inline_referrers[1]的低两位的内存空间重合</span></span><br><span class="line">        <span class="comment">// 长度为4的weak_referrer_t数组</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回true表示inline_referrers保存，返回false表示referrers保存weak_referrer_t</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重载操作符，直接使用memcpy拷贝other到this</span></span><br><span class="line">  <span class="keyword">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// newReferent是原始对象的指针，newReferrer是指向newReferent弱引用变量的地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化列表</span></span><br><span class="line">  <span class="keyword">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">      : referent(newReferent)</span><br><span class="line">  &#123;</span><br><span class="line">      inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">      <span class="comment">// 将inline_referrers数组中的剩余3位都置为nil</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">          inline_referrers[i] = nil;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之所以使用定长/哈希数组的切换，应该是考了到实例对象的弱引用变量个数一般比较少，这是使用定长数组不需要在动态申请内存空间（union中两个结构体公用32个字节内存），而是使用weak_entry_t初始化时分配的一块连续内存空间，这回得到允许效率上的提升。</p>
<h4 id="weak-referrer-t"><a href="#weak-referrer-t" class="headerlink" title="weak_referrer_t"></a>weak_referrer_t</h4><p>用于伪装__weak变量的地址，即用于伪装objc_object *的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The address of a __weak variable.</span></span><br><span class="line"><span class="comment">// These pointers are stored disguised so memory analysis tools</span></span><br><span class="line"><span class="comment">// don't see lots of interior pointers from the weak table into objects.</span></span><br><span class="line"><span class="comment">// __weak变量的地址（objc_object **），这些指针是伪装的，因此内存分析工具不会看到从weak table到object的大量内部指针</span></span><br><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; <span class="keyword">weak_referrer_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="object-setIvar"><a href="#object-setIvar" class="headerlink" title="_object_setIvar"></a>_object_setIvar</h3><p>设置对象的成员变量，根据成员变量获取当前成员变量类型是strong、weak以及_unsafe_unretained，调用对象存储函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_setIvar(id obj, Ivar ivar, id value, <span class="keyword">bool</span> assumeStrong)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj  ||  !ivar  ||  obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> offset;</span><br><span class="line">    <span class="keyword">objc_ivar_memory_management_t</span> memoryManagement;</span><br><span class="line">    _class_lookUpIvar(obj-&gt;ISA(), ivar, offset, memoryManagement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryManagement == objc_ivar_memoryUnknown) &#123;</span><br><span class="line">        <span class="keyword">if</span> (assumeStrong) memoryManagement = objc_ivar_memoryStrong;</span><br><span class="line">        <span class="keyword">else</span> memoryManagement = objc_ivar_memoryUnretained;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id *location = (id *)((<span class="keyword">char</span> *)obj + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (memoryManagement) &#123;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryWeak:       objc_storeWeak(location, value); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryStrong:     objc_storeStrong(location, value); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryUnretained: *location = value; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryUnknown:    _objc_fatal(<span class="string">"impossible"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-storeWeak"><a href="#objc-storeWeak" class="headerlink" title="objc_storeWeak"></a>objc_storeWeak</h4><blockquote>
<p>更新指针指向，创建对应的弱引用表</p>
<p>如果存在旧表，也存在成员值，需要进行清理操作，因为这个值可能是nil</p>
<p>如果有新表，赋值这个新值到变量中，这个值可能是nil</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Update a weak variable.</span><br><span class="line">&#x2F;&#x2F; If HaveOld is true, the variable has an existing value </span><br><span class="line">&#x2F;&#x2F;   that needs to be cleaned up. This value might be nil.</span><br><span class="line">&#x2F;&#x2F; If HaveNew is true, there is a new value that needs to be </span><br><span class="line">&#x2F;&#x2F;   assigned into the variable. This value might be nil.</span><br><span class="line">&#x2F;&#x2F; If CrashIfDeallocating is true, the process is halted if newObj is </span><br><span class="line">&#x2F;&#x2F;   deallocating or newObj&#39;s class does not support weak references. </span><br><span class="line">&#x2F;&#x2F;   If CrashIfDeallocating is false, nil is stored instead.</span><br><span class="line">enum CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating &#x3D; false, DoCrashIfDeallocating &#x3D; true</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj) &#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前置条件判断</li>
<li>声明新旧两个SideTable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (haveOld) &#123;</span><br><span class="line">    oldObj &#x3D; *location;</span><br><span class="line">    oldTable &#x3D; &amp;SideTables()[oldObj];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    oldTable &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line">if (haveNew) &#123;</span><br><span class="line">    newTable &#x3D; &amp;SideTables()[newObj];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    newTable &#x3D; nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据新值和旧值分别获区全局的SideTables表中的SideTable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls &#x3D; newObj-&gt;getIsa();</span><br><span class="line">        if (cls !&#x3D; previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            class_initialize(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If this class is finished with +initialize then we&#39;re good.</span><br><span class="line">            &#x2F;&#x2F; If this class is still running +initialize on this thread </span><br><span class="line">            &#x2F;&#x2F; (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">            &#x2F;&#x2F; then we may proceed but it will appear initializing and </span><br><span class="line">            &#x2F;&#x2F; not yet initialized to the check above.</span><br><span class="line">            &#x2F;&#x2F; Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">            previouslyInitializedClass &#x3D; cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>确保对象在弱引用之前，以及成功初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Clean up old value, if any.</span><br><span class="line">if (haveOld) &#123;</span><br><span class="line">  weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空旧值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign new value, if any.</span></span><br><span class="line"><span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">    newObj = (objc_object *)</span><br><span class="line">        weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                              crashIfDeallocating);</span><br><span class="line">    <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">    <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">        newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">    *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储新值<code>weak_register_no_lock</code>函数执行真正的存储逻辑</p>
<h4 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, id referent_id, </span><br><span class="line">                      id *referrer_id, bool crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F; referent弱引用对象，referrer weak指针的地址</span><br><span class="line">    objc_object *referent &#x3D; (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer &#x3D; (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; now remember it and where it is being stored</span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    if ((entry &#x3D; weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Do not set *referrer. objc_storeWeak() requires that the </span><br><span class="line">    &#x2F;&#x2F; value not change.</span><br><span class="line"></span><br><span class="line">    return referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明一个<code>weak_entry_t</code>类型实体，这里保存了呗弱引用对象的指针和weak指针的地址</li>
<li>根据弱引用对象的指针从全局<code>weak_table</code>中查找<code>entry</code>，如果找到则执行插入操作。</li>
<li>如果<code>weak_entry_for_referent</code>返回的entry存储<code>weak</code>指针的是<code>inline_referrers</code>类型，今天通过直接操作数组中的元素来达到修改数值的目的</li>
<li>如果没有查找到<code>entry</code>，则新建一个<code>weak_entry_t</code>结构体数组，直接将这个<code>weak_entry_t</code>插入到<code>weak_table</code>表中</li>
</ul>
<blockquote>
<p><code>weak_table_t</code>调用<code>weak_grow_maybe</code> 和 <code>weak_compact_maybe</code>这两个函数，用来当<code>weak_table_t</code>哈希数组过满或者为空的情况下及时调整其大小，优化内存的使用效率，并提高查找效率。这两个函数都是通过<code>weak_resize</code>函数来调整weak_table_t数组的大小</p>
</blockquote>
<h4 id="weak-grow-maybe"><a href="#weak-grow-maybe" class="headerlink" title="weak_grow_maybe"></a>weak_grow_maybe</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Grow the given zone&#39;s table of weak references if it is full.</span><br><span class="line">&#x2F;&#x2F; 如果给定区域的弱引用表已满，则对齐进行扩展</span><br><span class="line">static void weak_grow_maybe(weak_table_t *weak_table)</span><br><span class="line">&#123;</span><br><span class="line">    size_t old_size &#x3D; TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Grow if at least 3&#x2F;4 full.</span><br><span class="line">    &#x2F;&#x2F; 如果目前哈希数组中存储的weak_entry_t数量超过了总长度的3 &#x2F; 4，则进行扩容</span><br><span class="line">    if (weak_table-&gt;num_entries &gt;&#x3D; old_size * 3 &#x2F; 4) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果weak_table是新建的，则出事其哈希数组长度为64，如果是非空，则扩容为之前长度的两倍</span><br><span class="line">        weak_resize(weak_table, old_size ? old_size*2 : 64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数用于扩充<code>weak_table_t</code>的<code>weak_entry_t *weak_entries</code>长度，扩充条件是<code>num_entries</code>长度超过了mask+1的3 / 4。初始化<code>weak_table</code>长度是64，每次扩充的长度则是mask+1的两倍，扩容完毕后会把原哈希数组中的weak_entry_t重新哈希化插入到新空间内，并更新weak_tabl_t各成员变量。占据的内存空间的总容量则是<code>(mask+1) * sizeof(weak_entry_t)</code>字节。综上mask+1总是2的N次方（2^6=64 即 N&gt;=6）</p>
<h4 id="weak-compact-maybe"><a href="#weak-compact-maybe" class="headerlink" title="weak_compact_maybe"></a>weak_compact_maybe</h4><p>该函数会在weak_entry_remove函数中调用，旨在<code>weak_entry_t</code>从<code>weak_table_t</code>的数组中移除后，缩小<code>weak_entry_t *weak_entries</code>的空间</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shrink the table if it is mostly empty.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_compact_maybe(weak_table_t *weak_table)</span><br><span class="line">&#123;</span><br><span class="line">    size_t old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shrink if larger than 1024 buckets and at most 1/16 full.</span></span><br><span class="line">    <span class="comment">// old_size 超过了1024 并且低于1/16的空间占用率，则进行缩小 </span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= <span class="number">1024</span>  &amp;&amp; old_size / <span class="number">16</span> &gt;= weak_table-&gt;num_entries) &#123;</span><br><span class="line">        <span class="comment">// 缩小容量为1/8</span></span><br><span class="line">        weak_resize(weak_table, old_size / <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// leaves new table no more than 1/2 full</span></span><br><span class="line">        <span class="comment">// 缩小容量1/8 和 空间占用率少于1/16，两个条件组合在一起，保证缩小后的容量占用少于1/2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩小<code>weak_entry_t *weak_entries</code>容量的条件是目前的总长度超过了1024 和 容量占用了少于1/16，<code>weak_entries</code>空间缩小为当前空间的1/8</p>
<h4 id="weak-resize"><a href="#weak-resize" class="headerlink" title="weak_resize"></a>weak_resize</h4><p>扩大和缩小空间都会调用的weak_resize公共函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_resize(weak_table_t *weak_table, size_t new_size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// old_size = mask+1;表示原始哈希数组的总长度</span></span><br><span class="line">  size_t old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧weak_entries哈希数组的起始地址</span></span><br><span class="line">  weak_entry_t *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">  <span class="comment">// 为新 weak_entries 哈希数组申请指定长度的空间，并把起始地址返回</span></span><br><span class="line">  <span class="comment">// 内存空间大小为 new_size * sizeof(weak_entry_t)</span></span><br><span class="line">  weak_entry_t *new_entries = (weak_entry_t *)</span><br><span class="line">      calloc(new_size, <span class="keyword">sizeof</span>(weak_entry_t));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新mask,仍是new_size-1</span></span><br><span class="line">  weak_table-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 更新哈希数组起始地址</span></span><br><span class="line">  weak_table-&gt;weak_entries = new_entries;</span><br><span class="line">  <span class="comment">// 最大哈希冲突偏移值，默认为0</span></span><br><span class="line">  weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 当前哈希数组的占用数量，默认为0</span></span><br><span class="line">  weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有旧的weak_entry_t，需要放在新的空间内</span></span><br><span class="line">  <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">      weak_entry_t *entry;</span><br><span class="line">      weak_entry_t *end = old_entries + old_size;</span><br><span class="line">      <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">              weak_entry_insert(weak_table, entry);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      free(old_entries);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="weak-entry-insert"><a href="#weak-entry-insert" class="headerlink" title="weak_entry_insert"></a>weak_entry_insert</h4><p>将weak_entry_t<code>添加到</code>weak_table_t-&gt;weak_entries中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Add new_entry to the object&#39;s table of weak references.</span><br><span class="line"> * Does not check whether the referent is already in the table.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 添加一个新的weak_entry_t到对象的弱引用表中</span><br><span class="line">&#x2F;&#x2F; 不进行检查引用对象是否已存在表中</span><br><span class="line">static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 哈希数组的起始地址</span><br><span class="line">  weak_entry_t *weak_entries &#x3D; weak_table-&gt;weak_entries;</span><br><span class="line">  assert(weak_entries !&#x3D; nil);</span><br><span class="line">	&#x2F;&#x2F; 调用hash函数找到new_entry在weak_table_t的哈希数组中的位置，可能会发生hash冲突</span><br><span class="line">  size_t begin &#x3D; hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">  size_t index &#x3D; begin;</span><br><span class="line">  size_t hash_displacement &#x3D; 0;</span><br><span class="line">  while (weak_entries[index].referent !&#x3D; nil) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 如果发生hash冲突+1，继续往下探测</span><br><span class="line">      index &#x3D; (index+1) &amp; weak_table-&gt;mask;</span><br><span class="line">      &#x2F;&#x2F; 如果index每次+1加到值等于begin还是没有找到空位置，则触发bad_weak_table致命错误</span><br><span class="line">      if (index &#x3D;&#x3D; begin) bad_weak_table(weak_entries);</span><br><span class="line">      &#x2F;&#x2F; 记录偏移量 用于更新max_hash_displacement</span><br><span class="line">      hash_displacement++;</span><br><span class="line">  &#125;</span><br><span class="line">	&#x2F;&#x2F; new_entry放入哈希数组中</span><br><span class="line">  weak_entries[index] &#x3D; *new_entry;</span><br><span class="line">  &#x2F;&#x2F; 更新num_entries</span><br><span class="line">  weak_table-&gt;num_entries++;</span><br><span class="line">	&#x2F;&#x2F; 记录weak_table_t哈希数组中发生哈希冲突时的最大偏移量</span><br><span class="line">  if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">      weak_table-&gt;max_hash_displacement &#x3D; hash_displacement;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综合来看，weak_entry_insert函数可知weak_resize函数的整体左右，该函数对哈希数组进行的扩大和缩小，首先根据new_size申请相应大小的内存，new_entries指针指向这块新申请的内存。设置weak_table的mask为new_size-1。此处mask的作用是记录weak_table 总容量的内存边界，此外mask还用在哈希函数中保证index不会哈希数组越界。</p>
<p>​    weak_table_t的哈希数组可能会发生哈希碰撞，而weak_table_t采用了开放地址寻址法来处理碰撞。如果发生碰撞的话，将寻找相邻（如果已经到尾端的话，则从头开始）的下一个空位，例如weak_entry_for_referent函数，寻找给定的referent在弱引用表中的entry时，如果在循环过程中hash_displacement的值超过了weak_table-&gt;max_hash_displacement则表示，不存在要找的weak_entry_t</p>
<h4 id="weak-entry-for-referent"><a href="#weak-entry-for-referent" class="headerlink" title="weak_entry_for_referent"></a>weak_entry_for_referent</h4><blockquote>
<p>根据给定的referent 和 weak_table_t哈希表，查找其中的weak_entry_t并返回，如果未找到则返回NULL。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Return the weak reference table entry for the given referent. </span><br><span class="line"> * If there is no entry for referent, return NULL. </span><br><span class="line"> * Performs a lookup.</span><br><span class="line"> *</span><br><span class="line"> * @param weak_table </span><br><span class="line"> * @param referent The object. Must not be nil.</span><br><span class="line"> * </span><br><span class="line"> * @return The table of weak referrers to this object. </span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; weak_table通过&amp;SideTables()[referent]可从全局的SideTables中找到referent所处的weak_table</span><br><span class="line">static weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    assert(referent);</span><br><span class="line">		&#x2F;&#x2F; weak_table_t哈希数组的入口</span><br><span class="line">    weak_entry_t *weak_entries &#x3D; weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    if (!weak_entries) return nil;</span><br><span class="line"></span><br><span class="line">  	&#x2F;&#x2F; 哈希函数：hash_pointer函数返回值与mask做与，防止index越界</span><br><span class="line">    size_t begin &#x3D; hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index &#x3D; begin;</span><br><span class="line">    size_t hash_displacement &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 如果未发生哈希冲突的话，这weak_table-&gt;weak_entries[index]就是要找的weak_entry_t了</span><br><span class="line">    while (weak_table-&gt;weak_entries[index].referent !&#x3D; referent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果发生了哈希冲突 + 1，继续向下探测（开放地址寻址法）</span><br><span class="line">        index &#x3D; (index+1) &amp; weak_table-&gt;mask;</span><br><span class="line">        if (index &#x3D;&#x3D; begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        &#x2F;&#x2F; 记录探测偏移了多远</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        &#x2F;&#x2F; 如果探测偏移超过了 weak_table_t 的 max_hash_displacement，则说明weak_table中没有referent的weak_entry_t，则返回nil</span><br><span class="line">        if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Tagged-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Tagged-Pointer/" class="post-title-link" itemprop="url">内存管理-Tagged Pointer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-27 19:18:37" itemprop="dateCreated datePublished" datetime="2020-10-27T19:18:37+08:00">2020-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-28 17:32:55" itemprop="dateModified" datetime="2020-10-28T17:32:55+08:00">2020-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>苹果在iOS采用RC（引用计数器）进行内存管理，在MRC时代需要我们手动进行内存管理调用retain和release进行引用计数器+1和-1，iOS5之后苹果引入了ARC，通过LLVM和Runtime运行机制编译器自动帮忙添加上retain、release和autoreleasepool进行内存管理，大多数情况下我们已经不用在管理引用计数器问题。</p>
<p>但是为了了解系统内存管理的本质，需要我们通过源码去探究一下。</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>对象在内存中是对齐的，他们的地址总是指针的整数倍，通常为16倍数</p>
<p>通常情况下，对象、指针、NSInteger的内存占用都与当前CPU的位数有关，一个NSInteger类型的变量在32位下占4个字节，在64位下就会占用8个字节，指针也是，对象同理，同一个程序从32位机器上迁移到64位机器上，虽然逻辑没变化，但是内存占用上会翻倍，同时在效率上为了存储和访问一个NSNumber对象，我们需要在堆上为它分配内存维护引用计数器，管理它的生命周期，这都将造成运行效率上的损失。</p>
<h4 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h4><p>为了改进内存和效率上的问题，苹果引入了Tagged Pointer，由于NSNumber之类的变量本身的值需要占用的内存大小常常不需要8字节。所以我们可以将一个对象拆分为两个部分，一部分直接保存数据，一部分作为特殊标记，表示这是一个特别的指针不指向任何一个地址。</p>
<h3 id="Tagged-Pointer定义"><a href="#Tagged-Pointer定义" class="headerlink" title="Tagged Pointer定义"></a>Tagged Pointer定义</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if __LP64__</span><br><span class="line">#define OBJC_HAVE_TAGGED_POINTERS 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>64-bit，tag存储在LSB（Least Significant Bit最低位）。其他情况比如真机，tag存储在MSB（Most Significant Bit最高位）</p>
<ul>
<li><code>MacOS</code>下采用 LSB（Least Significant Bit，即最低有效位）为<code>Tagged Pointer</code>标识位；</li>
<li><code>iOS</code>下则采用 MSB（Most Significant Bit，即最高有效位）为<code>Tagged Pointer</code>标识位。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span><br><span class="line">    &#x2F;&#x2F; 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">    &#x2F;&#x2F; Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 1</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK 0xfUL</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>接下来是一个枚举定义，定义了默认使用了<code>Tagged Pointer</code>的类。例如NSString、NSNumber、NSIndexPath、NSDate</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">objc_tag_index_t</span> : <span class="keyword">uint16_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">objc_tag_index_t</span>;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 60-bit payloads</span></span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 60-bit reserved</span></span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 52-bit payloads</span></span><br><span class="line">    OBJC_TAG_Photos_1          = <span class="number">8</span>,</span><br><span class="line">    OBJC_TAG_Photos_2          = <span class="number">9</span>,</span><br><span class="line">    OBJC_TAG_Photos_3          = <span class="number">10</span>,</span><br><span class="line">    OBJC_TAG_Photos_4          = <span class="number">11</span>,</span><br><span class="line">    OBJC_TAG_XPC_1             = <span class="number">12</span>,</span><br><span class="line">    OBJC_TAG_XPC_2             = <span class="number">13</span>,</span><br><span class="line">    OBJC_TAG_XPC_3             = <span class="number">14</span>,</span><br><span class="line">    OBJC_TAG_XPC_4             = <span class="number">15</span>,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  &amp;&amp;  !defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">objc_tag_index_t</span> <span class="keyword">objc_tag_index_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><p>校验是否是<code>tagged pointer</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成一个<code>tagged pointer</code>，最高四位是tagged，余下是数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * _Nonnull</span><br><span class="line">_objc_makeTaggedPointer(<span class="keyword">objc_tag_index_t</span> tag, <span class="keyword">uintptr_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// PAYLOAD_LSHIFT and PAYLOAD_RSHIFT are the payload extraction shifts.</span></span><br><span class="line">    <span class="comment">// They are reversed here for payload insertion.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// assert(_objc_taggedPointersEnabled());</span></span><br><span class="line">    <span class="keyword">if</span> (tag &lt;= OBJC_TAG_Last60BitPayload) &#123;</span><br><span class="line">        <span class="comment">// assert(((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT) == value);</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> result =</span><br><span class="line">            (_OBJC_TAG_MASK | </span><br><span class="line">             ((<span class="keyword">uintptr_t</span>)tag &lt;&lt; _OBJC_TAG_INDEX_SHIFT) | </span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT));</span><br><span class="line">        <span class="keyword">return</span> _objc_encodeTaggedPointer(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// assert(tag &gt;= OBJC_TAG_First52BitPayload);</span></span><br><span class="line">        <span class="comment">// assert(tag &lt;= OBJC_TAG_Last52BitPayload);</span></span><br><span class="line">        <span class="comment">// assert(((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) == value);</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> result =</span><br><span class="line">            (_OBJC_TAG_EXT_MASK |</span><br><span class="line">             ((<span class="keyword">uintptr_t</span>)(tag - OBJC_TAG_First52BitPayload) &lt;&lt; _OBJC_TAG_EXT_INDEX_SHIFT) |</span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT));</span><br><span class="line">        <span class="keyword">return</span> _objc_encodeTaggedPointer(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Tagged Pointer中获取值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">objc_tag_index_t</span> </span><br><span class="line">_objc_getTaggedPointerTag(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    <span class="keyword">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">uintptr_t</span> extTag =   (value &gt;&gt; _OBJC_TAG_EXT_INDEX_SHIFT) &amp; _OBJC_TAG_EXT_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">objc_tag_index_t</span>)(extTag + OBJC_TAG_First52BitPayload);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">objc_tag_index_t</span>)basicTag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Tagged Pointer的引入，直接将值存储于指针本身，不旦减少了内存的占用，而且它不存在在堆中，也不需要malloc和free，还提高了运行效率。</p>
<p>我们也可以在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，看到苹果对于<code>Tagged Pointer</code>特点的介绍：</p>
<ul>
<li>Tagged Pointer专门用于存储小的对象，例如NSNumber、NSSting</li>
<li>Tagged Pointer的值不再是地址，而是真正的值，所以，它实际不再是一个对象，它只是一个披着对象皮的指针，所以它并不存储在堆中，也不需要malloc和free</li>
<li>在内存读取上有着3倍的速度，创建时也比之前快106倍</li>
</ul>
<h5 id="关闭tagged-pointer的数据混淆"><a href="#关闭tagged-pointer的数据混淆" class="headerlink" title="关闭tagged pointer的数据混淆"></a>关闭tagged pointer的数据混淆</h5><p>在现在的版本中，为了保证数据安全，苹果对tagged point做了数据混淆，开发者通过打印指针无法判断他是不是一个tagged pointer，更无法读取其存储的数据。</p>
<p>在分析tagged pointer之前，我们需要先把<code>tagged pointer</code>数据混淆关闭，以方便我们进行调试。通过设置环境变量<code>OBJC_DISABLE_TAG_OBFUSCATION</code>为<code>YES</code></p>
<h4 id="iOS应用举例"><a href="#iOS应用举例" class="headerlink" title="iOS应用举例"></a>iOS应用举例</h4><h5 id="NSNumber应用"><a href="#NSNumber应用" class="headerlink" title="NSNumber应用"></a>NSNumber应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *charNumber &#x3D; [NSNumber numberWithChar:&#39;1&#39;];</span><br><span class="line">NSNumber *shortNumber &#x3D; [NSNumber numberWithShort:1];</span><br><span class="line">NSNumber *intNumber &#x3D; [NSNumber numberWithInt:1];</span><br><span class="line">NSNumber *floatNumber &#x3D; [NSNumber numberWithFloat:1.0];</span><br><span class="line">NSNumber *longNumber &#x3D; [NSNumber numberWithLong:1];</span><br><span class="line">NSNumber *doubleNumber &#x3D; [NSNumber numberWithDouble:1.0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出变量的指针地址：</span><br><span class="line">&#x2F;&#x2F; charNumber 0xb000000000000310</span><br><span class="line">&#x2F;&#x2F; shortNumber 0xb000000000000011</span><br><span class="line">&#x2F;&#x2F; intNumber 0xb000000000000012</span><br><span class="line">&#x2F;&#x2F; floatNumber 0xb000000000000014</span><br><span class="line">&#x2F;&#x2F; longNumber 0xb000000000000013</span><br><span class="line">&#x2F;&#x2F; doubleNumber 0xb000000000000015</span><br></pre></td></tr></table></figure>

<p><img src="/Users/mikasa/Desktop/image_mark/image-20201028113927598.png" alt="image-20201028113927598"></p>
<p>规律都是以0xb(1011开头)</p>
<ul>
<li>最高位是1，说明指针是一个Tagged Pointer类型</li>
<li>第61-63位是11（十进制对应的是3），根据上诉枚举定义也就是（OBJC_TAG_NSNumber）</li>
<li>第1-4位是NSNumber类型，比如char是0 short是1，int是2，float是4，long是3，double是5</li>
<li>剩下56位就是真正的值了</li>
</ul>
<p><img src="/Users/mikasa/Desktop/image_mark/zufmtqnvbq.png" alt="zufmtqnvbq"></p>
<h5 id="NSString应用"><a href="#NSString应用" class="headerlink" title="NSString应用"></a>NSString应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; [NSString stringWithFormat:@&quot;a&quot;];</span><br><span class="line">NSString *str2 &#x3D; [NSString stringWithFormat:@&quot;ab&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出变量的指针地址：</span><br><span class="line">&#x2F;&#x2F; str1: 0xa000000000000611</span><br><span class="line">&#x2F;&#x2F; str2: 0xa000000000062612</span><br></pre></td></tr></table></figure>

<p><img src="/Users/mikasa/Desktop/image_mark/image-20201028114331053.png" alt="image-20201028114331053"></p>
<p>与NSNumber类似</p>
<ul>
<li>最高位是1，说明指针是一个Tagged Pointer类型</li>
<li>第61-63位是10（对应的十进制是2），根据上述枚举定义类型也就是OBJC_TAG_NSString</li>
<li>第1-4位是字符串长度</li>
<li>剩下的56位就是真正的值了</li>
</ul>
<p>进一步扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSString *a &#x3D; @&quot;a&quot;;</span><br><span class="line">NSMutableString *b &#x3D; [a mutableCopy];</span><br><span class="line">NSString *c &#x3D; [a copy];</span><br><span class="line">NSString *d &#x3D; [[a mutableCopy] copy];</span><br><span class="line">NSString *e &#x3D; [NSString stringWithString:a];</span><br><span class="line">NSString *f &#x3D; [NSString stringWithFormat:@&quot;f&quot;];</span><br><span class="line">NSString *string1 &#x3D; [NSString stringWithFormat:@&quot;abcdefg&quot;];</span><br><span class="line">NSString *string2 &#x3D; [NSString stringWithFormat:@&quot;abcdefghi&quot;];</span><br><span class="line">NSString *string3 &#x3D; [NSString stringWithFormat:@&quot;abcdefghij&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;* MacOS打印结果</span><br><span class="line">a: 0x100002038, __NSCFConstantString, 18446744073709551615</span><br><span class="line">b: 0x10071f3c0, __NSCFString, 1</span><br><span class="line">c: 0x100002038, __NSCFConstantString, 18446744073709551615</span><br><span class="line">d: 0x6115, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">e: 0x100002038, __NSCFConstantString, 18446744073709551615</span><br><span class="line">f: 0x6615, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">string1: 0x6766656463626175, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">string2: 0x880e28045a54195, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">string3: 0x10071f6d0, __NSCFString, 1 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>从打印结果来看，有三种NSString类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__NSCFConstantString</td>
<td align="left">常量字符串，存储在字符串常量区，继承于 __NSCFString。相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例，可以通过 == 判断字符串内容是否相同。2. 这种对象一般通过字面值@”…”创建。如果使用 __NSCFConstantString 来初始化一个字符串，那么这个字符串也是相同的 __NSCFConstantString。</td>
</tr>
<tr>
<td align="left">__NSCFString</td>
<td align="left">存储在堆区，需要维护其引用计数，继承于 NSMutableString。2. 通过stringWithFormat:等方法创建的NSString对象（且字符串值过大无法使用Tagged Pointer存储）一般都是这种类型。</td>
</tr>
<tr>
<td align="left">NSTaggedPointerString</td>
<td align="left">Tagged Pointer，字符串的值直接存储在了指针上。</td>
</tr>
</tbody></table>
<p>打印结果分析：</p>
<table>
<thead>
<tr>
<th align="left">NSString 对象</th>
<th align="left">类型</th>
<th align="left">分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="left">__NSCFConstantString</td>
<td align="left">通过字面量@”…”创建</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">__NSCFString</td>
<td align="left">a 的深拷贝，指向不同的内存地址，被拷贝到堆区</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">__NSCFConstantString</td>
<td align="left">a 的浅拷贝，指向同一块内存地址</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">单独对 a 进行 copy（如 c），浅拷贝是指向同一块内存地址，所以不会产生Tagged Pointer；单独对 a 进行 mutableCopy（如 b），复制出来是可变对象，内容大小可以扩展；而Tagged Pointer存储的内容大小有限，因此无法满足可变对象的存储要求。</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">__NSCFConstantString</td>
<td align="left">使用 __NSCFConstantString 来初始化的字符串</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">通过stringWithFormat:方法创建，指针足够存储字符串的值。</td>
</tr>
<tr>
<td align="left">string1</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">通过stringWithFormat:方法创建，指针足够存储字符串的值。</td>
</tr>
<tr>
<td align="left">string2</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">通过stringWithFormat:方法创建，指针足够存储字符串的值。</td>
</tr>
<tr>
<td align="left">string3</td>
<td align="left">__NSCFString</td>
<td align="left">通过stringWithFormat:方法创建，指针不足够存储字符串的值。</td>
</tr>
</tbody></table>
<p><img src="/Users/mikasa/Desktop/image_mark/cj0aj4o1ul.png" alt="cj0aj4o1ul"></p>
<p>在objc4源码中，我们经常会在函数中看见tagged pointer。比如objc_msgSend函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL _cmd, ...);</span><br><span class="line"> * IMP objc_msgLookup(id self, SEL _cmd, ...);</span><br><span class="line"> * </span><br><span class="line"> * objc_msgLookup ABI:</span><br><span class="line"> * IMP returned in x17</span><br><span class="line"> * x16 reserved for our use but not used</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">	.data</span><br><span class="line">	.align 3</span><br><span class="line">	.globl _objc_debug_taggedpointer_classes</span><br><span class="line">_objc_debug_taggedpointer_classes:</span><br><span class="line">	.fill 16, 8, 0</span><br><span class="line">	.globl _objc_debug_taggedpointer_ext_classes</span><br><span class="line">_objc_debug_taggedpointer_ext_classes:</span><br><span class="line">	.fill 256, 8, 0</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #0			// nil check and tagged pointer check</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br><span class="line">	ldr	p13, [x0]		// p13 = isa</span><br><span class="line">	GetClassFromIsa_p16 p13		// p16 = class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p><code>objc_msgSend</code>函数能够识别<code>tagged pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，不会进行<code>objc_msgSend</code>的三大流程，节省了调用开销。</p>
<p>内存管理相关，如<code>retain</code>方法中的<code>rootRetain</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行判断是否是tagged pointer伪对象</p>
<h4 id="Tagged-Pointer注意点"><a href="#Tagged-Pointer注意点" class="headerlink" title="Tagged Pointer注意点"></a>Tagged Pointer注意点</h4><p>前面知道，tagged pointer并不是真正的对象，它没有isa指针，所以直接访问tagged pointer的isa成员的话，在编译器就会出现警告。</p>
<p><strong>执行以下两段待会，会出现什么情况？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)mm_tagged_no_pointer &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            self.name &#x3D; [NSString stringWithFormat:@&quot;abcdefghi1&quot;];</span><br><span class="line">            NSLog(@&quot;%p---%@&quot;,self.name,[self.name class]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果，Crash</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mm_tagged_pointer &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abcdefghi"</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%p---%@"</span>,<span class="keyword">self</span>.name,[<span class="keyword">self</span>.name <span class="keyword">class</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果，正常</p>
<p>分别打印两段代码中的<code>self.name</code>，可以发现第一段代码中的<code>self.name</code>类型为<code>CFString</code> ，第二段代码中的类型为<code>NSTaggedPointerString</code>。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201028161517267.png" alt="image-20201028161517267"></p>
<p>观察一下Crash崩溃函数调用信息，不难发现，在线程退出的时候，会对当前线程中的TSD数据（<code>Autoreleasepool</code>及放入其中的对象进行<code>release</code>），多条线程并发执行过程中，可能就会出现对一个对象多次调用<code>release</code>造成对象过度释放，导致Crash</p>
<p><strong>解决办法（保证多线程数据安全）：</strong></p>
<ul>
<li>使用atomic属性关键字</li>
<li>加锁</li>
<li>队列串行访问</li>
<li>信号量</li>
</ul>
<p>而第二段代码中的NSString类型为<code>NSTaggedPointerString</code>类型，在objc_release函数会判断是否是TaggedPointer类型，是的话就不会进行release操作，也就避免了因过度释放对象而导致的Crash。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/23/AutoreleasePool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/23/AutoreleasePool/" class="post-title-link" itemprop="url">AutoreleasePool</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-23 14:18:49" itemprop="dateCreated datePublished" datetime="2020-10-23T14:18:49+08:00">2020-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-26 17:24:32" itemprop="dateModified" datetime="2020-10-26T17:24:32+08:00">2020-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ARC和MRC下的autoreleasepool"><a href="#ARC和MRC下的autoreleasepool" class="headerlink" title="ARC和MRC下的autoreleasepool"></a>ARC和MRC下的autoreleasepool</h4><h5 id="MRC中的autoreleasepool"><a href="#MRC中的autoreleasepool" class="headerlink" title="MRC中的autoreleasepool"></a>MRC中的autoreleasepool</h5><p>在MRC环境下，当我们创建和释放一个对象时，需手动管理器内存周期，调用<code>retain</code> 和 <code>release</code>或autorelease方法来释放它。调用retain会让计数器+1，调用<code>release</code>会让计数器-1，当对象计数器为0时，就会被释放。调用<code>autorelease</code>的对象会被添加到自动释放池中，它会在一个合适的时候（下文）为对象调用<code>release</code>人，所以加入到<code>autorelease</code>中的对象会被延迟释放。</p>
<p><strong>release</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool1() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [[MMPerson alloc] init];</span><br><span class="line">        [person retain];</span><br><span class="line">        </span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">        [person release]</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person dealloc</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure>

<p><strong>autorelease</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool1() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [[[MMPerson alloc] init] autoreleasepool];</span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person</span><br><span class="line">person dealloc</span><br></pre></td></tr></table></figure>

<p>局部变量person调用release后会被立即释放，而将对象加入到autoreleasepool中不会立即释放，释放时机被延迟了。</p>
<h5 id="ARC中autoreleasepool"><a href="#ARC中autoreleasepool" class="headerlink" title="ARC中autoreleasepool"></a>ARC中autoreleasepool</h5><p>苹果在iOS5中引入了ARC（Automatic Reference Counting）自动引用计数器管理技术，通过LLVM编译器和Runtime机协作进行自动管理内存。LLVM会在编译时在合适的地方为OC对象插入retain、release和autoreleasepool代码。</p>
<p><strong>通过alloc、copy、mutableCopy和new方式创建对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool1() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [MMPerson new];</span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，对象出了作用域立即被释放了，编译时插入了release</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[20:53:54] -[MMPerson dealloc] [第22行] 💕 MMPerson dealloc</span><br><span class="line">[20:53:54] _addAutoReleasePool1 [第49行] 💕 (null)</span><br></pre></td></tr></table></figure>

<p><strong>通过系统提供工厂方法创建对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool2() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [MMPerson buttonWithType:UIButtonTypeSystem];</span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，对象超出了其作用域还是存在的，也就是说起内部调用了autorelease方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[20:53:54] _addAutoReleasePool2 [第58行] 💕 &lt;MMPerson: 0x7fdbad51fe90; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x6000002e6fc0&gt;&gt;</span><br><span class="line">[20:53:54] -[MMPerson dealloc] [第22行] 💕 MMPerson dealloc</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>以 <code>alloc</code>, <code>copy</code>, ,<code>mutableCopy</code>和<code>new</code>这些方法会被默认标记为 <code>__attribute((ns_returns_retained))</code> ，以这些方法创建的对象,编译器在会在调用方法外围要加上内存管理代码<code>retain/release</code>，所以其在作用域结束的时候就会释放，而不以这些关键字开头的方法，会被默认标记为<code>__attribute((ns_returns_not_retained))</code>,编译器会在方法内部自动加上<code>autorelease</code>方法，这时创建的对象就会被注册到自动释放池中，同时其释放会延迟，等到自动释放池销毁的时候才释放。</p>
<h4 id="main入口函数中的-autoreleasepool"><a href="#main入口函数中的-autoreleasepool" class="headerlink" title="main入口函数中的@autoreleasepool"></a>main入口函数中的@autoreleasepool</h4><p>我们先来看看Xcode11版本中的main()函数，与之前版本的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Xcode 11</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; Setup code that might create autoreleased objects goes here.</span><br><span class="line">        appDelegateClassName &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Xcode 旧版本</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的点是</strong>，Xcode11之前是将整个应用程序放在<code>@autoreleasepool</code>中，由于<code>runloop</code>的存在，要程序结束后<code>@autoreleasepool</code>作用域才会结束，这也意味着程序结束后<code>main</code>函数中的<code>@autoreleasepool</code>中的<code>autoreleasepool</code>对象才会释放</p>
<p>Xcode11之后，触发主线程的<code>UIApplicationMain</code>函数被放置在<code>@autoreleasepool</code>之外，这可以保证<code>@autoreleasepool</code>中的autoreleasepool对象在程序启动后可以被立即释放。</p>
<p><strong>网上对于<code>main()</code>函数中的<code>@autoreleasepool</code>有一种解释</strong>：</p>
<p>在iOS工程的<code>main()</code>函数中有一个<code>@autoreleasepool</code>，这个<code>@autoreleasepool</code>负责应用程序所有<code>autoreleasepool</code>对象的释放。</p>
<p><strong>这个解释是错误的</strong></p>
<p>如果你的程序使用了AppKit或UIKit框架，系统在主线程的<code>RunLoop</code>里注册了两个<code>Observer</code>，回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler</code> ，第一个<code>Observer</code>的状态是<code>activities=0x1</code>，第二个Observer的状态是<code>activities=0xa0</code></p>
<p><code>0x1</code>代表的是<code>kCFRunLoopEntry</code>，主线程的<code>runloop</code>就会在即将进入loop时，<code>Observe</code>监听的事件为Entry，其内部回调就会调用<code>_objc_autoreleasePoolPush()</code>创建一个自动释放池，优先级最高，保证创建自动释放池发生在其他所有回调之前</p>
<p><code>0xa0</code>代表的是<code>kCFRunLoopBeforeWaiting</code>和<code>kCFRunLoopExit</code>，在<code>kCFRunLoopBeforeWaiting</code>事件时调用<code>_objc_autoreleasePoolPop</code>和<code>_objc_autoreleasePoolPush</code>，释放旧的释放池和其中的资源并创建新的自动释放池；在<code>kCFRunLoopExit</code>事件时调用<code>_objc_autoreleasePoolPop</code>来释放自动释放池，同时这个<code>Observer</code>的优先级最低，保证其自动释放池的操作发生在其他回调之后.</p>
<p>也就是说主线程的runLoop会在每次事件循环迭代中创建并处理<code>@autoreleasepool</code>，而main函数中的<code>@autoreleasepool</code>只是管理他作用域中的对象。</p>
<p>以上场景与嵌套<code>@autoreleasepool</code>情况类似。</p>
<h4 id="嵌套-autoreleasepool"><a href="#嵌套-autoreleasepool" class="headerlink" title="嵌套@autoreleasepool"></a>嵌套<code>@autoreleasepool</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface MMPerson : UIButton</span><br><span class="line">@end</span><br><span class="line">@implementation MMPerson</span><br><span class="line">+ (instancetype)person &#123;</span><br><span class="line">    return [[MMPerson alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;MMPerson dealloc&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">NS_INLINE void _addAutoReleasePool() &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MMPerson *person &#x3D; [MMPerson person];</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            MMPerson *person1 &#x3D; person;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                MMPerson *person2 &#x3D; person;</span><br><span class="line">                NSLog(@&quot;current count %@&quot;,person);</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;current count 2%@&quot;,person);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;current count 3%@&quot;,person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[20:24:37] _addAutoReleasePool [第68行] 💕 current count 1&lt;MMPerson: 0x7ffe76d22460; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x60000224bce0&gt;&gt;</span><br><span class="line"></span><br><span class="line">[20:24:37] _addAutoReleasePool [第70行] 💕 current count 2&lt;MMPerson: 0x7ffe76d22460; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x60000224bce0&gt;&gt;</span><br><span class="line"></span><br><span class="line">[20:24:37] _addAutoReleasePool [第72行] 💕 current count 3&lt;MMPerson: 0x7ffe76d22460; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x60000224bce0&gt;&gt;</span><br><span class="line"></span><br><span class="line">[20:24:37] -[MMPerson dealloc] [第22行] 💕 MMPerson dealloc</span><br></pre></td></tr></table></figure>

<p>对于多层嵌套而言，在<code>pop</code>的时候总会释放到上次<code>push</code>的位置为止，也就是哨兵位置，多层<code>pool</code>其实就是插入多个哨兵对象而已，然后根据哨兵对象来进行释放。</p>
<p><strong>注意：如果将一个对象加入到多个pool中</strong>，那么对象内层pool执行pop操作的时候就会被release释放掉，那么当调用<code>rootRelease()</code>的时候就会报错，因为当前对象已经被释放了，那么也就是说对于添加到pool中的对象只能被释放一次（同一个对象不能反复<code>autorelease</code>）</p>
<h4 id="Autoreleasepool的应用场景"><a href="#Autoreleasepool的应用场景" class="headerlink" title="Autoreleasepool的应用场景"></a>Autoreleasepool的应用场景</h4><p>AppKit和UIkit通常都会在RunLoop每次事件循环迭代中创建并处理<code>@autoreleasepool</code>，因此通常我们不必自己创建<code>@autoreleasepool</code>，但有些情况需要我们创建<code>@autoreleasepool</code></p>
<blockquote>
<p>苹果给出了三种需要手动添加<code>@autoreleasepool</code>的场景：</p>
<ul>
<li><p>如果你编写的应用程序不是基于UI框架的，比如说命令行工具</p>
</li>
<li><p>如果你编写的循环中创建了大量的临时对象；</p>
<p>你可以在循环中使用<code>@autoreleasepool</code>在下一次迭代之前处理这些对象，在循环中使用<code>@autoreleasepool</code>有助于减少应用程序的最大内存占用</p>
</li>
<li><p>如果你创建了辅助线程</p>
<p>一旦线程开始执行，就必须创建自己的<code>@autoreleasepool</code>；否则，你的应用程序将存在内存泄露</p>
</li>
</ul>
</blockquote>
<p>举个🌰</p>
<p>for循环中创建大量临时对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)mm_circulateMemory &#123;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100000000; i ++) &#123;</span><br><span class="line">        NSString * str &#x3D; [NSString stringWithFormat:@&quot;no_AutoReleasePool&quot;];</span><br><span class="line">        NSString *tempstr &#x3D; str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Users/mikasa/Desktop/image_mark/image-20201026171701138.png" alt="image-20201026171701138" style="zoom:50%;" />

<p>for循环中使用<code>@autoreleasepool</code>处理临时对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (void)mm_circulateMemory_autorelease &#123;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100000000; i ++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSString * str &#x3D; [NSString stringWithFormat:@&quot;have_AutoReleasePool&quot;];</span><br><span class="line">            NSString *tempstr &#x3D; str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Users/mikasa/Desktop/image_mark/image-20201026172111999.png" alt="image-20201026172111999"></p>
<p>使用<code>@autoreleasepool</code>进行处理临时对象后，内存没有明显变化。</p>
<h4 id="线程私有数据（TSD）"><a href="#线程私有数据（TSD）" class="headerlink" title="线程私有数据（TSD）"></a>线程私有数据（TSD）</h4><p>​        线程私有数据（Thread-Specific Data 或 TSD）。</p>
<p>​        在单线程中，我们经常用到全局变量来实现多个函数间数据共享，然而在多线程环境中，由于数据空间是共享的，全局变量也为多个线程多共享。但有时应用程序需要“线程私有的全局变量，仅在单个线程有效，但是却可以跨多个函数访问”，POSIX线程库，听过维护一定的数据结构来解决这个问题，线程私有数据TSD</p>
<h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>​        首先创建允许所有线程访问的全局变量key，然后在任意一个线程中调用pthread_key_create接口创建所有线程有可见的线程特定数据的键值key，但是这个键值所指向的真实数据却是不同，它并不指向同一块内存，而是指向的属于自己数据，更改线程0的key中所指向的数据，并不会影响线程1key中所指向的数据。</p>
<p>​        各个子线程可以通过pthread_setspecific 和 get_specific接口使用这个key来获取和存储数据，每个线程的操作都在自己的私有线程数据中完成。</p>
<h5 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h5><p><strong>创建TSD</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">init <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span>(*destr_function)(<span class="keyword">void</span> *))</span></span></span><br></pre></td></tr></table></figure>

<p>一个进程被启动后，多个线程被创建，当其中一个线程调用函数<code>pthread_key_create</code>，TSD分配一项空间，并将其赋值为key，系统在key结构数据中找到第一个未使用的元素，将其索引返回给调用者。</p>
<p>如果destr_function不为空，在线程退出（pthread_exit()）时，将以key所关联的数据为参数调用<code>destr_function()</code>，以释放分配的缓冲区。</p>
<p>无论哪个线程调用pthread_key_create获取的tsd数据区都是所有线程可访问的，各个线程可根据需要存储不同的数据。</p>
<p><strong>注销TSD</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span></span><br></pre></td></tr></table></figure>

<p>函数<code>pthread_key_delete</code>并不会检查当前是否有线程正使用TSD，也不会调清理函数（destr_function），而只是将TSD释放以供下一次调用pthread_key_create使用。</p>
<p><strong>读写TSD</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthreat_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *pointer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span></span><br></pre></td></tr></table></figure>

<p>写入pthread_setspecific()时，将pointer的值（不是所指内容）与key相关联，而相应的读出函数则将与key相关联的数据读出来。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://woniuxiang.space/blog/post/lightime/多线程（pthreads）" target="_blank" rel="noopener">多线程（pthread）</a></p>
<p><a href="https://juejin.im/post/6844904094503567368#heading-21" target="_blank" rel="noopener">iOS - 聊聊 autorelease 和 @autoreleasepool</a></p>
<p><a href="https://juejin.im/post/6844903971405086734#heading-13" target="_blank" rel="noopener">Autorelease &amp; AutoreleasePool</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/08/28/ios-%E6%A3%80%E6%B5%8B%E6%97%A0%E7%94%A8%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/28/ios-%E6%A3%80%E6%B5%8B%E6%97%A0%E7%94%A8%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">ios 检测无用类、方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-28 15:13:18" itemprop="dateCreated datePublished" datetime="2020-08-28T15:13:18+08:00">2020-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-17 21:18:19" itemprop="dateModified" datetime="2020-09-17T21:18:19+08:00">2020-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/05/30/Http%E4%B8%8EHttps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Http%E4%B8%8EHttps/" class="post-title-link" itemprop="url">Http与Https</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-30 01:14:06" itemprop="dateCreated datePublished" datetime="2020-05-30T01:14:06+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-05 19:48:37" itemprop="dateModified" datetime="2020-06-05T19:48:37+08:00">2020-06-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h2><p>HTTP有什么问题？</p>
<ol>
<li>使用明文（没有加密）通信，内容可能会被窃听</li>
<li>不会验证通信双方的身份，通信方的身份可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能会被篡改</li>
</ol>
<p>由于HTTP在设计的时候都没有考虑到这些，所以基于HTTP的应用都可能存在安全问题</p>
<h4 id="数据没有加密"><a href="#数据没有加密" class="headerlink" title="数据没有加密"></a>数据没有加密</h4><p>基于TCP/IP的网络，网络各处都会存在被窃听的风险，如果用HTTP协议进行通信，HTTP本身没有加密的功能，所有无法做到对通信整体（使用HTTP协议通讯的请求和响应内容）进行加密，HTTP报文采用明文传输。</p>
<p>即使使用加密内容进行通信，也能被窃听到内容，只不过拿到的是密文，而且HTTP头部是没有加密的，头部信息也会导致信息不安全。</p>
<p>要解决HTTP的3的安全问题，第一步就是先进行加密通信，于是在传输层增加了一层SSL（Secure Sockets Layer安全套机接层）/TLS（Transport Layer Security安全层传输协议）来加密HTTP的通信内容</p>
<p>HTTPS并不是新的协议，而是HTTP先和SSL/TLS通信，再由SSL/TLS和TCP通信，也就是说HTTPS使用隧道进行通信。</p>
<h4 id="无法验证对方身份"><a href="#无法验证对方身份" class="headerlink" title="无法验证对方身份"></a>无法验证对方身份</h4><p>基于TCP的HTTP虽然可以保证数据能完整的传输给对方，但是无法验证对方的身份。HTTP也由于协议的灵活性，应用的非常广泛。通信双方无需验证身份，服务器只要接收到能识别的请求，就会返回一个响应，一个request就会有一个response。由于不确认对方，就会导致一些隐患：</p>
<ol>
<li>服务器无法验证请求来自于谁，是否是合法的客户端</li>
<li>客户端收到响应，无法验证是否来自合法的服务器</li>
<li>无法阻止海量请求下的Dos拒绝攻击（Denial of Service,拒绝服务攻击）</li>
</ol>
<h4 id="无法防止数据被篡改"><a href="#无法防止数据被篡改" class="headerlink" title="无法防止数据被篡改"></a>无法防止数据被篡改</h4><p>HTTP协议是无法保证数据的完整性的，这里的完整性值得是信息的准确度，若无法证明信息的完整行，也就是意味着无法判断信息的准确性。</p>
<p>客户端和服务端对于收到的请求和响应，都只能无条件的接受，HTTP也无妨知道请求或响应过程中数据是否被篡改了，例如中间人攻击（Main-in-the-Middle attack,MITM）</p>
<p>HTTP也有验证报文完整性的方法，但是不是很可靠。比如利用MD5和SHA-1等散列值校验的方法用来确认文件的数字签名（MD5和SHA-1低位数的已经不再安全，会遭到碰撞攻击）</p>
<p>在下载i服务的web网站也会提供PGP（Pertty Good Privacy,完美隐私）创建的数字签名及MD5算法生成的散列值。PGP用来证明创建文件的数字签名，MD5是由单向函数生成的散列值。在HTTP协议下，浏览器是无法知晓数据是否被篡改了，还是需要用户自己查看。如果PGP和MD5在传输钱就被篡改了，用户拿到以后验证发现是一致的，这种情况下也没法保证数据的完整正确性</p>
<p>跳过TLS，HTTPS不仅能保证密文传输，重要的是还可以验证对方身份，保证报文传输的完整性，完全解决了HTTP上的三大安全问题。</p>
<h2 id="部署HTTPS的好处"><a href="#部署HTTPS的好处" class="headerlink" title="部署HTTPS的好处"></a>部署HTTPS的好处</h2><h4 id="使用HTTP-2获得更高的性能"><a href="#使用HTTP-2获得更高的性能" class="headerlink" title="使用HTTP/2获得更高的性能"></a>使用HTTP/2获得更高的性能</h4><p>内容交付和网络托管服务提供商正在开始推广HTTP/2。在Velocity的一次会议上，Load Impact和Mozilla报告说，互联网用户可以通过HTTP/2优化比HTTP/1.1上的网站性能要好50-70%。但是想用HTTP/2的性能优势，必须先部署HTTPS，这个规定也是对HTTPS的一个推广。</p>
<h4 id="提高SEO排名"><a href="#提高SEO排名" class="headerlink" title="提高SEO排名"></a>提高SEO排名</h4><p>谷歌在2014年宣布，支持HTTPS的网站会有排名靠前的较大比重</p>
<h4 id="更好的推荐数据"><a href="#更好的推荐数据" class="headerlink" title="更好的推荐数据"></a>更好的推荐数据</h4><p>如果采用的谷歌的Analytics库，他目前是强制允许在HTTPS上的，如果还是使用HTTP，会犹豫Analytics不会获取HTTP网站的Referral信息而导致数据不准确</p>
<h4 id="更高的安全性"><a href="#更高的安全性" class="headerlink" title="更高的安全性"></a>更高的安全性</h4><p>主流浏览器都会针对HTTPS网站增加小绿锁标志，没有小绿锁的网站，给用户的第一印象不是很安全</p>
<h4 id="提高网站的信任和信誉"><a href="#提高网站的信任和信誉" class="headerlink" title="提高网站的信任和信誉"></a>提高网站的信任和信誉</h4><p>在Chrome62版本后，如果网页上有输入框，没有HTTPS的网页一律视为不安全</p>
<h4 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h4><p>在Chrome 50版本后，地理位置，音频视频接口必须要求运行在HTTPS上，目的是能保证数据传输安全</p>
<h4 id="iOS-ATS要求"><a href="#iOS-ATS要求" class="headerlink" title="iOS ATS要求"></a>iOS ATS要求</h4><p>苹果为了推广HTTPS，在WWDC2017上也宣布新的App必须要开启ATS（App Transport Security）安全特性</p>
<h2 id="HTTPS中的密码"><a href="#HTTPS中的密码" class="headerlink" title="HTTPS中的密码"></a>HTTPS中的密码</h2><h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><p>对称密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快</li>
<li>缺点：密钥容易被获取</li>
</ul>
<h4 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h4><p>公开密钥加密（Public-key Encryption）,也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送发获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥进行解密。</p>
<ul>
<li>优点：更为安全</li>
<li>缺点：运算速度慢</li>
</ul>
<h4 id="HTTPS采用的加密方式"><a href="#HTTPS采用的加密方式" class="headerlink" title="HTTPS采用的加密方式"></a>HTTPS采用的加密方式</h4><p>HTTPS采用混合的加密机制，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。</p>
<ul>
<li>客户端请求连接，服务端生成公钥和私钥</li>
<li>使用公开加密方式传输公钥，同时生成一个Session Key传输给客户端</li>
<li>客户端使用公钥对Session Key进行对称加密，传输给服务端</li>
<li>服务端通过私钥进行解密</li>
</ul>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>HTTPS通过使用证书来对通信双方进行认证</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务端双方都可信赖的第三方机构。服务器的运营人员向CA提出公开密钥申请，CA在判明提出申请者的身份后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将公开密钥放入公开证书后绑定在一起。</p>
<p>进行HTTPS通信时，服务器会将证书发送给客户端，客户端获取其中的公开密钥后，先进行验证，如果验证通过，就可以开始通信了。具体的证书内容，可查看<a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTPS-digital-certificate.md" target="_blank" rel="noopener">《随处可见的公钥证书》</a></p>
<p>使用openSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告信息。</p>
<h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><p>SSL/TLS提供内容摘要功能来验证完整性。</p>
<h2 id="HTTPS中的SSL-TLS协议"><a href="#HTTPS中的SSL-TLS协议" class="headerlink" title="HTTPS中的SSL/TLS协议"></a>HTTPS中的SSL/TLS协议</h2><table>
<thead>
<tr>
<th></th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>HTTP</td>
<td>HTTP</td>
</tr>
<tr>
<td>安全层</td>
<td></td>
<td>SSL/TLS</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP</td>
<td>TCP</td>
</tr>
<tr>
<td>网络层</td>
<td>IP</td>
<td>IP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>网络接口</td>
<td>网络接口</td>
</tr>
</tbody></table>
<p>能让HTTP安全的就是其中的安全层，也就是其背后的TLS协议。它源于九十年代中期在Netscape上开发称为安全套接字层（SSL）层协议，到20世纪90年代末，Netscape将SSL移交给IETF，IETF将其重命名为TLS，并从此成为该协议的管理者。许多人仍将web加密称作SSL，即使绝大多数服务已经切换为仅支持TLS。</p>
<p>SSL/TLS位于应用层和传输层TCP协议的中间，TLS粗略划分可以分为两层：</p>
<ul>
<li>靠近应用层的握手协议TLS Handshaking Protocol</li>
<li>靠近TCP的记录层协议TLS Record Protocol</li>
</ul>
<p>TLS握手协议可细分为5个子协议：</p>
<ul>
<li>Change_cipher_spec：密码切换协议</li>
<li>alert：警告协议</li>
<li>handshake：握手协议</li>
<li>Application_data：应用数据协议</li>
<li>Heartbeat：心跳协议</li>
</ul>
<img src="https://img.halfrost.com/Blog/ArticleImage/95_11_.png" alt="img" style="zoom:30%;" />

<h4 id="1、TLS记录层协议"><a href="#1、TLS记录层协议" class="headerlink" title="1、TLS记录层协议"></a>1、TLS记录层协议</h4><p>记录层将上层的信息库分段为TLSPlaintext记录，TLSPlaintext中包含2^14字节或更少子节块数据。根据底层ContentType的不同，消息的边界的处理方式不同，TLS1.3中的规则比TLS1.2中强制执行的规则更加严格。</p>
<p>握手消息可以合并为单个TLSPlaintext记录，或者在几个记录中分段，前提是：</p>
<ul>
<li>握手消息不得与其他记录类型交错。也就是说，如果握手消息被分为两个或多个记录，则他们之间不能有任务其他记录</li>
<li>握手消息绝不能跨越密钥更改，实现方必须验证密钥更改之前的所有消息是否与记录边界对其；如果没有，你们他们必须用“unexperted_message”alert消息终止连接。因为ClientHello，EndOfEarlyData,ServerHello,Finished和KeyUpdate消息可以在密钥更改之前立即发生，所以实现方必须将这些消息与记录边界对齐。</li>
</ul>
<p>实现方绝不能发生握手类型的零长度片段，即使这些片段包含填充</p>
<p>另外Alert消息禁止在记录之间进行分段，并且多条alert消息不得合并为单个TLSPlaintext记录。换句话说，具有alert类型的记录必须只包含一条消息。</p>
<p>应用数据消息包含对TLS不透明的数据。应用数据消息应该始终受到保护，可以发生应用数据的零长度片段，因为他们可能作为流量分析对策使用。应用数据片段可以拆分为多个记录，也可以合并为一个记录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ContentType type;</span><br><span class="line">  ProtocolVersion legacy_record_version;</span><br><span class="line">  uint16 length;</span><br><span class="line">  opaque fragment[TLSPlaintext.length];</span><br><span class="line">&#125; TLSPlaintext;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>type</p>
<p>用户处理TLS握手层的高级协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">          invalid(0),</span><br><span class="line">          change_cipher_spec(20),</span><br><span class="line">          alert(21),</span><br><span class="line">          handshake(22),</span><br><span class="line">          application_data(23),</span><br><span class="line">          heartbeat(24),  &#x2F;* RFC 6520 *&#x2F;</span><br><span class="line">          (255)</span><br><span class="line">      &#125; ContentType;</span><br></pre></td></tr></table></figure>

<p>ContentType是对握手协议的封装，消息头类型和握手层子协议编号的对应关系如下：</p>
<table>
<thead>
<tr>
<th>消息头类型</th>
<th>ContentType</th>
</tr>
</thead>
<tbody><tr>
<td>invalid</td>
<td>0x00</td>
</tr>
<tr>
<td>change_cipher_spec</td>
<td>0x14</td>
</tr>
<tr>
<td>alert</td>
<td>0x15</td>
</tr>
<tr>
<td>handshake</td>
<td>0x16</td>
</tr>
<tr>
<td>application_data</td>
<td>0x17</td>
</tr>
<tr>
<td>heartbeat</td>
<td>0x18</td>
</tr>
</tbody></table>
</li>
<li><p>legacy_record_version</p>
<p>除初始化ClientHello之外的TLS1.3实现生成的所有记录（即，在HelloRetryRequest之后未生成的记录），必须将其设置为0x0303,其中处于兼容性目的，他也可以是0x0301。该字段在TLS1.3中已经弃用，必须忽略它。在某些情况下，以前版本的TLS将在此字段中使用其他值。</p>
<table>
<thead>
<tr>
<th>协议版本</th>
<th>Version</th>
</tr>
</thead>
<tbody><tr>
<td>TLS1.3</td>
<td>0x0304</td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>0x0303</td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>0x0302</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>0x0301</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>0x0300</td>
</tr>
</tbody></table>
</li>
<li><p>Length</p>
<p>TLSPlaintext.frament的长度（以字节为单位）。长度不超过2^14字节。接收超过此长度的记录的端点必须使用”record_overflow”alert 消息终止连接</p>
</li>
<li><p>fragment</p>
<p>正在传输的数据，此字段的值是透明的，它被视为一个独立的块，由类型字段指定的更高级别协议处理</p>
</li>
</ul>
<p>当尚未使用密码保护时，TLSPlaintext结构是直接写入传输线路中。一旦记录保护开始，TLSPlaintext记录将受到密码保护。请注意，应用数据不得写入未受保护的连接中。所以在握手成功之前，是不能发送应用数据的。</p>
<p>TLS记录层协议在整个TLS协议中的定位如下：</p>
<ul>
<li>封装处理TLS上层（握手层）中的平行子协议（TLS1.3中是5个子协议，TLS1.2及更老的版本是4个子协议），加上消息头，打包往下传递给TCP处理</li>
<li>对应用数据进行密码保护，对其他子协议只是简单封装（不加密）</li>
</ul>
<h4 id="2、密码切换协议（Change-cipher-spec）"><a href="#2、密码切换协议（Change-cipher-spec）" class="headerlink" title="2、密码切换协议（Change_cipher_spec）"></a>2、密码切换协议（Change_cipher_spec）</h4><p>Change_cipher_spec协议，是TLS记录层对应用是否进行加密的分割线，客户端或服务端一旦收到对端发来的CSS协议，就表明接下来传输数据过程中可以对应用数据协议进行加密了。</p>
<p>TLS记录层在处理上层5个协议（密码切换协议、警告协议、握手协议、心跳协议、应用数据协议）的时候，TLS不同版本对不同协议的加密情况不同，具体情况如下：</p>
<table>
<thead>
<tr>
<th align="left">协议版本</th>
<th>密码切换协议</th>
<th>警告协议</th>
<th>握手协议</th>
<th>心跳协议</th>
<th>应用数据协议</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TLS 1.3</td>
<td>无</td>
<td>根据连接状态不同进行加密，即一部分会密码</td>
<td>一部分加密</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td align="left">TLS 1.2</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>无</td>
<td>✅</td>
</tr>
</tbody></table>
<p>协议数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123;change_cipher_spec(<span class="number">1</span>), (<span class="number">255</span>)&#125; type</span><br><span class="line">&#125; ChangeCipherSpec</span><br></pre></td></tr></table></figure>

<h4 id="3、警告协议（alert）"><a href="#3、警告协议（alert）" class="headerlink" title="3、警告协议（alert）"></a>3、警告协议（alert）</h4><p>TLS提供alert内容类型用来表示关闭信息和错误。与其他信息一样，alert消息也会根据当前连接状态进行加密。在TLS 1.3中，错误的严重性隐含在正在发送的警报类型中，并且可以安全地忽略“level”字段。“close_notify”alert用户表示连接从一个方向开始有序的关闭。收到这样的警报后，TLS实现方应该表明程序的数据结束。</p>
<p>收到错误警告后，TLS实现方应该向应用程序表示出现了错误，并且不允许在连接上发送或接收任何其他数据。</p>
<p>协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum&#123;warning(1),fatal(2), (255)&#125; AlertLevel;</span><br><span class="line">struct &#123;</span><br><span class="line">	AlertLevel level;</span><br><span class="line">	AlertDescription description;</span><br><span class="line">&#125;Alert;</span><br></pre></td></tr></table></figure>

<p>TLS 1.3和TLS 1.2在这个协议上的改动很小，只是新增了几个枚举类型。</p>
<p>TLS 1.2的所有警告信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	close_notify(<span class="number">0</span>),</span><br><span class="line">	unexpected_message(<span class="number">10</span>),</span><br><span class="line">	bad_record_mac(<span class="number">20</span>),</span><br><span class="line">	decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">	record_overflow(<span class="number">22</span>),</span><br><span class="line">	decompression_failure(<span class="number">30</span>),</span><br><span class="line">	handshake_failure(<span class="number">40</span>),</span><br><span class="line">	no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">	bad_certificate(<span class="number">42</span>),</span><br><span class="line">	unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">	certificate_revoked(<span class="number">44</span>),</span><br><span class="line">	certificate_unknow(<span class="number">46</span>),</span><br><span class="line">	illegal_paramter(<span class="number">47</span>),</span><br><span class="line">	unknow_ca(<span class="number">48</span>),</span><br><span class="line">	access_denied(<span class="number">49</span>),</span><br><span class="line">	decode_error(<span class="number">50</span>),</span><br><span class="line">	decrypt_error(<span class="number">51</span>),</span><br><span class="line">	export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">	protocol_version(<span class="number">70</span>),</span><br><span class="line">	internal_error(<span class="number">80</span>),</span><br><span class="line">	user_canceled(<span class="number">90</span>),</span><br><span class="line">	no_renegotiation(<span class="number">100</span>),</span><br><span class="line">	unsupported_extension(<span class="number">110</span>),</span><br><span class="line">	(<span class="number">255</span>)</span><br><span class="line">&#125;AlertDescription;</span><br></pre></td></tr></table></figure>

<p>TLS 1.3 在TLS 1.2基础上新增了9个警告描述信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inapporopriate_fallback(<span class="number">86</span>),</span><br><span class="line">missing_extension(<span class="number">109</span>),</span><br><span class="line">certificate_unobtainable_RESERVED(<span class="number">111</span>),</span><br><span class="line">bad_certificate_status_response(<span class="number">113</span>),</span><br><span class="line">bad_certificate_hash_value_RESERVED(<span class="number">114</span>),</span><br><span class="line">unkonwn_psk_identity(<span class="number">115</span>),</span><br><span class="line">centificate_required(<span class="number">116</span>),</span><br><span class="line">no_application_protocol(<span class="number">120</span>),</span><br></pre></td></tr></table></figure>

<h4 id="4、握手协议（handshake）"><a href="#4、握手协议（handshake）" class="headerlink" title="4、握手协议（handshake）"></a>4、握手协议（handshake）</h4><p>握手协议是整个TLS协议簇中最核心的协议，HTTPS能保证安全也是因为它的功劳。</p>
<p>握手协议由多个子消息构成，服务端和客户端第一次完成握手需要2-RTT。</p>
<p>握手协议的目的是为了双方协商出密码块，这个密码块会交给TLS记录层进行密钥加密，也就是说握手协议达成的“共识”（密码块）就是整个TLS和HTTPS安全的基础。</p>
<p>握手协议在TLS1.2 和 TLS1.3中发生了很大的变化。TLS1.3的0-RTT是一个全新的概念。两个版本在密钥协商上，密码套件选择上都有很大的不同。</p>
<p>TLS 1.2协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	hello_request(0),</span><br><span class="line">	client_hello(1),</span><br><span class="line">	server_hello(2),</span><br><span class="line">	certificate(11),</span><br><span class="line">	server_key_exchange(12),</span><br><span class="line">	certificate_request(13),</span><br><span class="line">	server_hello_done(14),</span><br><span class="line">	certificate_verify(15),</span><br><span class="line">	client_key_exchange(16),</span><br><span class="line">	finished(20),</span><br><span class="line">	(255)</span><br><span class="line">&#125;HandshakeType;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">	HandshakeType msg_type;</span><br><span class="line">	unit24 length;</span><br><span class="line">	select(HandshakeType) &#123;</span><br><span class="line">		case hello_request:	HelloRequest;</span><br><span class="line">		case client_hello:	ClientHello;</span><br><span class="line">		case server_hello:	ServerHello;</span><br><span class="line">		case certificate:		Certificate;</span><br><span class="line">		case server_key_exchange:	ServerKeyExchange;</span><br><span class="line">		case certificate_request:	CertifiCateRequest;</span><br><span class="line">		case server_hello_done:		ServerHelloDone;</span><br><span class="line">		case certificate_request:	CertificateRequest;</span><br><span class="line">		case client_key_exchange:	ClientKeyExchange;</span><br><span class="line">		case finished:						Finished;</span><br><span class="line">	&#125; body;</span><br><span class="line">&#125;Handshake;</span><br></pre></td></tr></table></figure>

<p>TSL 1.3协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	hello_request_RESERVERD(0);</span><br><span class="line">	client_hello(1),</span><br><span class="line">	server_hello(2),</span><br><span class="line">	hello_verify_request_RESERVED(3),</span><br><span class="line">	new_session_ticket(4),</span><br><span class="line">	end_of_early_data(5),</span><br><span class="line">	hello_retry_request_RESERVED(6),</span><br><span class="line">	encrypted_extensions(8),</span><br><span class="line">	certificate(11),</span><br><span class="line">	server_key_exchange_RESERVED(14),</span><br><span class="line">	certifycate_verify(15),</span><br><span class="line">	client_key_exchange_RESERVED(16),</span><br><span class="line">	finished(20),</span><br><span class="line">	certificate_url_RESERVED(21),</span><br><span class="line">	ceritificate_status_RESERVED(22),</span><br><span class="line">	supplemental_data_RESERVED(23),</span><br><span class="line">	key_update(24),</span><br><span class="line">	message_hash(254),</span><br><span class="line">	(255)</span><br><span class="line">&#125;HandshakeType;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">	HandshakeType msg_type;</span><br><span class="line">	unit24 length;</span><br><span class="line">	select(HandshakeType) &#123;</span><br><span class="line">		case client_hello:	ClientHello;</span><br><span class="line">    case server_hello:	ServerHello;</span><br><span class="line">    case end_of_early_data:	EndOfEarlyData;</span><br><span class="line">    case encrypted_extensions:	EncryptedExtensions;</span><br><span class="line">    case certificate_request:		CertificateRequest;</span><br><span class="line">    case certificate:						Certificate;</span><br><span class="line">    case certificate_verify:		CertificateVerify;</span><br><span class="line">    case finished:							Finished;</span><br><span class="line">    case new_session_ticket:		NewSessionTicket;</span><br><span class="line">    case key_update:						KeyUpdate</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、应用数据协议（application-data）"><a href="#5、应用数据协议（application-data）" class="headerlink" title="5、应用数据协议（application_data）"></a>5、应用数据协议（application_data）</h4><p>应用数据洗衣就是TLS上层的各种协议，TLS主要保护的数据就是应用数据协议的数据。</p>
<p>TLS记录层灰根据加密模式不同在应用数据的末尾加上MAC校验数据。</p>
<h4 id="6、TLS心跳协议（heartbeat）"><a href="#6、TLS心跳协议（heartbeat）" class="headerlink" title="6、TLS心跳协议（heartbeat）"></a>6、TLS心跳协议（heartbeat）</h4><p>TLS 1.3新增协议。</p>
<p>协议数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/05/16/RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/16/RunLoop/" class="post-title-link" itemprop="url">RunLoop</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-16 00:45:42" itemprop="dateCreated datePublished" datetime="2020-05-16T00:45:42+08:00">2020-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-18 15:25:36" itemprop="dateModified" datetime="2020-05-18T15:25:36+08:00">2020-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/05/13/load%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/13/load%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">+ Load vs + initialize</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-13 15:08:05" itemprop="dateCreated datePublished" datetime="2020-05-13T15:08:05+08:00">2020-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-14 17:29:55" itemprop="dateModified" datetime="2020-05-14T17:29:55+08:00">2020-05-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Load-vs-initialize"><a href="#Load-vs-initialize" class="headerlink" title="+ Load vs + initialize"></a><code>+ Load</code> vs <code>+ initialize</code></h3><h3 id="load"><a href="#load" class="headerlink" title="+ load"></a><code>+ load</code></h3><ul>
<li>load`方法的调用顺序</li>
</ul>
<p>首先通过<code>+ load</code>方法的调用栈，分析一下是如何被调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; insert code here...</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">@implementation MMPerson</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;MMPerson&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation MMPerson (BB)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;BB&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end </span><br><span class="line">  </span><br><span class="line">@implementation MMPerson (AA)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;AA&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>文件编译顺序</p>
<img src="/Users/mikasa/Library/Application Support/typora-user-images/image-20200513152750308.png" alt="image-20200513152717723" style="zoom:50%;" />

<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-05-13 15:18:04.667822+0800 Load_initialize[66907:805301] MMPerson</span><br><span class="line">2020-05-13 15:18:09.267336+0800 Load_initialize[66907:805301] AA</span><br><span class="line">2020-05-13 15:18:09.267430+0800 Load_initialize[66907:805301] BB</span><br><span class="line">2020-05-13 15:18:09.267577+0800 Load_initialize[66907:805301] Hello, World!</span><br></pre></td></tr></table></figure>

<p>虽然在主函数中什么方法都没有调用，但是运行之后仍调用了MMPerson中的<code>+ load</code>方法，并且<code>+load</code>方法的调用在<code>main</code>函数之前</p>
<p>断点调试</p>
<p>在<code>MMPerson load</code>方法内加上断点，获取当前代码执行</p>
<p>![image-20200513154759631](/Users/mikasa/Library/Application Support/typora-user-images/image-20200513154759631.png)</p>
<h4 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h4><p><code>load_images</code>方法在objc-os.mm文件的<code>_objc_init</code>中找到调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br></pre></td></tr></table></figure>

<p>dyld是the dynamic link editor的缩写，它是苹果的动态链接器，在系统内核做好程序准备工作之后，剩下的交由dyld负责</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized &#x3D; false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h4><p>每当有新的镜像加载之后<code>_objc_init</code>，都会执行<code>_dyld_objc_notify_register</code>调用<code>load_images</code>方法，并传入最新镜像的<code>mach_header</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h4><p>调用<code>prepare_load_methods</code>查找当前类、父类、分类中的<code>+ load</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist &#x3D; </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist &#x3D; _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat &#x3D; categorylist[i];</span><br><span class="line">        Class cls &#x3D; remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  &#x2F;&#x2F; category for ignored weak-linked class</span><br><span class="line">        if (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(&quot;Swift class extensions and categories on Swift &quot;</span><br><span class="line">                        &quot;classes are not allowed to have +load methods&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="schedule-class-load"><a href="#schedule-class-load" class="headerlink" title="schedule_class_load"></a>schedule_class_load</h4><p><code>schedule_class_load</code>会获取当前类中实现了+ load方法的类，优先递归获取父类的load方法，保证父类调用load方法在子类之前，并将查找到的实现了 <code>+ load</code>方法的类存入loadable_classes列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会读取当前类的分类列表，按照编译顺序读取，依次获取分类中<code>+ load</code>方法的实现imp将其存入loadable_classes列表中</p>
<h4 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h4><p>call_load_methods方法会从待加载的列表loadable_classes中找到cls，然后找到imp并执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading &#x3D; NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading &#x3D; YES;</span><br><span class="line"></span><br><span class="line">    void *pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. Repeatedly call class +loads until there aren&#39;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. Call category +loads ONCE</span><br><span class="line">        more_categories &#x3D; call_category_loads();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading &#x3D; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、准备调用当前中loadable_classes中所有类，并执行+ load</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class="line">    int used &#x3D; loadable_classes_used;</span><br><span class="line">    loadable_classes &#x3D; nil;</span><br><span class="line">    loadable_classes_allocated &#x3D; 0;</span><br><span class="line">    loadable_classes_used &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls &#x3D; classes[i].cls;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、调用一次call_category_loads加载分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">static bool call_category_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, shift;</span><br><span class="line">    bool new_categories_added &#x3D; NO;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取当前可以加载的分类列表</span><br><span class="line">    struct loadable_category *cats &#x3D; loadable_categories;</span><br><span class="line">    int used &#x3D; loadable_categories_used;</span><br><span class="line">    int allocated &#x3D; loadable_categories_allocated;</span><br><span class="line">    loadable_categories &#x3D; nil;</span><br><span class="line">    loadable_categories_allocated &#x3D; 0;</span><br><span class="line">    loadable_categories_used &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat &#x3D; cats[i].cat;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (!cat) continue;</span><br><span class="line"></span><br><span class="line">        cls &#x3D; _category_getClass(cat);</span><br><span class="line">        &#x2F;&#x2F; 如果当前类是可加载的&#96;cls&#96; &amp;&amp; &#96;cls-&gt;isLoadable()&#96;就会调用分类</span><br><span class="line">        if (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            if (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat &#x3D; nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将所有加载过的分类从loadable_categories列表中移除</span><br><span class="line">    shift &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        if (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] &#x3D; cats[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -&#x3D; shift;</span><br><span class="line">    </span><br><span class="line">		&#x2F;&#x2F; 为loadable_categories重新分类内存，并重新设置他的值</span><br><span class="line">    &#x2F;&#x2F; Copy any new +load candidates from the new list to the detached list.</span><br><span class="line">    new_categories_added &#x3D; (loadable_categories_used &gt; 0);</span><br><span class="line">    for (i &#x3D; 0; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        if (used &#x3D;&#x3D; allocated) &#123;</span><br><span class="line">            allocated &#x3D; allocated*2 + 16;</span><br><span class="line">            cats &#x3D; (struct loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  sizeof(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] &#x3D; loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Destroy the new list.</span><br><span class="line">    if (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Reattach the (now augmented) detached list. </span><br><span class="line">    &#x2F;&#x2F; But if there&#39;s nothing left to load, destroy the list.</span><br><span class="line">    if (used) &#123;</span><br><span class="line">        loadable_categories &#x3D; cats;</span><br><span class="line">        loadable_categories_used &#x3D; used;</span><br><span class="line">        loadable_categories_allocated &#x3D; allocated;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (cats) free(cats);</span><br><span class="line">        loadable_categories &#x3D; nil;</span><br><span class="line">        loadable_categories_used &#x3D; 0;</span><br><span class="line">        loadable_categories_allocated &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        if (loadable_categories_used !&#x3D; 0) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取当前可以加载的分类列表</li>
<li>如果当前类是可记载的cls &amp;&amp; cls-&gt;isLoadable 就会调用分类</li>
<li>将所有加载过的分类从loadable_categories列表中移除</li>
<li>为loadable_categories重新分类内存，并重新设置它的值</li>
</ol>
<h3 id="load的应用"><a href="#load的应用" class="headerlink" title="load的应用"></a>load的应用</h3><p>load方法会在main函数之前调用，并且只调用一次，如果类和分类中都实现了这个方法，他都会调用，不像其他分类方法会被覆盖，这也使得+ load成为<strong>Swizzling Method</strong>绝佳方法</p>
<h3 id="initialize"><a href="#initialize" class="headerlink" title="+ initialize"></a><code>+ initialize</code></h3><p>+initialize方法是在类或者子类收到第一条消息之前被调用，这里的消息包括类方法、实例方法的调用，也就是说initialize方法是以懒加载的方式调用的，如果程序一直没有给类发送消息或者调用方法，initialize方法将一直不会被调用，这样做可以节省系统资源、避免浪费</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">    if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, class_initialize will send +initialize and </span><br><span class="line">        &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给某个类发送消息时，runtime会调用这个函数在类中查找相应方法的实现或进行消息转发。上述代码可以看出，当类没有进行初始化时，会调用_class_initialize进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  *  @brief   向任意未初始化的类发送 +initialize 消息。强制先初始化父类</span><br><span class="line">  *&#x2F;</span><br><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 父类</span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    &#x2F;&#x2F; See note about deadlock above.</span><br><span class="line">    &#x2F;&#x2F; 获取父类</span><br><span class="line">    supercls &#x3D; cls-&gt;superclass;</span><br><span class="line">    &#x2F;&#x2F; 父类存在 &amp;&amp; 父类还没有执行 initialized 方法</span><br><span class="line">    &#x2F;&#x2F; 有时候父类的 initialize 方法会被调用多次，这是由于当子类没有实现 initialize 方法时，会先调用父类的 initialize 方法（第一次），然后再调用自己的 initialize 方法，由于是通过 obj_msgSend 消息机制调用，通过 isa 找到类对象，如果没有则去父类中查找，找到再调用（第二次）</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归调用</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        &#x2F;&#x2F; We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Record that we&#39;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (MultithreadedForkChild) &#123;</span><br><span class="line">            &#x2F;&#x2F; LOL JK we don&#39;t really call +initialize methods after fork().</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Send the +initialize message.</span><br><span class="line">        &#x2F;&#x2F; Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        &#x2F;&#x2F; this class doesn&#39;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</span><br><span class="line">                         pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Exceptions: A +initialize call that throws an exception </span><br><span class="line">        &#x2F;&#x2F; is deemed to be a complete and successful +initialize.</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span><br><span class="line">        &#x2F;&#x2F; bootstrapping problem of this versus CF&#39;s call to</span><br><span class="line">        &#x2F;&#x2F; objc_exception_set_functions().</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 +initialize 消息</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</span><br><span class="line">                             &quot;threw an exception&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Done initializing.</span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码对类进行递归调用，确保父类优于子类初始化，标记当前类为正在进行初始化RW_INITIALIZING</p>
<h4 id="callInitialize"><a href="#callInitialize" class="headerlink" title="callInitialize"></a>callInitialize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>callInitialize使用objc_msgSend的方法对<code>+ initialize</code>进行调用，也就是说<code>+ initialize</code>方法的调用方式和普通方法的是一致的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface MMStudent : MMPerson</span><br><span class="line">@end</span><br><span class="line">@interface MMTeacher : MMPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ol>
<li><p>子类没有实现，继承自父类的实现会被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMPerson initialize</span><br><span class="line">MMPerson initialize</span><br><span class="line">MMTeacher initialize</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类有实现<code>+ initialize</code>，会先调用父类的<code>+ initialize</code>，再调用子类<code>+ initialize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMPerson initialize</span><br><span class="line">MMStudent initialize</span><br><span class="line">MMTeacher initialize</span><br></pre></td></tr></table></figure>
</li>
<li><p>分类如果实现了<code>+ initialize</code>，会对这个类的<code>+ initialize</code>进行覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AA-initialize</span><br><span class="line">MMStudent initialize</span><br><span class="line">MMTeacher initialize</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>因此，一个子类如果没有实现<code>+ initialize</code>方法，父类的<code>+ initialize</code>可能会被执行多次，为了避免代码的执行不是我们想要了，可以进行类判断</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>+ load</code>和<code>+ initialize</code></p>
<table>
<thead>
<tr>
<th></th>
<th>+ load</th>
<th>+ initialize</th>
</tr>
</thead>
<tbody><tr>
<td>调用时机</td>
<td>加载镜像时，main函数执行之前</td>
<td>收到方法调用（实例方法或者对象方法），否则也可能永远也不会调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类 &gt; 子类 &gt; 分类，编译顺序靠前的分类会被优先调用</td>
<td>父类 &gt; 子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>系统调用一次，手动调用多次，如果是父类，子类没有实现的情况下，会被多次调用</td>
</tr>
<tr>
<td>是否需要显示调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中实现</td>
<td>类和分类都会执行</td>
<td>分类会覆盖执行</td>
</tr>
</tbody></table>
<p>Q：<strong><code>load</code> 方法是如何被调用的？</strong></p>
<p>A：当 Objective-C 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入<em>运行时</em>的时候，进行回调。执行 <code>load_images</code> 将所有包含 <code>load</code> 方法的文件加入列表 <code>loadable_classes</code> ，然后从这个列表中找到对应的 <code>load</code> 方法的实现，调用 <code>load</code> 方法。</p>
<p>Q：<code>load</code>方法的调用顺序</p>
<p>A：main方法执行之前，父类优于子类，子类优于分类，分类取决于编译顺序</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/17/Cocoapods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/Cocoapods/" class="post-title-link" itemprop="url">Cocoapods</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-17 21:13:05" itemprop="dateCreated datePublished" datetime="2020-03-17T21:13:05+08:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-24 11:02:19" itemprop="dateModified" datetime="2020-07-24T11:02:19+08:00">2020-07-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Cocoapods升级"><a href="#Cocoapods升级" class="headerlink" title="Cocoapods升级"></a>Cocoapods升级</h2><h3 id="升级Cocoapods到最新版本"><a href="#升级Cocoapods到最新版本" class="headerlink" title="升级Cocoapods到最新版本"></a>升级Cocoapods到最新版本</h3><p>1、先切换gem源</p>
<p>gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></p>
<p>gem source -a <a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a></p>
<p>查看是否切换成功</p>
<p>gem source -l</p>
<p>打印出<strong>* CURRENT SOURCES *</strong></p>
<p>​      <a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a></p>
<p>就说明切换成功，如果还是官方的源, 请手动重启电脑尝试</p>
<p>2、接下来就可以开始升级了Cocoapods了</p>
<p>sudo gem install -n /usr/local/bin cocoapods –pre</p>
<p>3、然后敲下</p>
<p>pod –version</p>
<p>出现</p>
<p>1.2.0.beta.1</p>
<p>恭喜你, 安装成功</p>
<p>4、剩下的就是设置pod仓库了</p>
<p>pod setup</p>
<p>至此, 已经升级到Cocoapods1.1.1了, 可以愉快的把玩Swift3.0的一些三方库了</p>
<h3 id="升级Cocoapods到指定版本"><a href="#升级Cocoapods到指定版本" class="headerlink" title="升级Cocoapods到指定版本"></a>升级Cocoapods到指定版本</h3><p>a、在终端输入：sudo gem uninstall cocoapods输出下面</p>
<p>Select gem to uninstall:</p>
<p>\1. cocoapods-1.1.0.rc.2</p>
<p>\2. cocoapods-1.2.0.beta.1</p>
<p>\3. All versions</p>
<p>&gt;‘在此处输入要删除的版本，如：2’会输出下面</p>
<p>Successfully uninstalled cocoapods-1.1.1</p>
<p>b、在终端输入：sudo gem install cocoapods -v 1.1.1</p>
<p>输出：Fetching: cocoapods-1.1.1.gem (100%)</p>
<p>ERROR: While executing gem … (Errno::EPERM)</p>
<p>Operation not permitted - /usr/bin/pod</p>
<p>c、上面的方法不行，那咱们就换一种输入：sudo gem install -n /usr/local/bin cocoapods -v 1.1.1</p>
<p>输出：Successfully installed cocoapods-1.1.1</p>
<p>Parsing documentation for cocoapods-1.1.1</p>
<p>Installing ri documentation for cocoapods-1.1.1</p>
<p>1 gem installed</p>
<p>d、输入pod –version查看一下版本号</p>
<p>输出：1.1.1</p>
<p>成功解决ERROR: While executing gem … (Errno::EPERM) Operation not permitted - /usr/bin/pod问题，就可以使用1.1.1版本了</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="执行-pod-install-出现-“Failed-to-connect-to-github-com-port-443-Operation-timed-out”解决方案"><a href="#执行-pod-install-出现-“Failed-to-connect-to-github-com-port-443-Operation-timed-out”解决方案" class="headerlink" title="执行 pod install 出现 “Failed to connect to github.com port 443: Operation timed out”解决方案"></a>执行 pod install 出现 “Failed to connect to github.com port 443: Operation timed out”解决方案</h3><p>升级Cocoapods到1.9.0后执行pod install出现以下错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[!] Error installing Bugly</span><br><span class="line">[!] /usr/bin/curl -f -L -o /var/folders/2d/klrwscg57tsb6t7qpsc18fpm0000gn/T/d20200317-99220-1t7nt4g/file.zip https://raw.githubusercontent.com/BuglyDevTeam/Bugly-iOS/master/release/Bugly-2.5.2.zip --create-dirs --netrc-optional --retry 2</span><br><span class="line"></span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0</span><br><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>ping gitHub.com</code>出现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PING github.com (52.74.223.119): 56 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br></pre></td></tr></table></figure>

<p>一直处于超时状态，丢包率100%，但是网络没什么问题</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p>打开终端，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /private/etc/hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>将如下IP-域名映射信息复制到最后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">151.101.184.133 assets-cdn.github.com</span><br><span class="line">151.101.184.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.112.133 avatars1.githubusercontent.com</span><br><span class="line">199.232.4.133  raw.githubusercontent.com</span><br><span class="line">13.229.188.59 github.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次 ping github.com</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PING github.com (192.30.253.112): 56 data bytes</span><br><span class="line">64 bytes from 192.30.253.112: icmp_seq=0 ttl=48 time=308.088 ms</span><br><span class="line">64 bytes from 192.30.253.112: icmp_seq=1 ttl=48 time=302.332 ms</span><br><span class="line">64 bytes from 192.30.253.112: icmp_seq=2 ttl=48 time=301.365 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 pod install,顺利安装</p>
</li>
</ol>
<h3 id="pod-install时CDN-trunk-URL-couldn’t-be-downloaded-https-raw-githubusercontent-com-CocoaPods-Specs-master-Specs"><a href="#pod-install时CDN-trunk-URL-couldn’t-be-downloaded-https-raw-githubusercontent-com-CocoaPods-Specs-master-Specs" class="headerlink" title="pod install时CDN: trunk URL couldn’t be downloaded: https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/"></a>pod install时CDN: trunk URL couldn’t be downloaded: <a href="https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/" target="_blank" rel="noopener">https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/</a></h3><p>执行pod install一直出现 “CDN: trunk URL couldn’t be downloaded: <a href="https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/0/f/b/MJRefresh/3.4.3/MJRefresh.podspec.json" target="_blank" rel="noopener">https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/0/f/b/MJRefresh/3.4.3/MJRefresh.podspec.json</a> Response: Couldn’t connect to server”</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1.不替换cdn源：</p>
<p>步骤：1.终端执行sudo vim /private/etc/hosts</p>
<p>　　　2.在hosts文件中添加199.232.4.133  raw.githubusercontent.com的映射，重新执行pod install</p>
<p>2.用source ‘<a href="https://github.com/CocoaPods/Specs.git&#39;替换到cdn源" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git&#39;替换到cdn源</a></p>
<p>步骤：1.在podfile里面添加source ‘<a href="https://github.com/CocoaPods/Specs.git&#39;" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git&#39;</a></p>
<p>　　　2.终端下执行 pod repo remove trunk来移除trunk，重新pod install</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>进入 vi ~/.ssh/known_hosts，把  git.wanmeizhensuo.com 对应的那一行删除掉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/12/Objective-C-Runtime%E2%80%94%E2%80%94objc-msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/Objective-C-Runtime%E2%80%94%E2%80%94objc-msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/" class="post-title-link" itemprop="url">Objective-C Runtime——objc_msgSend消息发送和转发</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 22:45:43" itemprop="dateCreated datePublished" datetime="2020-03-12T22:45:43+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-06 15:43:08" itemprop="dateModified" datetime="2020-05-06T15:43:08+08:00">2020-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Objective-C作为基于Runtime的语言，它有着非常强大的动态特性，可以在运行期间自省、进行方法调剂、为类添加属性、方法、修改消息转发链路，在代码运行期间可以通过Runtime修改Objective-C层的一切类、属性、方法。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在很多语言中，比如C，调用一个方法就是跳到内存中的某一个点并开始执行一段代码。没有任何的动态的特性，因为这在编译时就决定好了，而在Object-C中，<code>[person run]</code>并不会立即执行run这个方法的代码，它在运行时给person发送一条run的消息，这个消息，也许会由person来处理，也许会被转发给另外一个对象，或者不予理睬假装没有收到这个消息。多条不同的消息也可以对应同一个方法的实现。</p>
<p>需要提前获知的信息：</p>
<ol>
<li>在Object-C中“方法调用”其实应该叫做“消息传递”</li>
<li><code>[person run]</code>会被翻译为objc_msgSend(person,@selector(run))</li>
<li>在消息的响应链路中可能会调用 <code>- resolveInstanceMethod:</code>或者<code>- forwardInvocation:</code>等方法</li>
</ol>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Sends a message with a simple return value to an instance of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param self A pointer to the instance of the class that is to receive the message.</span><br><span class="line"> * @param op The selector of the method that handles the message.</span><br><span class="line"> * @param ... </span><br><span class="line"> *   A variable argument list containing the arguments to the method.</span><br><span class="line"> * </span><br><span class="line"> * @return The return value of the method.</span><br><span class="line"> * </span><br><span class="line"> * @note When it encounters a method call, the compiler generates a call to one of the</span><br><span class="line"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</span><br><span class="line"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; </span><br><span class="line"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</span><br><span class="line"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</span><br><span class="line"> *&#x2F;</span><br><span class="line">objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure>

<p>当编译器遇到一个方法调用时，它会将方法的调用翻译成一下函数中的一个<code>objc_msgSend</code> <code>objc_msgSend_stret</code> <code>objc_msgSendSuper</code> <code>objc_msgSendSuper_stret</code>，发送给对象的父类的消息会使用会使用<code>objc_msgSendSuper</code>，有数据结构作为返回值的方法会调用<code>objc_msgSendSuper_stret</code> 或者<code>objc_msgSend_stret</code>，其他消息都是使用<code>objc_msgSend</code>发送</p>
<p><code>objc_msgSend</code>有两个参数，一个是对象结构成员中的receiver，一个是SEL</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents a method selector.</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>

<p>要传递的消息都会通过@selector()转换成<code>objc_msgSend</code>的一个参数传递进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person run] ——&gt; objc_msgSend(person, @selector(run))</span><br></pre></td></tr></table></figure>

<p>objc_selector是一个映射到方法的C字符串，需要注意的是：</p>
<ol>
<li>使用selector()生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了，也就是说向不同的类发送相同的消息时，生成的选择子是一样的，选择子只与方法名相关，即使方法相同参数变量类型不同也会导致他们具有相同的选择子。这也是OC不支持重栽的原因</li>
<li>Objective-C为我们维护了一个巨大的选择子表</li>
<li>在使用@selector()时，会从这个选择子表中根据选择子的名称查找对应的SEL，如果没有找到，则会生成一个SEL并添加到表中</li>
<li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用的@selector()生成的选择子添加到选择子表中</li>
</ol>
<h4 id="objc-msgSend源码解析"><a href="#objc-msgSend源码解析" class="headerlink" title="objc_msgSend源码解析"></a><a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html" target="_blank" rel="noopener">objc_msgSend源码解析</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/objc-runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">id  <span class="title">c_objc_msgSend</span><span class="params">( struct objc_class <span class="comment">/* ahem */</span> *self, SEL _cmd, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span>    *<span class="title">cls</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span>    *<span class="title">cache</span>;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>         hash;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span>   *<span class="title">method</span>;</span>   </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>         index;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>( self)</span><br><span class="line">   &#123;</span><br><span class="line">      cls   = self-&gt;isa;</span><br><span class="line">      cache = cls-&gt;cache;</span><br><span class="line">      hash  = cache-&gt;mask;</span><br><span class="line">      index = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) _cmd &amp; hash;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">         method = cache-&gt;buckets[ index];</span><br><span class="line">         <span class="keyword">if</span>( ! method)</span><br><span class="line">            <span class="keyword">goto</span> recache;</span><br><span class="line">         index = (index + <span class="number">1</span>) &amp; cache-&gt;mask;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>( method-&gt;method_name != _cmd);</span><br><span class="line">      <span class="keyword">return</span>( (*method-&gt;method_imp)( (id) self, _cmd));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>( (id) self);</span><br><span class="line"></span><br><span class="line">recache:</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">   <span class="keyword">return</span>( <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中的方法do-while循环就是在当前类中的方法分发表中查找method的过程</p>
<p>另外在objc-msg-x86_64.s文件中有一段相关的汇编代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * id objc_msgSend(id self, SEL	_cmd,...);</span></span><br><span class="line"><span class="comment"> * IMP objc_msgLookup(id self, SEL _cmd, ...);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * objc_msgLookup ABI:</span></span><br><span class="line"><span class="comment"> * IMP returned in r11</span></span><br><span class="line"><span class="comment"> * Forwarding returned in Z flag</span></span><br><span class="line"><span class="comment"> * r10 reserved for our use but not used</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line">	</span><br><span class="line">	.data</span><br><span class="line">	.align <span class="number">3</span></span><br><span class="line">	.globl _objc_debug_taggedpointer_classes</span><br><span class="line">_objc_debug_taggedpointer_classes:</span><br><span class="line">	.<span class="built_in">fill</span> <span class="number">16</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line">	.globl _objc_debug_taggedpointer_ext_classes</span><br><span class="line">_objc_debug_taggedpointer_ext_classes:</span><br><span class="line">	.<span class="built_in">fill</span> <span class="number">256</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		<span class="comment">// r10 = self-&gt;isa</span></span><br><span class="line">	CacheLookup NORMAL, CALL	<span class="comment">// calls IMP on success</span></span><br><span class="line"></span><br><span class="line">	NilTestReturnZero NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache miss: go search the method lists</span></span><br><span class="line">LCacheMiss:</span><br><span class="line">	<span class="comment">// isa still in r10</span></span><br><span class="line">	jmp	__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgLookup</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		<span class="comment">// r10 = self-&gt;isa</span></span><br><span class="line">	CacheLookup NORMAL, LOOKUP	<span class="comment">// returns IMP on success</span></span><br><span class="line"></span><br><span class="line">	NilTestReturnIMP NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache miss: go search the method lists</span></span><br><span class="line">LCacheMiss:</span><br><span class="line">	<span class="comment">// isa still in r10</span></span><br><span class="line">	jmp	__objc_msgLookup_uncached</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgLookup</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgSend_fixup</span><br><span class="line">	int3</span><br><span class="line">	END_ENTRY _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	STATIC_ENTRY _objc_msgSend_fixedup</span><br><span class="line">	<span class="comment">// Load _cmd from the message_ref</span></span><br><span class="line">	movq	<span class="number">8</span>(%a2), %a2</span><br><span class="line">	jmp	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_fixedup</span><br></pre></td></tr></table></figure>

<p>拆开来看，objc_msgSend首先会去尝试查找缓存CacheLookup，当缓存中无法找到时候会去执行MethodTableLookup方法查找，MethodTableLookup可以算是一个接口层宏，主要用户保存环境和准备参数，调用__class_lookupMethodAndLoadCache3方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _class_lookupMethodAndLoadCache.</span><br><span class="line">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</span><br><span class="line">* This lookup avoids optimistic cache scan because the dispatcher </span><br><span class="line">* already tried that.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES&#x2F;*initialize*&#x2F;, NO&#x2F;*cache*&#x2F;, YES&#x2F;*resolver*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_class_lookupMethodAndLoadCache3函数也是个接口层，此函数提供相应的参数配置，实际功能在lookUpImpOrForward中</p>
<h5 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span></span><br><span class="line"><span class="comment">* Most callers should use initialize==YES and cache==YES.</span></span><br><span class="line"><span class="comment">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span></span><br><span class="line"><span class="comment">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span></span><br><span class="line"><span class="comment">* May return _objc_msgForward_impcache. IMPs destined for external use </span></span><br><span class="line"><span class="comment">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span></span><br><span class="line"><span class="comment">*   If you don't want forwarding at all, use lookUpImpOrNil() instead.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">/*…… 中间为查找过程 ……*/</span></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐行解析一下</p>
<ol>
<li><p>runtimeLock.assertUnlocked();这是加一个读写锁，保证线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.assertUnlocked();</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否查找缓存的IMP，如果传入YES，则调用cache_getImp方法去查找缓存中IMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">if (cache) &#123;</span><br><span class="line">    imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cache_getImp的具体实现也是具体的编译指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> * IMP cache_getImp(Class cls, SEL sel)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On entry:	a1 = class whose cache is to be searched</span></span><br><span class="line"><span class="comment"> *		a2 = selector to search for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If found, returns method implementation.</span></span><br><span class="line"><span class="comment"> * If not found, returns NULL.</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY _cache_getImp</span><br><span class="line"></span><br><span class="line"><span class="comment">// do lookup</span></span><br><span class="line">	movq	%a1, %r10		<span class="comment">// move class to r10 for CacheLookup</span></span><br><span class="line">	CacheLookup NORMAL, GETIMP	<span class="comment">// returns IMP on success</span></span><br><span class="line"></span><br><span class="line">LCacheMiss:</span><br><span class="line"><span class="comment">// cache miss, return nil</span></span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY _cache_getImp</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验当前类是否已被加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* isKnownClass</span><br><span class="line">* Return true if the class is known to the runtime (located within the</span><br><span class="line">* shared cache, within the data segment of a loaded image, or has been</span><br><span class="line">* allocated with obj_allocateClassPair).</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static bool isKnownClass(Class cls) &#123;</span><br><span class="line">    &#x2F;&#x2F; The order of conditionals here is important for speed. We want to</span><br><span class="line">    &#x2F;&#x2F; put the most common cases first, but also the fastest cases</span><br><span class="line">    &#x2F;&#x2F; first. Checking the shared region is both fast and common.</span><br><span class="line">    &#x2F;&#x2F; Checking allocatedClasses is fast, but may not be common,</span><br><span class="line">    &#x2F;&#x2F; depending on what the program is doing. Checking if data segments</span><br><span class="line">    &#x2F;&#x2F; contain the address is slow, so do it last.</span><br><span class="line">    return (sharedRegionContains(cls) ||</span><br><span class="line">            NXHashMember(allocatedClasses, cls) ||</span><br><span class="line">            dataSegmentsContain(cls));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断当前类是否被初始化，进行首次初始化，分配读写数据，返回真实类结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        cls &#x3D; realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化类的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, class_initialize will send +initialize and </span><br><span class="line">        &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为在运行时中会动态的添加方法，为了保证线程安全，所有加了一个读锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试从缓存列表IMP中获取IMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Try this class&#39;s cache.</span><br><span class="line">imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试从类的方法列表中获取方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Try this class&#39;s method lists.</span><br><span class="line">&#123;</span><br><span class="line">    Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    if (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp &#x3D; meth-&gt;imp;</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试从父类及层次结构链中查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line">&#123;</span><br><span class="line">    unsigned attempts &#x3D; unreasonableClassCount();</span><br><span class="line">    for (Class curClass &#x3D; cls-&gt;superclass;</span><br><span class="line">         curClass !&#x3D; nil;</span><br><span class="line">         curClass &#x3D; curClass-&gt;superclass)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">        if (--attempts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass cache.</span><br><span class="line">        imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            if (imp !&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">                log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass method list.</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果都没有找到IMP实现，尝试进行一次方法决议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    resolveMethod(cls, sel, inst);</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    &#x2F;&#x2F; Don&#39;t cache the result; we don&#39;t hold the lock so it may have </span><br><span class="line">    &#x2F;&#x2F; changed already. Re-do the search from scratch instead.</span><br><span class="line">    triedResolver &#x3D; YES;</span><br><span class="line">    goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开读锁，因为在此开发者可能会动态增加方法实现，不需要缓存结果，但是此处锁被打开可能会出现线程问题，所以执行结束后会<code>goto retry;</code>，重新执行一边之前的查找过程</p>
</li>
<li><p>如果在<code>resolveMethod</code>方法结束后仍没有找到IMP的实现，method resolver也失效了，那么只能进行消息转发阶段了，在进入这个阶段之前，imp变成了<code>_objc_msgForward_impcache</code>，加入到缓存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help. </span><br><span class="line">&#x2F;&#x2F; Use forwarding.</span><br><span class="line"></span><br><span class="line">    imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="消息转发Message-Forwarding阶段"><a href="#消息转发Message-Forwarding阶段" class="headerlink" title="消息转发Message Forwarding阶段"></a>消息转发Message Forwarding阶段</h4><ol>
<li><p>当<code>_objc_msgForward_impcache</code>被存储在方法缓存中时，会调用<code>id _objc_msgForward(id self, SEL _cmd,...);</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line">*</span><br><span class="line">* id _objc_msgForward(id self, SEL _cmd,...);</span><br><span class="line">*</span><br><span class="line">* _objc_msgForward is the externally-callable</span><br><span class="line">*   function returned by things like method_getImplementation().</span><br><span class="line">* _objc_msgForward_impcache is the function pointer actually stored in</span><br><span class="line">*   method caches.</span><br><span class="line">*</span><br><span class="line">********************************************************************/</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	// No stret specialization.</span><br><span class="line">	b	__objc_msgForward</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">	adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">	TailCallFunctionPointer x17</span><br><span class="line">	</span><br><span class="line">	END_ENTRY __objc_msgForward</span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgSend_noarg</span><br><span class="line">	b	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_noarg</span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend_debug</span><br><span class="line">	b	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_debug</span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSendSuper2_debug</span><br><span class="line">	b	_objc_msgSendSuper2</span><br><span class="line">	END_ENTRY _objc_msgSendSuper2_debug</span><br><span class="line"></span><br><span class="line">	ENTRY _method_invoke</span><br><span class="line">	// x1 is method triplet instead of SEL</span><br><span class="line">	add	p16, p1, #METHOD_IMP</span><br><span class="line">	ldr	p17, [x16]</span><br><span class="line">	ldr	p1, [x1, #METHOD_NAME]</span><br><span class="line">	TailCallMethodListImp x17, x16</span><br><span class="line">	END_ENTRY _method_invoke</span><br></pre></td></tr></table></figure>

<p>执行<code>__objc_msgForward</code>方法后，会调用<code>__objc_forward_handler</code>函数</p>
</li>
<li><p>在objc-runtime文件中，<code>void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</code>,<code>objc_defaultForwardHandler</code>函数中可以看到我们常见的报错信息unrecognized selector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Default forward handler halts the process.</span><br><span class="line">__attribute__((noreturn)) void </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler &#x3D; (void*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要设置转发只要重写<code>_objc_forward_handler</code>函数即可，在<code>objc_setForwardHandler</code>函数中可以设置forward_handler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void objc_setForwardHandler(void *fwd, void *fwd_stret)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_forward_handler &#x3D; fwd;</span><br><span class="line">#if SUPPORT_STRET</span><br><span class="line">    _objc_forward_stret_handler &#x3D; fwd_stret;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>等等</li>
</ol>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Check for ignored selectors (GC) and short-circuit.</span><br><span class="line"> 2. Check for nil target.</span><br><span class="line">    If nil &amp; nil receiver handler configured, jump to handler</span><br><span class="line">    If nil &amp; no handler (default), cleanup and return.</span><br><span class="line"> 3. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache)</span><br><span class="line">    -1. If found, jump to it.</span><br><span class="line">    -2. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain.</span><br><span class="line">        If found, load it into cache and jump to it.</span><br><span class="line">        If not found, jump to forwarding mechanism.</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查选择子selector是不是要忽略</p>
</li>
<li><p>检查target是否为nil</p>
</li>
<li><p>在该类class的方法缓存列表中查找方法对呀的IMP实现，如果找到就跳转进去执行</p>
<p>如果没有找到，就在当前类及层次结构链中的方法列表中查找方法的IMP实现</p>
</li>
<li><p>如果还是没有找到，跳转进入消息转发机智</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doris AI</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doris AI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
