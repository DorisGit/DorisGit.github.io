<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorisgit.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="泡泡茶壶">
<meta property="og:url" content="https://dorisgit.github.io/index.html">
<meta property="og:site_name" content="泡泡茶壶">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Doris AI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dorisgit.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>泡泡茶壶</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泡泡茶壶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/06/jekins-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/jekins-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">jekins+单元测试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-06 23:39:58 / Modified: 23:45:30" itemprop="dateCreated datePublished" datetime="2020-03-06T23:39:58+08:00">2020-03-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Jekins环境我们已经有了，单元测试可以参考[XCTest]相关的，这里简单说下如何创建单元测试job以及利用Jekins生成Junit的单元测试报告</p>
<h3 id="1、和之前持续化集成的步骤相同，新建一个Gengmei-Test的Job"><a href="#1、和之前持续化集成的步骤相同，新建一个Gengmei-Test的Job" class="headerlink" title="1、和之前持续化集成的步骤相同，新建一个Gengmei_Test的Job"></a>1、和之前持续化集成的步骤相同，新建一个Gengmei_Test的Job</h3><h3 id="2、增加构建Execute-shell"><a href="#2、增加构建Execute-shell" class="headerlink" title="2、增加构建Execute shell"></a>2、增加构建Execute shell</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild test -workspace Gengmei.xcworkspace -scheme Gengmei -sdk iphonesimulator13.0 -destination OS=13.0,name="iPhone 11" -configuration Debug 2&gt;&amp;1 | ocunit2junit</span><br></pre></td></tr></table></figure>

<p>这里设置的单元测试是在模拟器上上进行的，如果测试服务器连接着iOS设备，也可以设置在iOS设备中进行，只需修改上述shell的参数即可</p>
<h4 id="2-1-查看当前项目信息，执行命令"><a href="#2-1-查看当前项目信息，执行命令" class="headerlink" title="2.1 查看当前项目信息，执行命令"></a>2.1 查看当前项目信息，执行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -list</span><br></pre></td></tr></table></figure>

<p>可以看到当前Gengmei项目Targets、Build、Schemes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Information about project &quot;Gengmei&quot;:</span><br><span class="line">    Targets:</span><br><span class="line">        Gengmei</span><br><span class="line">        GengmeiTests</span><br><span class="line">        GengmeiUITests</span><br><span class="line">        GMServiceExtension</span><br><span class="line"> </span><br><span class="line">    Build Configurations:</span><br><span class="line">        Debug</span><br><span class="line">        UnitTest</span><br><span class="line">        Release</span><br><span class="line">        AppStore</span><br><span class="line"> </span><br><span class="line">    If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.</span><br><span class="line"> </span><br><span class="line">    Schemes:</span><br><span class="line">        Gengmei</span><br><span class="line">        Gengmei-AppStore</span><br><span class="line">        GMServiceExtension</span><br></pre></td></tr></table></figure>



<h4 id="2-2-查看当前服务器Xcode-sdk版本"><a href="#2-2-查看当前服务器Xcode-sdk版本" class="headerlink" title="2.2 查看当前服务器Xcode sdk版本"></a>2.2 查看当前服务器Xcode sdk版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -showsdks</span><br></pre></td></tr></table></figure>

<p>在没有真机连接的情况下，测试服务器上版本如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iOS SDKs:</span><br><span class="line">    iOS 13.0                        -sdk iphoneos13.0</span><br><span class="line"> </span><br><span class="line">iOS Simulator SDKs:</span><br><span class="line">    Simulator - iOS 13.0            -sdk iphonesimulator13.0</span><br><span class="line"> </span><br><span class="line">macOS SDKs:</span><br><span class="line">    DriverKit 19.0                  -sdk driverkit.macosx19.0</span><br><span class="line">    macOS 10.15                     -sdk macosx10.15</span><br><span class="line"> </span><br><span class="line">tvOS SDKs:</span><br><span class="line">    tvOS 13.0                       -sdk appletvos13.0</span><br><span class="line"> </span><br><span class="line">tvOS Simulator SDKs:</span><br><span class="line">    Simulator - tvOS 13.0           -sdk appletvsimulator13.0</span><br><span class="line"> </span><br><span class="line">watchOS SDKs:</span><br><span class="line">    watchOS 6.0                     -sdk watchos6.0</span><br><span class="line"> </span><br><span class="line">watchOS Simulator SDKs:</span><br><span class="line">    Simulator - watchOS 6.0         -sdk watchsimulator6.0</span><br></pre></td></tr></table></figure>



<h4 id="2-3-通过指定schema获取当前支持的destination"><a href="#2-3-通过指定schema获取当前支持的destination" class="headerlink" title="2.3 通过指定schema获取当前支持的destination"></a>2.3 通过指定schema获取当前支持的destination</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -showdestinations -scheme Gengmei</span><br></pre></td></tr></table></figure>

<p>打印如下，有真机连接的情况，这里应该也可以获取到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Available destinations for the "Gengmei" scheme:</span><br><span class="line">        &#123; platform:iOS Simulator, id:A1E89E7A-D771-49DC-B593-2C30B3C04A6D, OS:13.0, name:iPad Air (3rd generation) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:DAAF8FA0-7FF7-47E4-B93B-7FA3A0367043, OS:13.0, name:iPad Pro (9.7-inch) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:41FFCDB7-460E-4B01-A18F-BAE4049476B5, OS:13.0, name:iPad Pro (11-inch) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:F7133775-46B4-4C21-896E-4296F2179FDA, OS:13.0, name:iPad Pro (12.9-inch) (3rd generation) &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:B28FB262-94CA-40AD-9118-20F8BAFFAC88, OS:13.0, name:iPhone 8 &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:5E62CB73-DC9D-4E36-A055-DE900078E51E, OS:13.0, name:iPhone 8 Plus &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:4B700323-428C-447D-8D6A-3E672C4F9F22, OS:13.0, name:iPhone 11 &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:24BEE8EB-CC92-40BD-B416-6C011777F7AE, OS:13.0, name:iPhone 11 Pro &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:7D982993-8383-461F-9CBB-553AEF1A7C9D, OS:13.0, name:iPhone 11 Pro Max &#125;</span><br><span class="line"> </span><br><span class="line">    Ineligible destinations for the "Gengmei" scheme:</span><br><span class="line">        &#123; platform:iOS, id:dvtdevice-DVTiPhonePlaceholder-iphoneos:placeholder, name:Generic iOS Device &#125;</span><br><span class="line">        &#123; platform:iOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-iphonesimulator:placeholder, name:Generic iOS Simulator Device &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-4-2-gt-amp-1"><a href="#2-4-2-gt-amp-1" class="headerlink" title="2.4  2&gt;&amp;1"></a>2.4  2&gt;&amp;1</h4><p>2&gt;&amp;1  意思是把 标准错误输出 重定向到 标准输出</p>
<p>这里的测试输出结果既有正常输出内容又有错误输出内容</p>
<h3 id="3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本"><a href="#3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本" class="headerlink" title="3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本"></a>3、配置支持将ocunit格式的测试报告转化为JUnit报告格式的脚本</h3><p>安装OCUnit2JUnit，执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install ocunit2junit</span><br></pre></td></tr></table></figure>



<h3 id="4、测试报告"><a href="#4、测试报告" class="headerlink" title="4、测试报告"></a>4、测试报告</h3><p>点击“Add post-build action”选择“Publish JUnit test result report”，输入内容test-reports/*.xml保存设置</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/06/%E6%90%AD%E5%BB%BAJekins-Sonarqube%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/%E6%90%AD%E5%BB%BAJekins-Sonarqube%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">搭建Jekins+Sonarqube环境</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-06 17:30:37 / Modified: 18:22:09" itemprop="dateCreated datePublished" datetime="2020-03-06T17:30:37+08:00">2020-03-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Jekins环境已有，那么就直接准备Sonarqube吧</p>
<ol>
<li><p>安装<a href="https://www.sonarqube.org/downloads/" target="_blank" rel="noopener">Sonarqube</a>)</p>
<p>解压到/usr/local/下</p>
</li>
<li><p>安装<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdev.mysql.com%2Fdownloads%2Fmysql%2F" target="_blank" rel="noopener">MySql</a></p>
<p>虽然SonarQube自带了H2数据库，但是为了方便管理数据推荐使用Mysql数据库</p>
</li>
</ol>
<ol start="3">
<li>首先确保安装了jdk1.8 +</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/03/05/%E9%A6%96%E9%A1%B5%E4%BC%98%E5%8C%96%E4%B9%8B%E2%80%94%E2%80%94%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/%E9%A6%96%E9%A1%B5%E4%BC%98%E5%8C%96%E4%B9%8B%E2%80%94%E2%80%94%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">首页优化之——离屏渲染</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-05 21:13:25 / Modified: 21:29:36" itemprop="dateCreated datePublished" datetime="2020-03-05T21:13:25+08:00">2020-03-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首页作为最大访问量的页面，页面流畅度怎么样？会不会存在多余的CPU计算、GPU渲染占用额外资源问题？视图图层还有没有可优化的空间？App体验很重要，一款流畅的app会给用户带来不一样的使用感受。</p>
<h1 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenGL中，GPU屏幕渲染方式中有两种，一种当前屏幕渲染，一种为离屏渲染</p>
<p>On-Screen Rendering（当前屏幕渲染）</p>
<p>GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行</p>
<p>Off-Screen Rendering（离屏渲染）</p>
<p>GPU的渲染操作是在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作，处理不好离屏渲染往往会对APP的性能产生较大的影响</p>
<h3 id="为什么离屏渲染往往会对APP的性能产生较大的影响"><a href="#为什么离屏渲染往往会对APP的性能产生较大的影响" class="headerlink" title="为什么离屏渲染往往会对APP的性能产生较大的影响?"></a>为什么离屏渲染往往会对APP的性能产生较大的影响?</h3><p>想要进行离屏渲染，首先得创建一个屏幕外缓冲区，屏幕渲染会有一个上下文环境的概念，离屏渲染的整个过程需要切换上下文环境，先从当前屏幕切换到离屏，等渲染完成后又需要再切换回来，触发离屏渲染后，这样的转换发生在每一帧，在页面发生滚动的过程中出现大量离屏渲染，会严重影响帧率；</p>
<p>由于垂直同步机制的机制，如果一个ASync时间内容GPU没有完成渲染任务，提交到帧缓冲区，那么这一帧就会被丢弃，等到下一次机会再显示，而屏幕则依旧展示上一次内容，也就是我们看到的界面卡顿。</p>
<h3 id="既然离屏渲染这么耗性能，为什么有这套机制呢？"><a href="#既然离屏渲染这么耗性能，为什么有这套机制呢？" class="headerlink" title="既然离屏渲染这么耗性能，为什么有这套机制呢？"></a><strong>既然离屏渲染这么耗性能，为什么有这套机制呢？</strong></h3><p>有些效果被认为不能直接显示在屏幕上，而需要在别的地方做预合成。图层属性的混合体在没有被预合成之前不能直接在屏幕上绘制，这时就需要离屏渲染。离屏渲染并不意味着软件绘制，但是它意味着图层在被绘制到屏幕上前必须在一个屏幕外上下文环境中被渲染合成（不论是CPU 还是GPU）</p>
<h3 id="怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？"><a href="#怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？" class="headerlink" title="怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？"></a>怎样既能保证图层属性混合体在一个屏幕外上下文环境中被绘制，而又不影响App性能呢？</h3><p>1、缓存已经合成的纹理图，复用缓存位图，但这样只能在位图不会发生变化的前提下使用，在一些场景下位图的失效，或者还需要被使用的位图也有可能被GPU丢弃的情况下，需要额外的计算来校验位图的是否可用情况；</p>
<p>2、既然离屏渲染的关键点在于两次昂贵的环境切换（转换环境到屏幕外缓冲区，再转换环境到帧缓冲区），文章<a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕</a>中也有提到“直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多”</p>
<h2 id="哪些情况会引发离屏渲染"><a href="#哪些情况会引发离屏渲染" class="headerlink" title="哪些情况会引发离屏渲染"></a>哪些情况会引发离屏渲染</h2><ul>
<li>为图层设置遮罩（layer.mask）</li>
<li>将图层的layer.masksToBounds / view.clipsToBounds属性设置为true</li>
<li>将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0</li>
<li>为图层设置阴影（layer.shadow *）</li>
<li>为图层设置layer.shouldRasterize=true（光栅化）</li>
<li>具有layer.cornerRadius，layer.edgeAntialiasingMask（抗锯齿），layer.allowsEdgeAntialiasing的图层</li>
<li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）</li>
<li>使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅只是一个空的实现</li>
</ul>
<h2 id="检测项目中离屏渲染"><a href="#检测项目中离屏渲染" class="headerlink" title="检测项目中离屏渲染"></a>检测项目中离屏渲染</h2><h3 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h3><p>模拟器的 debug -&gt; 选取 Color Off-screen Rendered</p>
<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_15-58-38.png?version=1&amp;modificationDate=1583395119000&amp;api=v2" alt="img" style="zoom:80%;" />

<p>打开后会把需要离屏渲染的部分高亮为黄色，表明这些黄色图层可能存在性能问题</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_15-59-8.png" alt="img"></p>
<p>可以看出搜索栏、Banner设置圆角、卡片设置圆角的图层出现了离屏渲染的问题</p>
<p>1、搜索栏、Banner圆角设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.layer.masksToBounds &#x3D; YES;</span><br><span class="line">self.layer.cornerRadius &#x3D; self.height &#x2F; 2;</span><br></pre></td></tr></table></figure>

<p>取消圆角设置，卡片上的黄色图层随机消失，可以看出图层的layer.masksToBounds / view.clipsToBounds属性设置为true会引发离屏渲染</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-17-35.png" alt="img"></p>
<p>2、卡片圆角设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)containerRectCorner:(CGSize)cornerRadii byRoundingCorners:(UIRectCorner)corners &#123;</span><br><span class="line">    UIBezierPath *maskPath &#x3D; [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:corners cornerRadii:cornerRadii];</span><br><span class="line">    CAShapeLayer *maskLayer &#x3D; [[CAShapeLayer alloc] init];</span><br><span class="line">    maskLayer.frame &#x3D; self.bounds;</span><br><span class="line">    maskLayer.path &#x3D; maskPath.CGPath;</span><br><span class="line">    self.layer.mask &#x3D; maskLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当把卡片圆角设置取消掉，卡片上的黄色图层随机消失，表明当我们直接为图层设置遮罩（layer.mask），是会引发离屏渲染的</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-17-16.png" alt="img"></p>
<p>3、更改View的Alpha小于1</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-13-58.png" alt="img"></p>
<p>在这里，其实我们是在滑动过程中更新segment的Alpha值，当Alpha&lt;1时，可以看出出现离屏渲染的情况，而当alpha=1时，则黄色消失</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-4_20-16-11.png" alt="img"></p>
<h3 id="Instrument检测"><a href="#Instrument检测" class="headerlink" title="Instrument检测"></a>Instrument检测</h3><p>Instrument 的 Core Animation 工具检查 <em>Color Hits Green and Misses Red</em> 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>
<h2 id="方案优化"><a href="#方案优化" class="headerlink" title="方案优化"></a>方案优化</h2><h3 id="圆角优化"><a href="#圆角优化" class="headerlink" title="圆角优化"></a>圆角优化</h3><p><strong>1、设置shouldRasterize=true（光栅化）</strong></p>
<p>缓存可以使离屏渲染的结果缓存到内存中存为位图， 使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新 创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.layer.shouldRasterize &#x3D; YES; </span><br><span class="line">self.layer.rasterizationScale &#x3D; [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure>



<p><strong>2、使用Core Graphics 绘制圆角</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)mm_addRounderCornerWithRadius:(CGFloat)radius &#123;</span><br><span class="line"> </span><br><span class="line">    CGSize size &#x3D; self.bounds.size;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, 0);</span><br><span class="line">    CGContextRef cxt &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSetFillColorWithColor(cxt, [UIColor whiteColor].CGColor);</span><br><span class="line">    CGContextSetStrokeColorWithColor(cxt, [UIColor redColor].CGColor);</span><br><span class="line">    CGContextSetLineWidth(cxt, 0.5);</span><br><span class="line">    CGContextMoveToPoint(cxt, 0, radius);</span><br><span class="line">    CGContextAddArcToPoint(cxt, 0, 0, radius, 0, radius);&#x2F;&#x2F; 左上角</span><br><span class="line">    CGContextAddArcToPoint(cxt, size.width, 0, size.width, radius, radius);&#x2F;&#x2F; 右上角</span><br><span class="line">    CGContextAddArcToPoint(cxt, size.width, size.height ,size.width-radius, size.height, radius);&#x2F;&#x2F; 右下角</span><br><span class="line">    CGContextAddArcToPoint(cxt, 0, size.height, 0, size.height-radius, radius);&#x2F;&#x2F; 左下角</span><br><span class="line">    CGContextSetLineCap(cxt, kCGLineCapRound);</span><br><span class="line">    CGContextSetLineJoin(cxt, kCGLineJoinRound);</span><br><span class="line">    CGContextClosePath(cxt);</span><br><span class="line">    CGContextDrawPath(cxt, kCGPathFillStroke);</span><br><span class="line">    UIImage *image &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"> </span><br><span class="line">    UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, size.width, size.height)];</span><br><span class="line">    [imageView setImage:image];</span><br><span class="line">    [self insertSubview:imageView atIndex:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2、使用贝塞尔曲线UIBezierPath和Core Graphics框架画出一个圆角</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawImageRoundedCorners:(UIRectCorner)corners</span><br><span class="line">                      withRadii:(CGSize)radii &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;开始对imageView进行画图</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(rect.size, NO, 1);</span><br><span class="line">    &#x2F;&#x2F;使用贝塞尔曲线画出一个圆形图</span><br><span class="line">    CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    [[UIColor redColor] setStroke];</span><br><span class="line">    [[UIColor whiteColor] setFill];</span><br><span class="line">    UIBezierPath *bezierPath &#x3D; [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</span><br><span class="line">    [bezierPath addClip];</span><br><span class="line">    CGContextAddPath(ctx, bezierPath.CGPath);</span><br><span class="line">    CGContextDrawPath(ctx, kCGPathFillStroke);</span><br><span class="line">    UIImage *image &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    &#x2F;&#x2F;结束画图</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"> </span><br><span class="line">    UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:self.bounds];</span><br><span class="line">    imageView.image &#x3D; image;</span><br><span class="line">    [self insertSubview:imageView atIndex:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_16-49-19.png?version=1&modificationDate=1583398160000&api=v2" alt="img"></p>
<p><strong>左1 右2</strong></p>
<p><strong>3、使用CAShapeLayer和UIBezierPath设置圆角</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)addRoundedCorners:(UIRectCorner)corners</span><br><span class="line">                withRadii:(CGSize)radii</span><br><span class="line">                fillColor:(CGColorRef)fillColor</span><br><span class="line">              borderColor:(CGColorRef)borderColor</span><br><span class="line">              borderWidth:(CGFloat)borderWidth &#123;</span><br><span class="line">     </span><br><span class="line">    UIBezierPath *rounded &#x3D; [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:corners cornerRadii:radii];</span><br><span class="line">    CAShapeLayer *shape &#x3D; [[CAShapeLayer alloc] init];</span><br><span class="line">    shape.frame &#x3D; self.bounds;</span><br><span class="line">    shape.strokeColor &#x3D; borderColor;</span><br><span class="line">    shape.fillColor &#x3D; fillColor;</span><br><span class="line">    shape.lineWidth &#x3D; borderWidth;</span><br><span class="line">    shape.path &#x3D; rounded.CGPath;</span><br><span class="line">    [self.layer addSublayer:shape];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><p><strong>以上2、3、4无论哪一种方法，都不能为View设置背景颜色</strong></p>
<p>因为我们没有设置masksToBounds，超出圆角的部分仍然会显示</p>
<p><strong>在使用UIGraphicsGetCurrentContext()尝试获取当前上下文进行绘制时，发现拿到的一直是nil</strong></p>
<p>原因是，在调用 drawRect前，视图对象会先往栈上压入一个有效的上下文并使它成为当前上下文。所以在drawRect方法中可以通过UIGraphicsGetCurrentContext()获取到上下文。但是在其他地方可能会获取到为nil,需要自己创建一个上下文如果</p>
<p>能够只用 <code>cornerRadius</code> 解决问题，就不用优化。 </p>
<p>如果必须设置 <code>masksToBounds</code>，可以参考圆角视图的数量，如果数量较少（一页只有几个）也可以考虑不用优化。 </p>
<p><code>UIImageView</code> 的圆角通过直接截取图片实现，其它视图的圆角可以通过 Core Graphics 画出圆角矩形实现。</p>
<p><a href="http://www.cocoachina.com/articles/12873" target="_blank" rel="noopener">layer.mask与layer.cornerRadius测试对比</a></p>
<p>实现圆角cornerRadius要比mask高效很多。</p>
<p>Rasterize在大部分情况下极大减少GPU工作。在有空间的情况下，大部分情况下缓存总能帮到你</p>
<p>后台预处理图片也能很简单帮上你很大的忙。</p>
<h4 id="关于cornerRadius属性的解释"><a href="#关于cornerRadius属性的解释" class="headerlink" title="关于cornerRadius属性的解释"></a><code>关于cornerRadius属性的解释</code></h4><blockquote>
<p>By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to true causes the content to be clipped to the rounded corners.</p>
</blockquote>
<p>也就是说在默认情况下，cornerRadius这个属性只会影响背景颜色和layer的border属性，而不会影响View的contents属性，只有当设置masksToBounds为True的时候，才会影响View的content</p>
<h3 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h3><p>通常设置阴影的方式为,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.layer.shadowColor &#x3D; shadowColor.CGColor;</span><br><span class="line">self.layer.shadowOffset &#x3D; shadowOffset;</span><br><span class="line">self.layer.shadowOpacity &#x3D; shadowOpacity;</span><br><span class="line">self.layer.shadowRadius &#x3D; shadowRadius;</span><br></pre></td></tr></table></figure>

<p>另外一种设置阴影的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)addShadow:(UIColor *)shadowColor shadowOpacity:(CGFloat)shadowOpacity shadowRadius:(CGFloat)shadowRadius shadowOffset:(CGSize)shadowOffset shadowFrame:(CGRect)shadowFrame &#123;</span><br><span class="line">    self.layer.shadowColor &#x3D; shadowColor.CGColor;</span><br><span class="line">    self.layer.shadowOffset &#x3D; shadowOffset;</span><br><span class="line">    self.layer.shadowOpacity &#x3D; shadowOpacity;</span><br><span class="line">    self.layer.shadowRadius &#x3D; shadowRadius;</span><br><span class="line">    self.layer.masksToBounds &#x3D; NO;</span><br><span class="line">    UIBezierPath *path &#x3D; [UIBezierPath bezierPathWithRect:shadowFrame];</span><br><span class="line">    self.layer.shadowPath &#x3D; path.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们看下效果</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_18-24-47.png?version=1&modificationDate=1583403888000&api=v2" alt="img"></p>
<p>左侧出现了我们的Off-Screen Render Yellow，也就是检测出来离屏渲染，这里的区别就是，默认shadowPath为nil，仅开启阴影(没有指定路径，同屏数量10个以上)在滚动时帧率会大幅下降，检测到离屏渲染的黄色特征；指定一个与边界相同的简单路径后离屏渲染特征消失，帧率恢复正常。</p>
<p><strong>测试结果（结果来源于 <a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a>）</strong></p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_18-27-27.png?version=1&modificationDate=1583404048000&api=v2" alt="img"></p>
<p>为阴影指定路径确实可以作为阴影优化的一点，“除了指定路径，实现良好性能阴影的方法还有：用圆角优化里混合图层的方法模拟阴影的效果：放一个同样效果的视图在要添加阴影程度的视图的下方；使用 Core Graphics 绘制阴影，不过除非万不得已没人想碰 Core Graphics API。从实现成本来讲，都不如指定路径方便。这两种方法实现简单形状的阴影比较方便，比如图中左侧和中间的效果，面对右侧的阴影效果就不好弄了，用指定路径的方法实现也比较麻烦。</p>
<h3 id="Mask"><a href="#Mask" class="headerlink" title="Mask"></a>Mask</h3><p>一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和它下面包含的像素合并之前都会把 mask 应用到图层的像素上去，当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板</p>
<p>前面看到过，当我们为一个View设置圆角时，同样也可以通过Mask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)addRoundedCorners:(UIRectCorner)corners</span><br><span class="line">                withRadii:(CGSize)radii &#123;</span><br><span class="line">    UIBezierPath* rounded &#x3D; [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:corners cornerRadii:radii];</span><br><span class="line">    CAShapeLayer* shape &#x3D; [[CAShapeLayer alloc] init];</span><br><span class="line">    [shape setPath:rounded.CGPath];</span><br><span class="line">    self.layer.mask &#x3D; shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是显然Mask仍然会有离屏渲染</p>
<p>同样的 mask 效果使用 CAShapeLayer 时相比直接使用 maskView 在帧率上稍低，CPU 利用率无明显变化，但是 GPU 利用率也低一些。</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2014/419/" target="_blank" rel="noopener">WWDC 2014: Advanced Graphics and Animations for iOS Apps</a></p>
<h3 id="GroupOpacity"><a href="#GroupOpacity" class="headerlink" title="GroupOpacity"></a>GroupOpacity</h3><p><img src="http://q6luryr3j.bkt.clouddn.com/37334-ea98e568f4748d39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1045" alt="img"></p>
<p>GroupOpacity 是指 CALayer 的<code>allowsGroupOpacity</code>属性，UIView 的<code>alpha</code>属性等同于 CALayer <code>opacity</code>属性。开启 GroupOpacity 后，子 layer 在视觉上的透明度的上限是其父 layer 的<code>opacity；</code></p>
<p>从 iOS 7 以后默认全局开启了这个功能，这样做是为了让子视图与其容器视图保持同样的透明度。</p>
<p>这个触发条件并不需要subLayer.opacity != 1.0，非常容易满足。然而在 TableView 这样的视图里设置 cell 的alpha属性小于1并不能检测离屏渲染的黄色特征，性能上也没有明显差别。经过摸索发现：只有设置cell.contentView, tableView 的alpha小于1时会触发离屏渲染，对性能无明显影响；设置 cell 的alpha属性并不会对整体的透明度产生影响，只有设置 cell.contentView 才有效</p>
<p>设置cell的alpha属性小于1，无离屏渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.alpha &#x3D; 0.3;</span><br></pre></td></tr></table></figure>

<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_19-49-52.png" alt="img" style="zoom:80%;" />

<p>设置cell.contentView的属性小于1，有离屏渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.contentView.alpha &#x3D; 0.3;</span><br></pre></td></tr></table></figure>

<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_19-48-46.png" alt="img" style="zoom:80%;" />

<h3 id="开启layer-edgeAntialiasingMask、layer-allowsEdgeAntialiasing的图层"><a href="#开启layer-edgeAntialiasingMask、layer-allowsEdgeAntialiasing的图层" class="headerlink" title="开启layer.edgeAntialiasingMask、layer.allowsEdgeAntialiasing的图层"></a>开启layer.edgeAntialiasingMask、layer.allowsEdgeAntialiasing的图层</h3><p>经过测试，开启设置<code>layer.allowsEdgeAntialiasing=true、layer.</code>edgeAntialiasingMask=true并不会触发离屏渲染，对性能也没有什么影响</p>
<img src="http://q6luryr3j.bkt.clouddn.com/image2020-3-5_19-55-32.png" alt="img" style="zoom:80%;" />



<h2 id="其他一些优化建议"><a href="#其他一些优化建议" class="headerlink" title="其他一些优化建议"></a>其他一些优化建议</h2><ul>
<li>当我们需要圆角效果时，可以使用一张中间透明图片蒙上去</li>
<li>使用ShadowPath指定layer阴影效果路径</li>
<li>使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit）</li>
<li>设置layer的opaque值为YES，减少复杂图层合成</li>
<li>尽量使用不包含透明（alpha）通道的图片资源</li>
<li>尽量设置layer的大小值为整形值</li>
<li>直接让美工把图片切成圆角进行显示，这是效率最高的一种方案</li>
<li>很多情况下用户上传图片进行显示，可以让服务端处理圆角</li>
<li>使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>RoundedCorner 在仅指定<code>cornerRadius</code>时不会触发离屏渲染，仅适用于特殊情况：<code>contents</code>为 nil 或者<code>contents</code>不会遮挡背景色圆角；</li>
<li>Shawdow 可以通过指定路径来取消离屏渲染；</li>
<li>Mask 无法取消离屏渲染；</li>
</ol>
<p>以上效果在同等数量的规模下，对性能的影响等级：Shadow &gt; RoundedCorner &gt; Mask &gt; GroupOpacity</p>
<p>任何时候优先考虑避免触发离屏渲染，无法避免时优化方案有两种：</p>
<ol>
<li>Rasterization：适用于静态内容的视图，也就是内部结构和内容不发生变化的视图，对上面的所有效果而言，在实现成本以及性能上最均衡的。即使是动态变化的视图，开启 Rasterization 后能够有效降低 GPU 的负荷，不过在动态视图里是否启用还是看 Instruments 的数据。</li>
<li>规避离屏渲染，用其他手法来模拟效果，混合图层是个性能最好、耗能最少的通用优化方案，尤其对于 rounded corer 和 mask。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a></p>
<p><a href="http://www.cocoachina.com/articles/12873" target="_blank" rel="noopener">layer.mask与layer.cornerRadius测试对比</a></p>
<p><a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕上</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/02/27/iOS%E5%BC%80%E5%8F%91-layoutSubviews/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/iOS%E5%BC%80%E5%8F%91-layoutSubviews/" class="post-title-link" itemprop="url">iOS开发-layoutSubviews</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 22:38:58 / Modified: 22:39:21" itemprop="dateCreated datePublished" datetime="2020-02-27T22:38:58+08:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前段时间准备Autolayout用做Cell适配的时候，涉及多行Label需要在当前Cell调用layoutSubViews方法后拿到确定多行Label的Rect（preferredMaxLayoutWidth参照的是Label的Rect），总是因为不知道Cell的layoutSubviews不知道在何时被调用而遇到一些坑，总结一下layoutSubviews刷新布局及调用情况。</p>
<hr>
<p><strong>官方文档</strong></p>
<p>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>
<p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p>
<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>
<p><strong>Tips</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iOS5.1和更早版本该方法的实现不会执行任何操作,iOS5.1之后版本实现该方法会依照外部已确定的子视图大小和位置的约束进行布局</span><br><span class="line">子类可以重写该方法来进行更精确的布局子控件，通过在此方法中直接调整控件大小和约束为所需的</span><br><span class="line">官方强调不要直接调用layoutSubviews,想要做布局更新的话，官方建议使用setNeedsLayout而非绘制更新,想要立即更新视图布局的话，官方建议使用layoutIfNeeded</span><br><span class="line">刷新布局</span><br><span class="line"></span><br><span class="line">-setNeedsLayout标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用</span><br><span class="line"></span><br><span class="line">-layoutIfNeeded有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）</span><br><span class="line"></span><br><span class="line">如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局</span><br><span class="line"></span><br><span class="line">在视图第一次显示之前(frame不为CGRectZero)，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]</span><br></pre></td></tr></table></figure>

<h4 id="layoutSubviews方法调用先于drawRect"><a href="#layoutSubviews方法调用先于drawRect" class="headerlink" title="layoutSubviews方法调用先于drawRect"></a>layoutSubviews方法调用先于drawRect</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.view addSubview:self.oneView];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController One]</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[OneView drawRect:]</span><br></pre></td></tr></table></figure>

<h4 id="setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews"><a href="#setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews" class="headerlink" title="setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews"></a>setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[self.oneView  setNeedsLayout];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController Two]</span><br><span class="line">[OneView layoutSubviews]</span><br></pre></td></tr></table></figure>

<h4 id="layoutIfNeeded方法如其名，UIKit会判断subviews链中receiver是否需要layout，需要，则立即执行"><a href="#layoutIfNeeded方法如其名，UIKit会判断subviews链中receiver是否需要layout，需要，则立即执行" class="headerlink" title="layoutIfNeeded方法如其名，UIKit会判断subviews链中receiver是否需要layout，需要，则立即执行"></a>layoutIfNeeded方法如其名，UIKit会判断subviews链中receiver是否需要layout，需要，则立即执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.oneView setNeedsLayout];</span><br><span class="line">[self.oneView layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[ViewController Two]</span><br></pre></td></tr></table></figure>

<h4 id="layoutSubviews调用情况"><a href="#layoutSubviews调用情况" class="headerlink" title="layoutSubviews调用情况"></a>layoutSubviews调用情况</h4><h5 id="init初始化不会触发layoutSubviews"><a href="#init初始化不会触发layoutSubviews" class="headerlink" title="init初始化不会触发layoutSubviews"></a>init初始化不会触发layoutSubviews</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] init];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[self.view addSubview:oneView];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController One]</span><br></pre></td></tr></table></figure>

<h5 id="initWithFrame-进行初始化时，当rect的值不为CGRectZero才会触发"><a href="#initWithFrame-进行初始化时，当rect的值不为CGRectZero才会触发" class="headerlink" title="initWithFrame 进行初始化时，当rect的值不为CGRectZero才会触发"></a>initWithFrame 进行初始化时，当rect的值不为CGRectZero才会触发</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectZero];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[self.view addSubview:oneView];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController One]</span><br><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectMake(0, 340, 100, 100)];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[self.view addSubview:oneView];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController One]</span><br><span class="line">[OneView layoutSubviews]</span><br></pre></td></tr></table></figure>

<h5 id="addSubview会触发layoutSubviews"><a href="#addSubview会触发layoutSubviews" class="headerlink" title="addSubview会触发layoutSubviews"></a>addSubview会触发layoutSubviews</h5><ul>
<li>设置OneView的rect不为CGRectZero,不调用父类addSubview</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectMake(0, 340, 100, 100)];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController One]</span><br></pre></td></tr></table></figure>

<ul>
<li>设置OneView的rect不为CGRectZero后立即调用layoutIfNeeded,不调用父类addSubview</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectMake(0, 340, 100, 100)];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[oneView layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[ViewController One]</span><br></pre></td></tr></table></figure>

<ul>
<li>设置OneView的rect为CGRectZero后立即调用layoutIfNeeded,不调用父类addSubview</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectZero];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[oneView layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController One]</span><br></pre></td></tr></table></figure>

<ul>
<li>设置OneView的rect不为CGRectZero后立即调用layoutIfNeeded,延迟3.0f再调用父类addSubview</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectMake(0, 340, 100, 100)];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[oneView layoutIfNeeded];</span><br><span class="line">self.oneView &#x3D; oneView;</span><br><span class="line">[self performSelector:@selector(Two) withObject:nil afterDelay:3.0f];</span><br><span class="line">[self.view addSubview:self.oneView];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[ViewController One]</span><br><span class="line">[ViewController Two]</span><br><span class="line">[OneView drawRect:]</span><br></pre></td></tr></table></figure>

<ul>
<li>设置twoView的rect不为CGRectZero,调用addSubview</li>
</ul>
<p>On</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">eView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectMake(0, 340, 100, 100)];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[oneView layoutIfNeeded];</span><br><span class="line">[self.view addSubview:oneView];</span><br><span class="line">self.oneView &#x3D; oneView;</span><br><span class="line">[self performSelector:@selector(Two) withObject:nil afterDelay:3.0f];</span><br><span class="line"></span><br><span class="line">TwoView *twoView &#x3D; [[TwoView alloc] initWithFrame:CGRectMake(10, 10, 10, 10)];</span><br><span class="line">[self.oneView addSubview:twoView];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[ViewController One]</span><br><span class="line">[OneView drawRect:]</span><br><span class="line">[ViewController Two]</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[TwoView layoutSubviews]</span><br><span class="line">[TwoView drawRect:]</span><br></pre></td></tr></table></figure>



<ul>
<li>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectMake(0, 340, 100, 100)];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[self.view addSubview:oneView];</span><br><span class="line">self.oneView &#x3D; oneView;</span><br><span class="line">[self.oneView addSubview:self.twoView];</span><br><span class="line">[self performSelector:@selector(Two) withObject:nil afterDelay:3.0f];</span><br><span class="line">self.oneView.frame &#x3D; CGRectZero;</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController One]</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[TwoView layoutSubviews]</span><br><span class="line">[OneView drawRect:]</span><br><span class="line">[TwoView drawRect:]</span><br><span class="line">[ViewController Two]</span><br><span class="line">[OneView layoutSubviews]</span><br></pre></td></tr></table></figure>

<ul>
<li>滚动一个UIScrollView会触发layoutSubviews</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OneView为UIScrollView子类，滚动其会不断触发layoutSubviews</span><br><span class="line">Log:</span><br><span class="line">[OneView layoutSubviews]</span><br></pre></td></tr></table></figure>

<ul>
<li>旋转Screen会触发父UIView上的layoutSubviews事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OneView *oneView &#x3D; [[OneView alloc] initWithFrame:CGRectMake(0, 340, 100, 100)];</span><br><span class="line">oneView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[self.view addSubview:oneView];</span><br><span class="line">self.oneView &#x3D; oneView;</span><br><span class="line">[self.oneView addSubview:self.twoView];</span><br><span class="line"></span><br><span class="line">ThreeView *threeView &#x3D; [[ThreeView alloc] init];</span><br><span class="line">threeView.frame &#x3D; CGRectMake(200, 440, 100, 100);</span><br><span class="line">threeView.backgroundColor &#x3D; KRandomColor;</span><br><span class="line">[self.oneView addSubview:threeView];</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[ThreeView layoutSubviews]</span><br><span class="line">[TwoView layoutSubviews]</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[ThreeView layoutSubviews]</span><br><span class="line">[TwoView layoutSubviews]</span><br><span class="line"></span><br><span class="line">fromInterfaceOrientation&#x3D;&#x3D;3&#x3D;&#x3D;toInterfaceOrientation&#x3D;&#x3D;1</span><br></pre></td></tr></table></figure>

<ul>
<li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[self.oneView addSubview:self.twoView];</span><br><span class="line">[self.oneView addSubview:self.threeView];</span><br><span class="line"></span><br><span class="line">self.twoView.frame &#x3D; CGRectZero;</span><br><span class="line">self.threeView.frame &#x3D; CGRectMake(200, 340, 100, 200);</span><br><span class="line"></span><br><span class="line">Log:</span><br><span class="line">[ViewController Two]</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[TwoView layoutSubviews]</span><br><span class="line">[ViewController Four]</span><br><span class="line">[OneView layoutSubviews]</span><br><span class="line">[ThreeView layoutSubviews]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/02/27/iOS%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BMVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/iOS%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BMVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">iOS开发-基类设计：架构模式之MVC、MVP、MVVM架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 22:37:25 / Modified: 22:38:27" itemprop="dateCreated datePublished" datetime="2020-02-27T22:37:25+08:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在改造项目中的基类设计，侧重注意了一下基类的设计和使用。</p>
<h3 id="现存问题："><a href="#现存问题：" class="headerlink" title="现存问题："></a>现存问题：</h3><ul>
<li>ViewController承担任务过多，不易扩展变化，列表数据处理存在资源浪费</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 列表中已无更多数据还会进行网络请求，浪费资源</span><br><span class="line">2. 列表已经有可用数据，再进行第N页请求失败了,都会展示网络加载失败页面，无法展示之前有效数据</span><br><span class="line">3. 基类做了上拉下拉数据默认获取，有一定的方便性，但是也影响了数据的灵活组装</span><br><span class="line">4. 下拉加载、上拉获取，不同业务也有不确定性，不够通用的业务放在基类中反而增加了很多判断</span><br><span class="line">5. ViewController更新取决于监听ViewModel对于数据获取完后对Key改变</span><br></pre></td></tr></table></figure>

<ul>
<li>ViewModel业务承载过于单一，对于复杂业务无法进行拆分组装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 只能承载单个列表请求，业务复杂的列表，无法进行拆分后组装</span><br><span class="line">2. 网络请求分散于VM C各个地方，不便于统一开发规范</span><br></pre></td></tr></table></figure>

<h3 id="改造目的："><a href="#改造目的：" class="headerlink" title="改造目的："></a>改造目的：</h3><ol>
<li>聚合大量共有的常用业务逻辑，极大程度减少开发者冗余代码的产生，更加专注于自身模块的开发</li>
<li>采用协议的方式，让其他类可以去实现，一定程序上保证了开发规范</li>
</ol>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>关于基类架构设计，基于项目本身也是基于MVVM的模式，目前也准备沿用下去，对应着也了解一下Model、View、Controller/Presenter/ViewModel之间的关系，以及这三者组合而形成的多种设计模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVC（传统MVC、Cocoa MVC）</span><br><span class="line">MVP</span><br><span class="line">MVVM</span><br></pre></td></tr></table></figure>

<h3 id="Model-View-Controller简述"><a href="#Model-View-Controller简述" class="headerlink" title="Model View Controller简述"></a>Model View Controller简述</h3><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Model objects encapsulate the data specific to an application and define the logic and computation that manipulate and process that data. For example, a model object might represent a character in a game or a contact in an address book. A model object can have to-one and to-many relationships with other model objects, and so sometimes the model layer of an application effectively is one or more object graphs. Much of the data that is part of the persistent state of the application (whether that persistent state is stored in files or databases) should reside in the model objects after the data is loaded into the application. Because model objects represent knowledge and expertise related to a specific problem domain, they can be reused in similar problem domains. Ideally, a model object should have no explicit connection to the view objects that present its data and allow users to edit that data—it should not be concerned with user-interface and presentation issues.&quot;</span><br></pre></td></tr></table></figure>

<p>模型 - 封装特定于应用程序的数据，可以是单个对象，也可以是对象的某种结构，并定义操作和处理该数据的逻辑和计算。理想状态下，model与显示其数据或编辑其数据视图都没有直接关系，它不关心用户界面和展示情况</p>
<h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“A view object is an object in an application that users can see. A view object knows how to draw itself and can respond to user actions. A major purpose of view objects is to display data from the application’s model objects and to enable the editing of that data. Despite this, view objects are typically decoupled from model objects in an MVC application.</span><br><span class="line"></span><br><span class="line">Because you typically reuse and reconfigure them, view objects provide consistency between applications. Both the UIKit and AppKit frameworks provide collections of view classes, and Interface Builder offers dozens of view objects in its Library.”</span><br></pre></td></tr></table></figure>

<p>视图 - 作为UI的视觉展示，通常会突出model的某些属性，也会隐藏其他属性。View应明确知道该如何根据Model中的对象属性绘制自己，并响应用户操作对数据进行编辑。</p>
<p>虽然View看起来与Model应该是强关联，但通常View与Model是解耦的</p>
<h4 id="Controller-Presenter-ViewModel"><a href="#Controller-Presenter-ViewModel" class="headerlink" title="Controller/Presenter/ViewModel"></a>Controller/Presenter/ViewModel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“A controller object acts as an intermediary between one or more of an application’s view objects and one or more of its model objects. Controller objects are thus a conduit through which view objects learn about changes in model objects and vice versa. Controller objects can also perform setup and coordinating tasks for an application and manage the life cycles of other objects.”</span><br></pre></td></tr></table></figure>

<p>控制器 - 通常作为View与Model的中介，View通过其知道Model的变化，对应更新视图变化，Model通过其获知用户操作后需要进行的数据更新。</p>
<h3 id="Model-View-Controller-MVC"><a href="#Model-View-Controller-MVC" class="headerlink" title="Model-View-Controller(MVC)"></a>Model-View-Controller(MVC)</h3><h4 id="传统的MVC"><a href="#传统的MVC" class="headerlink" title="传统的MVC"></a><a href="https://en.wikipedia.org/wiki/Model–view–controller" target="_blank" rel="noopener">传统的MVC</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/5458052-2c6fb3f34f4d9ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="old_mvc"></p>
<ol>
<li>View从Model中获取数据的变化，进行状态更新</li>
<li>Model负责数据管理，通知View更新UI</li>
<li>Controller响应用户输入并对数据模型对象执行更新</li>
</ol>
<blockquote>
</blockquote>
<p>简单来看，其符合View、Model、Controller特性设计，但三者之间均存在通讯，紧密耦合，大大降低了三者之间的复用性。</p>
<h4 id="Cocoa-MVC"><a href="#Cocoa-MVC" class="headerlink" title="Cocoa MVC"></a><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14" target="_blank" rel="noopener">Cocoa MVC</a></h4><p>基于传统MVC过于古老，且不太实用于当下的iOS开发，苹果设计出一套Cocoa MVC模式，进行解耦View 与 Model</p>
<h5 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h5><p>Controller作为中介器协调View与Model，View与Model完全解耦</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5458052-2c6fb3f34f4d9ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="cocoa_mvc"></p>
<h5 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h5><p>Controller需要承担代理、数据源、分发取消网络和一系列其他的任务，通常过于臃肿<br>View只作为传递用户动作事件而存在</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5458052-d8e29878d1167f47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt="cocoa_mvc2"></p>
<p>Controller与View是紧密耦合的，直接导致对他们进行测试是很艰难的（需要模拟View和它们的生命周期），业务代码也逐渐的被分散到View布局代码中，View的复用也变得极其艰难，当有类似View出现时，要么我们将在View中写很多逻辑控制，要么我们将舍弃复用而再维护一个类似的View，造成很多的代码冗余</p>
<h4 id="综上特性"><a href="#综上特性" class="headerlink" title="综上特性"></a>综上特性</h4><ul>
<li>View与Model进行了解耦，Model可方便进行单元测试和复用</li>
<li>Controller与View紧密耦合,Controller承担任务过重，过于臃肿</li>
<li>不熟悉的开发人员也能快速上手</li>
</ul>
<h3 id="MVP-Model-view-presenter"><a href="#MVP-Model-view-presenter" class="headerlink" title="MVP(Model-view-presenter)"></a><a href="https://en.wikipedia.org/wiki/Model–view–presenter" target="_blank" rel="noopener">MVP(Model-view-presenter)</a></h3><p>MVP是基于MVC架构模式的一种派生模式，更加适用于构建用户交互，旨在促进自动化单元测试。<br>MVP定义出一种“中介者”角色，所有的协调更新逻辑都可交由Present来处理</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/d/dc/Model_View_Presenter_GUI_Design_Pattern.png" alt="MVP"></p>
<ul>
<li>Model定义要在用户界面中显示以及操作的数据接口</li>
<li>View由Model驱动显示数据并将用户操作事件告知给“中介者”</li>
<li>Presenter根据模型和视图进行操作，从Model中检索数据，并将其进行处理后驱动在View中展示</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5458052-655c18035e28aab5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt="MVP"></p>
<p>看起来MVP是更加符合苹果愿景的用户界面架构模式，Presenter在此只负责更新View的数据和状态，并不关注Controller的生命周期，就MVP而言，如果把Controller的子类看作Views，我们的可测试性将极大的提高，但相应的开发速度可能会有一些降低，因为必须要做一些手动的数据和事件的绑定。</p>
<ol>
<li>View/Controller与Model解耦，功能简单，便于测试</li>
<li>代码量大，所有的更新传递数据操作都要通过Presenter，但是概念清晰，职责明确</li>
</ol>
<h3 id="MVVM（Model-View-ViewModel）"><a href="#MVVM（Model-View-ViewModel）" class="headerlink" title="MVVM（Model-View-ViewModel）"></a><a href="https://en.wikipedia.org/wiki/Model–view–viewmodel" target="_blank" rel="noopener">MVVM（Model-View-ViewModel）</a></h3><p>MVVM 同样也是一种派生自MVC的设计模式，它将用户界面展示与后端逻辑分离开来，ViewModel作为一个转换器，负责管理Model的转换以及View的更新，用于处理大部分视图的显示逻辑、Model的转换逻辑、对于后端数据的访问逻辑<br><img src="https://upload.wikimedia.org/wikipedia/commons/8/87/MVVMPattern.png" alt="MVVM"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q:ViewModel在iOS中ViewModel实际上代表什么？</span><br><span class="line"></span><br><span class="line">A:它基本上就是UIKit下的每个控件以及控件的状态。ViewModel调用会改变Model同时会将Model的改变更新到自身并且因为我们绑定了View和ViewModel，第一步就是相应的更新状态。</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1874977-9bab0f07280d0134.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="MVVM"></p>
<ul>
<li>Model 数据对象（数据处理可通过自身提供接口，也可添加分类来扩展业务逻辑）</li>
<li>View（View+Controller），负责UI展示，绑定viewModel，触发viewModel中提供的命令以及呈现viewModel提供的数据</li>
<li>View-Model 负责从Model获取View所需的数据，转换成View可以展示的数据，并暴露公开的属性和命令提供给view进行绑定</li>
<li>Binder 在MVVM中，声明性数据和命令绑定是隐式的。它可以使开发者非常方便的实现View与ViewModel的同步，避免编写大量烦杂的样板话的代码。</li>
</ul>
<hr>
<h4 id="iOS中基于Binder的两种方案："><a href="#iOS中基于Binder的两种方案：" class="headerlink" title="iOS中基于Binder的两种方案："></a>iOS中基于Binder的两种方案：</h4><p>基于KVO的绑定库如<a href="https://github.com/Rightpoint/RZDataBinding" target="_blank" rel="noopener">RZDataBinding</a>和<a href="https://github.com/DeclarativeHub/Bond" target="_blank" rel="noopener">SwiftBond</a></p>
<p>完全的函数响应式编程，比如像<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>、<a href="https://github.com/ReactiveX/RxSwift/" target="_blank" rel="noopener">RxSwift</a>或者<a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a></p>
<hr>
<h4 id="MVVM模块层级图"><a href="#MVVM模块层级图" class="headerlink" title="MVVM模块层级图"></a>MVVM模块层级图</h4><p><img src="https://upload-images.jianshu.io/upload_images/1874977-f8c57cfd22113349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675" alt="MVVM模块层级图"></p>
<h4 id="综上特性-1"><a href="#综上特性-1" class="headerlink" title="综上特性"></a>综上特性</h4><ul>
<li>任务均摊 – 在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。</li>
<li>可测试性 – ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。</li>
<li>易用性 – 必须把View中的事件指向Presenter并且手动的来更新View，如果使用绑定的话，MVVM代码量将会小的多。</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="noopener">View、Model、Controller相关定义</a></p>
<p><a href="https://en.wikipedia.org/wiki/Model–view–controller" target="_blank" rel="noopener">传统MVC</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14" target="_blank" rel="noopener">Cocoa MVC</a></p>
<p><a href="https://en.wikipedia.org/wiki/Model–view–presenter" target="_blank" rel="noopener">MVP</a></p>
<p><a href="https://en.wikipedia.org/wiki/Model–view–viewmodel" target="_blank" rel="noopener">MVVM</a></p>
<p><a href="https://www.jianshu.com/p/ed9fd8a9e2d4" target="_blank" rel="noopener">iOS开发-进阶:架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a></p>
<p><a href="https://www.jianshu.com/p/db8400e1d40e" target="_blank" rel="noopener">iOS 关于MVVM Without ReactiveCocoa设计模式的那些事</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/02/27/BeeHive-%E7%BB%84%E4%BB%B6%E5%8C%96Protoco-impClass%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/BeeHive-%E7%BB%84%E4%BB%B6%E5%8C%96Protoco-impClass%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" class="post-title-link" itemprop="url">BeeHive-组件化Protoco-impClass具体应用实例</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-27 22:29:19" itemprop="dateCreated datePublished" datetime="2020-02-27T22:29:19+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-05 21:31:44" itemprop="dateModified" datetime="2020-03-05T21:31:44+08:00">2020-03-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>BeeHive是基于Spring的Service理念，可以使模块间的具体实现与接口解耦。</p>
<p>目前BeeHive v1.2.0 全部是利用Protocol的方式，实现了模块间解耦的目的：</p>
<p>1.各个模块以插件的形式存在。每个都可独立，相互解耦。</p>
<p>2.各个模块具体实现与接口调用分离</p>
<p>3.各个模块也有生命周期，也可以进行管理。</p>
<h3 id="官方架构图"><a href="#官方架构图" class="headerlink" title="官方架构图"></a>官方架构图</h3><p><img src="http://q6luryr3j.bkt.clouddn.com/04.png" alt="img"></p>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p><img src="http://q6luryr3j.bkt.clouddn.com/01.jpeg" alt="img"></p>
<ol>
<li>各个功能模块以protocol为key，以impClass为Value注册添加到Core 中</li>
<li>模块间、应用事件调用通过注册的ServiceProtocol进行</li>
<li>ModuleProtocol可调用应用事件和系统事件</li>
</ol>
<h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><p><img src="http://q6luryr3j.bkt.clouddn.com/image2019-12-4_15-36-40.png" alt="img"></p>
<p>【调用者】发起调用—&gt;传递调用标示（当前protocol）—&gt;告知中间件需要调用哪个组件</p>
<p>【中间层】根据调用者传递表示，返回目标组件句柄</p>
<p>【调用组件】根据调用者持有的目标组件句柄，遵循调用</p>
<h3 id="调用标示与组件一一对应"><a href="#调用标示与组件一一对应" class="headerlink" title="调用标示与组件一一对应"></a>调用标示与组件一一对应</h3><ul>
<li><p>生成映射关系</p>
<p>BeeHive使用protocol-impClass方式来表示上文所说的映射关系，protocol表示目标组件对应暴露的方法，impClass表示目标组件的句柄</p>
</li>
<li><p>存储映射关系</p>
<p>BeeHive内部使用一个可变字典来存储protocol-impClass，其中以protocol为key，impClass作为Value</p>
</li>
<li><p>获取目标句柄</p>
<p>BeeHive在调用组件时，调用者将目标组件的协议protocol作为参数传递给BeeHive，然后BeeHive返回对应的组件句柄impClass</p>
</li>
</ul>
<h2 id="Module模块"><a href="#Module模块" class="headerlink" title="Module模块"></a>Module模块</h2><h3 id="模块事件"><a href="#模块事件" class="headerlink" title="模块事件"></a>模块事件</h3><p><code>BeeHive</code>会给每个模块提供生命周期事件，用于与<code>BeeHive</code>宿主环境进行必要信息交互，感知模块生命周期的变化。</p>
<p>事件分为三种类型：</p>
<ul>
<li>系统事件</li>
<li>通用事件</li>
<li>业务自定义事件</li>
</ul>
<h4 id="系统事件"><a href="#系统事件" class="headerlink" title="系统事件"></a>系统事件</h4><p>系统事件通常指Application生命周期事件，例如DidBecomeActive、WillEnterBackground等。</p>
<p>系统事件基本工作流程图：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/03.jpeg" alt="img"></p>
<h4 id="通用事件"><a href="#通用事件" class="headerlink" title="通用事件"></a>通用事件</h4><p>在系统事件的基础之上，扩展了应用的通用事件，例如<code>modSetup</code>、<code>modInit</code>等，可以用于编码实现各插件模块的设置与初始化。</p>
<p>扩展的通用事件如下：</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/02.jpeg" alt="img"></p>
<h4 id="业务自定义事件"><a href="#业务自定义事件" class="headerlink" title="业务自定义事件"></a>业务自定义事件</h4><p>如果觉得系统事件、通用事件不足以满足需要，我们还将事件封装简化成<code>BHAppdelgate</code>，你可以通过继承BHAppdelegate`来扩展自己的事件。</p>
<p>自定义的事件的type就是BHMDidCustomEvent = 1000</p>
<h4 id="BeeHive事件-BHModuleEventType"><a href="#BeeHive事件-BHModuleEventType" class="headerlink" title="BeeHive事件(BHModuleEventType)"></a>BeeHive事件(BHModuleEventType)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, BHModuleEventType)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;通用事件</span><br><span class="line">    BHMSetupEvent &#x3D; 0,</span><br><span class="line">    BHMInitEvent,&#x2F;&#x2F;特殊事件</span><br><span class="line">    BHMTearDownEvent,&#x2F;&#x2F;特殊事件</span><br><span class="line">    BHMSplashEvent,&#x2F;&#x2F;通用事件</span><br><span class="line">  </span><br><span class="line">  	&#x2F;&#x2F;3D-Touch</span><br><span class="line">    BHMQuickActionEvent,</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;生命周期</span><br><span class="line">    BHMWillResignActiveEvent,</span><br><span class="line">    BHMDidEnterBackgroundEvent,</span><br><span class="line">    BHMWillEnterForegroundEvent,</span><br><span class="line">    BHMDidBecomeActiveEvent,</span><br><span class="line">    BHMWillTerminateEvent,</span><br><span class="line">  </span><br><span class="line">  	&#x2F;&#x2F;未使用</span><br><span class="line">    BHMUnmountEvent,</span><br><span class="line">    BHMOpenURLEvent,</span><br><span class="line">    BHMDidReceiveMemoryWarningEvent,</span><br><span class="line">  </span><br><span class="line">  	&#x2F;&#x2F;推送相关事件</span><br><span class="line">    BHMDidFailToRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidReceiveRemoteNotificationEvent,</span><br><span class="line">    BHMDidReceiveLocalNotificationEvent,</span><br><span class="line">    BHMWillPresentNotificationEvent,</span><br><span class="line">    BHMDidReceiveNotificationResponseEvent,</span><br><span class="line">  </span><br><span class="line"> 		&#x2F;&#x2F;handoff和相关事件</span><br><span class="line">    BHMWillContinueUserActivityEvent,</span><br><span class="line">    BHMContinueUserActivityEvent,</span><br><span class="line">    BHMDidFailToContinueUserActivityEvent,</span><br><span class="line">    BHMDidUpdateUserActivityEvent,</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;watchApp请求事件</span><br><span class="line">    BHMHandleWatchKitExtensionRequestEvent,</span><br><span class="line">    </span><br><span class="line">    BHMDidCustomEvent &#x3D; 1000&#x2F;&#x2F; 自定义业务事件</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="处理系统事件"><a href="#处理系统事件" class="headerlink" title="处理系统事件"></a>处理系统事件</h4><p>系统的事件会被传递给每个模块，让每个模块自己决定编写业务处理逻辑，比如<code>3D-Touch</code>功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3D-Touch功能</span><br><span class="line">- (void)modQuickAction:(BHContext *)context &#123;</span><br><span class="line">    &#x2F;&#x2F; 模块处理</span><br><span class="line">    [BHRouter openURL:[NSURL URLWithString:BHRUsageRegister] withParams:@&#123;@&quot;params&quot;:@&#123;@&quot;user_id&quot;:@&quot;11111&quot;&#125;&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊事件"><a href="#特殊事件" class="headerlink" title="特殊事件"></a>特殊事件</h4><h5 id="BHMInitEvent——初始化Module模块调用modInit-事件"><a href="#BHMInitEvent——初始化Module模块调用modInit-事件" class="headerlink" title="BHMInitEvent——初始化Module模块调用modInit:事件"></a>BHMInitEvent——初始化Module模块调用modInit:事件</h5><p>在处理Module事件时，当事件类型BHMInitEvent时，会依次遍历BHModules数组，依次对每个Module实例调用modInit:方法。这里会有异步加载的问题。如果moduleInstance重写了async方法，那么就会根据这个方法返回的值来进行是否异步加载的判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModulesInitEventForTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">                        withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    BHContext *context &#x3D; [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam &#x3D; customParam;</span><br><span class="line">    context.customEvent &#x3D; BHMInitEvent;</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances &#x3D; @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances &#x3D; [self.BHModulesByEvent objectForKey:@(BHMInitEvent)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        __weak typeof(&amp;*self) wself &#x3D; self;</span><br><span class="line">        void ( ^ bk )(void);</span><br><span class="line">        bk &#x3D; ^()&#123;</span><br><span class="line">            __strong typeof(&amp;*self) sself &#x3D; wself;</span><br><span class="line">            if (sself) &#123;</span><br><span class="line">                if ([moduleInstance respondsToSelector:@selector(modInit:)]) &#123;</span><br><span class="line">                    [moduleInstance modInit:context];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- modInit:&quot;, [moduleInstance class]]];</span><br><span class="line">        </span><br><span class="line">        if ([moduleInstance respondsToSelector:@selector(async)]) &#123;</span><br><span class="line">            BOOL async &#x3D; [moduleInstance async];</span><br><span class="line">            </span><br><span class="line">            if (async) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    bk();</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bk();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体场景可分为：</p>
<ol>
<li><p>根据环境的不同初始化不同的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)modInit:(BHContext *)context &#123;</span><br><span class="line">    switch (context.env) &#123;</span><br><span class="line">        case BHEnvironmentDev:</span><br><span class="line">            &#x2F;&#x2F;....初始化开发环境</span><br><span class="line">            break;</span><br><span class="line">        case BHEnvironmentProd:</span><br><span class="line">            &#x2F;&#x2F;....初始化生产环境</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在初始化的时候注册一些协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)modInit:(BHContext *)context &#123;</span><br><span class="line">  [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="BHMTearDownEvent——拆除事件"><a href="#BHMTearDownEvent——拆除事件" class="headerlink" title="BHMTearDownEvent——拆除事件"></a>BHMTearDownEvent——拆除事件</h5><p>倒叙遍历当前Module中所有事件，调用modInit:事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModulesTearDownEventForTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">                            withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    BHContext *context &#x3D; [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam &#x3D; customParam;</span><br><span class="line">    context.customEvent &#x3D; BHMTearDownEvent;</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances &#x3D; @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances &#x3D; [self.BHModulesByEvent objectForKey:@(BHMTearDownEvent)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Reverse Order to unload</span><br><span class="line">    for (int i &#x3D; (int)moduleInstances.count - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        id&lt;BHModuleProtocol&gt; moduleInstance &#x3D; [moduleInstances objectAtIndex:i];</span><br><span class="line">        if (moduleInstance &amp;&amp; [moduleInstance respondsToSelector:@selector(modTearDown:)]) &#123;</span><br><span class="line">            [moduleInstance modTearDown:context];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><h5 id="通过配置BHContext指定本地moduleConfigName配置文件"><a href="#通过配置BHContext指定本地moduleConfigName配置文件" class="headerlink" title="通过配置BHContext指定本地moduleConfigName配置文件"></a>通过配置BHContext指定本地moduleConfigName配置文件</h5><ol>
<li><p>指定文件读取路径</p>
<p>[BHContext shareInstance].moduleConfigName = @“BeeHive.bundle/BeeHive.plist”</p>
</li>
<li><p>配置文件格式</p>
<p><img src="http://q6luryr3j.bkt.clouddn.com/image-20200227230948167.png" alt="img"></p>
</li>
<li><p>读取文件内容，将其读取存入内存字段BHModuleInfos中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)loadLocalModules &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *moduleList &#x3D; [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 加载模块文件</span><br><span class="line">    NSArray&lt;NSDictionary *&gt; *modulesArray &#x3D; [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass &#x3D; @&#123;&#125;.mutableCopy;</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; 标记当前模块已被加载</span><br><span class="line">        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];</span><br><span class="line">    &#125;];</span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            [self.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="API注册"><a href="#API注册" class="headerlink" title="API注册"></a>API注册</h5><p>将其添加到内存BHModuleInfos字段中，BHModuleInfos是一个NSMutableArray，里面存的都是一个个的字典，字典里面有两个Key，一个是@”moduleLevel”，另一个是@”moduleClass”。存储已经注册的Module的时候都要判断Level。还有一点需要说明的，所有需要注册的Module必须遵循BHModuleProtocol协议，否则不能被存储。</p>
<ol>
<li>遍历BHModules 判断当前object类 类型是否已存在BHModules中</li>
<li>校验当前Class是否实现BHModuleProtocol的协议方法</li>
<li>初始化moduleInfo将其添加到BHModuleInfos 中，实例化obj 将其添加到BHModules中，设置已添加标示</li>
<li>遍历BHModules中所有Module,将其中moduleInstance进行排序</li>
<li>根据shouldTriggerInitEvent判断是否需要立即触发初始化方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">- (void)addModuleFromObject:(id)object</span><br><span class="line">     shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent &#123;</span><br><span class="line">    Class class;</span><br><span class="line">    NSString *moduleName &#x3D; nil;</span><br><span class="line">    </span><br><span class="line">    if (object) &#123;</span><br><span class="line">        class &#x3D; object;</span><br><span class="line">        moduleName &#x3D; NSStringFromClass(class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历BHModules 判断当前object类 类型是否已存在BHModules中</span><br><span class="line">    __block BOOL flag &#x3D; YES;</span><br><span class="line">    [self.BHModules enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([obj isKindOfClass:class]) &#123;</span><br><span class="line">            flag &#x3D; NO;</span><br><span class="line">            *stop &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    if (!flag) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 校验当前Class是否遵循BHModuleProtocol的协议方法</span><br><span class="line">    if ([class conformsToProtocol:@protocol(BHModuleProtocol)]) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 构建字典moduleInfo</span><br><span class="line">        NSMutableDictionary *moduleInfo &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">        BOOL responseBasicLevel &#x3D; [class instancesRespondToSelector:@selector(basicModuleLevel)];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 默认初始化level为1，判断是否需要更改</span><br><span class="line">        int levelInt &#x3D; 1;</span><br><span class="line">        if (responseBasicLevel) &#123;</span><br><span class="line">            levelInt &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        [moduleInfo setObject:@(levelInt) forKey:kModuleInfoLevelKey];</span><br><span class="line">        </span><br><span class="line">        if (moduleName) &#123;</span><br><span class="line">            [moduleInfo setObject:moduleName forKey:kModuleInfoNameKey];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将其添加到BHModuleInfos 中，</span><br><span class="line">        [self.BHModuleInfos addObject:moduleInfo];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 实例化obj 将其添加到BHModules中，设置已初始化标示</span><br><span class="line">        id&lt;BHModuleProtocol&gt; moduleInstance &#x3D; [[class alloc] init];</span><br><span class="line">        [self.BHModules addObject:moduleInstance];</span><br><span class="line">        [moduleInfo setObject:@(YES) forKey:kModuleInfoHasInstantiatedKey];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 遍历BHModules中所有Module,将其中moduleInstance根据basicModuleLevel（0 1）进行排序，相同情况下再根据modulePriority进行排序（1 0）</span><br><span class="line">        [self.BHModules sortUsingComparator:^NSComparisonResult(id&lt;BHModuleProtocol&gt; moduleInstance1, id&lt;BHModuleProtocol&gt; moduleInstance2) &#123;</span><br><span class="line">            NSNumber *module1Level &#x3D; @(BHModuleNormal);</span><br><span class="line">            NSNumber *module2Level &#x3D; @(BHModuleNormal);</span><br><span class="line">            if ([moduleInstance1 respondsToSelector:@selector(basicModuleLevel)]) &#123;</span><br><span class="line">                module1Level &#x3D; @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            if ([moduleInstance2 respondsToSelector:@selector(basicModuleLevel)]) &#123;</span><br><span class="line">                module2Level &#x3D; @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            if (module1Level.integerValue !&#x3D; module2Level.integerValue) &#123;</span><br><span class="line">                return module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSInteger module1Priority &#x3D; 0;</span><br><span class="line">                NSInteger module2Priority &#x3D; 0;</span><br><span class="line">                if ([moduleInstance1 respondsToSelector:@selector(modulePriority)]) &#123;</span><br><span class="line">                    module1Priority &#x3D; [moduleInstance1 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                if ([moduleInstance2 respondsToSelector:@selector(modulePriority)]) &#123;</span><br><span class="line">                    module2Priority &#x3D; [moduleInstance2 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                return module1Priority &lt; module2Priority;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        &#x2F;&#x2F; 注册模块，将module注册添加到BHModulesByEvent中</span><br><span class="line">        [self registerEventsByModuleInstance:moduleInstance];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 是否需要立即触发BHMSetupEvent事件</span><br><span class="line">        if (shouldTriggerInitEvent) &#123;</span><br><span class="line">            [self handleModuleEvent:BHMSetupEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];</span><br><span class="line">            [self handleModulesInitEventForTarget:moduleInstance withCustomParam:nil];</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [self handleModuleEvent:BHMSplashEvent forTarget:moduleInstance withSeletorStr:nil andCustomParam:nil];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Load方法注册，BH-EXPORT-MODULE宏定义"><a href="#Load方法注册，BH-EXPORT-MODULE宏定义" class="headerlink" title="Load方法注册，BH_EXPORT_MODULE宏定义"></a>Load方法注册，BH_EXPORT_MODULE宏定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BH_EXPORT_MODULE(isAsync) \</span><br><span class="line">+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \</span><br><span class="line">-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><h5 id="通过读取存储在数据段中的数据进行注册"><a href="#通过读取存储在数据段中的数据进行注册" class="headerlink" title="通过读取存储在数据段中的数据进行注册"></a>通过读取存储在数据段中的数据进行注册</h5><ol>
<li><h6 id="存储数据到数据段"><a href="#存储数据到数据段" class="headerlink" title="存储数据到数据段"></a>存储数据到数据段</h6><p>通过BeeHiveMod(DiaryModule)宏进行注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef BeehiveModSectName</span><br><span class="line">#define BeehiveModSectName &quot;BeehiveMods&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</span><br><span class="line"></span><br><span class="line">#define BeeHiveMod(name) \</span><br><span class="line">class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) &#x3D; &quot;&quot;#name&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>BeeHiveDATA 宏定会将数据存储到__DATA数据段中中指定的sectname字段中</p>
<p>BeeHiveMod(MMDoubanModule)  在预编译完成后，会变为</p>
<p>class BeeHive; char * kMMDoubanModule_mod BeeHiveDATA(BeehiveMods) = “””MMDoubanModule”””</p>
<p>也就相当于</p>
<p>char * kMMDoubanModule_mod = “””MMDoubanModule”””;</p>
</li>
<li><h6 id="使用预编译指令进行简单验证"><a href="#使用预编译指令进行简单验证" class="headerlink" title="使用预编译指令进行简单验证"></a>使用预编译指令进行简单验证</h6><p>新建beeHive_macro.c文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BeeHiveDATA(sectname) __attribute((used, section(<span class="meta-string">"__DATA, "</span>#sectname<span class="meta-string">" "</span>)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BeeHiveMod(name) \</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeeHive</span>;</span> <span class="keyword">char</span> * k#<span class="meta">#name##_mod BeeHiveDATA(BeehiveMods) = <span class="meta-string">""</span>#name<span class="meta-string">""</span>;</span></span><br><span class="line"></span><br><span class="line">@BeeHiveMod(MMDoubanModule)</span><br></pre></td></tr></table></figure>

<p>执行预编译指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -E beeHive_macro.c</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@class BeeHive; char * kMMDoubanModule_mod __attribute((used, section("__DATA, ""BeehiveMods"" "))) = """MMDoubanModule""";</span><br></pre></td></tr></table></figure>

<p>上述输出中，<code>__attribute((used, section(&quot;__DATA, &quot;&quot;BeehiveMods&quot;&quot; &quot;)))</code>表示在项目的mach-o文件的名字为<code>__DATA</code>的segment中添加一个名字为<code>BeehiveMods</code>的section，并将其值设置为字符串<code>&quot;MMDoubanModule&quot;</code>。</p>
</li>
</ol>
</li>
</ol>
<pre><code>实用otool命令验证，mach-o文件，输出mach-o文件的所有segment和section

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -l demo.o</span><br></pre></td></tr></table></figure>

输出内容，内容很多，只截取我们需要部分

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Section</span><br><span class="line">  sectname BeehiveMods</span><br><span class="line">   segname __DATA</span><br><span class="line">      addr 0x0000000100002018</span><br><span class="line">      size 0x0000000000000008</span><br><span class="line">    offset 8216</span><br><span class="line">     align 2^3 (8)</span><br><span class="line">    reloff 0</span><br><span class="line">    nreloc 0</span><br><span class="line">     flags 0x00000000</span><br><span class="line"> reserved1 0</span><br><span class="line"> reserved2 0</span><br></pre></td></tr></table></figure>

在mach-o文件中确实存在`BeehiveMods`这个section，接下来，继续验证这个section中的值是否是字符串`&quot;ModuleAModule&quot;`

查看section内容

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -s __DATA BeehiveMods demo.o</span><br></pre></td></tr></table></figure>

输出内容：

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Contents of (__DATA,BeehiveMods) section</span><br><span class="line">0000000100002018	92 0f 00 00 01 00 00 00</span><br></pre></td></tr></table></figure>

上述输出表示，section内部包含了地址92 0f 00 00 01 00 00 00， 地址指向的就是字符串`&quot;MMDoubanModule&quot;`



为了进一步验证，可以查看.o文件中segment为__TEXT section为 __cstring的内容

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -V -s __TEXT __cstring</span><br></pre></td></tr></table></figure>

输出如下：

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Contents of (__TEXT,__cstring) section</span><br><span class="line">0000000100000f92  MMDoubanModule</span><br><span class="line">0000000100000fa1  Hello, World!</span><br></pre></td></tr></table></figure>

可以看出地址0000000100000f92 对应的字符串就是MMDoubanModule，可以验证MMDoubanModule确实被存储在了section中。</code></pre><ol start="3">
<li><h6 id="通过BHReadConfiguration读取-Data段中的字符串"><a href="#通过BHReadConfiguration读取-Data段中的字符串" class="headerlink" title="通过BHReadConfiguration读取__Data段中的字符串"></a>通过BHReadConfiguration读取__Data段中的字符串</h6><p>BeeHive在文件<code>BHAnnotation.m</code>中注册了一个函数<code>dyld_callback</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个函数被<code>__attribute__((constructor))</code>修饰时，表示这个函数是这个image的初始化函数，在image被加载时，首先会调用这个函数。（image指的是mach-o和动态共享库，在工程运行时，可以使用lldb命令<code>image list</code>查看这个工程中加载的所有image。）</p>
<p>上述代码表示<code>initProphet</code>函数被指定为mach-o的初始化函数，当dyld（动态链接器）加载mach-o时，执行<code>initProphet</code>函数，其执行时机在man函数和类的<code>load</code>方法之前。</p>
<p>当<code>_dyld_register_func_for_add_image(dyld_callback);</code>被执行时，如果已经加载了image，则每存在一个已经加载的image就执行一次<code>dyld_callback</code>函数，在此之后，每当有一个新的image被加载时，也会执行一次<code>dyld_callback</code>函数。</p>
<p>（<code>dyld_callback</code>函数在image的初始化函数之前被调用，mach-o是第一个被加载的image，调用顺序是：load mach-o -&gt; initProphet -&gt; dyld_callback -&gt; load other_image -&gt; dyld_callback -&gt; other_image_initializers -&gt; ……）</p>
<p>所以，当程序启动时，会多次调用<code>dyld_callback</code>函数。</p>
</li>
<li><h6 id="通过getsectiondata函数从数据段中取出数据"><a href="#通过getsectiondata函数从数据段中取出数据" class="headerlink" title="通过getsectiondata函数从数据段中取出数据"></a>通过getsectiondata函数从数据段中取出数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern uint8_t *getsectiondata(</span><br><span class="line">    const struct mach_header_64 *mhp,</span><br><span class="line">    const char *segname,</span><br><span class="line">    const char *sectname,</span><br><span class="line">    unsigned long *size);</span><br></pre></td></tr></table></figure>

<p>segname的值为<code>__DATA</code>，sectname的值为<code>BeehiveMods</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从数据段__data__中取出数据</span><br><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp) &#123;</span><br><span class="line">    NSMutableArray *configs &#x3D; [NSMutableArray array];</span><br><span class="line">    unsigned long size &#x3D; 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 &#x3D; (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter &#x3D; size&#x2F;sizeof(void*);</span><br><span class="line">    for(int idx &#x3D; 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string &#x3D; (char*)memory[idx];</span><br><span class="line">        NSString *str &#x3D; [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config &#x3D; %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    return configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h6 id="调用registerDynamicModule注册方法将其添加到BHModuleInfos数组中"><a href="#调用registerDynamicModule注册方法将其添加到BHModuleInfos数组中" class="headerlink" title="调用registerDynamicModule注册方法将其添加到BHModuleInfos数组中"></a>调用registerDynamicModule注册方法将其添加到BHModuleInfos数组中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide) &#123;</span><br><span class="line">    NSArray *mods &#x3D; BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    for (NSString *modName in mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (modName) &#123;</span><br><span class="line">            cls &#x3D; NSClassFromString(modName);</span><br><span class="line">            if (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h6 id="调用API进行注册到BHModuleInfos中"><a href="#调用API进行注册到BHModuleInfos中" class="headerlink" title="调用API进行注册到BHModuleInfos中"></a>调用API进行注册到BHModuleInfos中</h6></li>
</ol>
<h2 id="Service注册"><a href="#Service注册" class="headerlink" title="Service注册"></a>Service注册</h2><h3 id="静态注册-1"><a href="#静态注册-1" class="headerlink" title="静态注册"></a>静态注册</h3><h4 id="通过配置BHContext指定本地serviceConfigName"><a href="#通过配置BHContext指定本地serviceConfigName" class="headerlink" title="通过配置BHContext指定本地serviceConfigName"></a>通过配置BHContext指定本地serviceConfigName</h4><ol>
<li><p>指定文件读取路径</p>
<p>[BHContext shareInstance].serviceConfigName = @”BeeHive.bundle/BHService.plist”</p>
</li>
<li><p>配置文件格式</p>
<img src="http://q6luryr3j.bkt.clouddn.com/image-20200228173020182.png" alt="image-20200228173020182" style="zoom:80%;" />
</li>
<li><p>读取文件，形成protocolKey:protocolImplClass映射关系，将其Add到allServicesDict字典中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerLocalServices &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *serviceConfigName &#x3D; [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    NSString *plistPath &#x3D; [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (!plistPath) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray *serviceList &#x3D; [[NSArray alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 读取plist的文件</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    for (NSDictionary *dict in serviceList) &#123;</span><br><span class="line">        NSString *protocolKey &#x3D; [dict objectForKey:@&quot;service&quot;];</span><br><span class="line">        NSString *protocolImplClass &#x3D; [dict objectForKey:@&quot;impl&quot;];</span><br><span class="line">        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;</span><br><span class="line">            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="API注册-1"><a href="#API注册-1" class="headerlink" title="API注册"></a>API注册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册protocol与目标句柄</span><br><span class="line">- (void)registerService:(Protocol *)service implClass:(Class)implClass &#123;</span><br><span class="line">    </span><br><span class="line">    NSParameterAssert(service !&#x3D; nil);</span><br><span class="line">    NSParameterAssert(implClass !&#x3D; nil);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 校验当前目标句柄是否遵守协议</span><br><span class="line">    if (![implClass conformsToProtocol:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ module does not comply with %@ protocol&quot;, NSStringFromClass(implClass), NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 检测当前service是否已经注册</span><br><span class="line">    if ([self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol has been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *key &#x3D; NSStringFromProtocol(service);</span><br><span class="line">    NSString *value &#x3D; NSStringFromClass(implClass);</span><br><span class="line">    if (key.length &gt; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        [self.lock lock];</span><br><span class="line">        [self.allServicesDict addEntriesFromDictionary:@&#123;key:value&#125;];</span><br><span class="line">        [self.lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态注册-1"><a href="#动态注册-1" class="headerlink" title="动态注册"></a>动态注册</h3><h4 id="BeeHiveService宏注册"><a href="#BeeHiveService宏注册" class="headerlink" title="BeeHiveService宏注册"></a>BeeHiveService宏注册</h4><ol>
<li><p>BeeHiveService宏定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</span><br><span class="line"></span><br><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line">class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) &#x3D; &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</span><br></pre></td></tr></table></figure>

<p>BeeHiveDATA 宏定会将数据存储到__DATA数据段中中指定的sectname字段中</p>
<p>BeeHiveService(MMDouBanProtocol,MMDouBanModule)最终宏在预编译完成后会变为</p>
<p>char * kMMDouBanProtocol_service <strong>attribute((used, section(“</strong>DATA,””MMDouBanProtocol”” “))) = “{ &quot;“MMDouBanProtocol”&quot; : &quot;“MMDouBanModule”&quot;}”;</p>
</li>
</ol>
</li>
</ol>
<pre><code>__attribute第一个参数used很有用。这个关键字是用来修饰函数的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。具体的描述可以看这个[gun的官方文档](https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html#Function Attributes)。

Static静态变量会按照他们申明的顺序，放到一个单独的段中。我们通过使用__attribute__((section(&quot;name&quot;)))来指明哪个段。数据则用__attribute__((used))来标记，防止链接器会优化删除未被使用的段。</code></pre><ol start="2">
<li><p>通过BHReadConfiguration读取__Data段中的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从数据段__data__中取出数据</span><br><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp) &#123;</span><br><span class="line">    NSMutableArray *configs &#x3D; [NSMutableArray array];</span><br><span class="line">    unsigned long size &#x3D; 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 &#x3D; (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter &#x3D; size&#x2F;sizeof(void*);</span><br><span class="line">    for(int idx &#x3D; 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string &#x3D; (char*)memory[idx];</span><br><span class="line">        NSString *str &#x3D; [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config &#x3D; %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    return configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用API进行注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide) &#123;</span><br><span class="line">    &#x2F;&#x2F;register services</span><br><span class="line">    NSArray&lt;NSString *&gt; *services &#x3D; BHReadConfiguration(BeehiveServiceSectName,mhp);</span><br><span class="line">    for (NSString *map in services) &#123;</span><br><span class="line">        NSData *jsonData &#x3D;  [map dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        NSError *error &#x3D; nil;</span><br><span class="line">        id json &#x3D; [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;error];</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            if ([json isKindOfClass:[NSDictionary class]] &amp;&amp; [json allKeys].count) &#123;</span><br><span class="line">                </span><br><span class="line">                NSString *protocol &#x3D; [json allKeys][0];</span><br><span class="line">                NSString *clsName  &#x3D; [json allValues][0];</span><br><span class="line">                </span><br><span class="line">                if (protocol &amp;&amp; clsName) &#123;</span><br><span class="line">                    [[BHServiceManager sharedManager] registerService:NSProtocolFromString(protocol) implClass:NSClassFromString(clsName)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h5 id="浏览日记本详情页——-gt-关注日记作者——-gt-校验当前用户登录状态——-gt-执行关注"><a href="#浏览日记本详情页——-gt-关注日记作者——-gt-校验当前用户登录状态——-gt-执行关注" class="headerlink" title="浏览日记本详情页——&gt;关注日记作者——&gt;校验当前用户登录状态——&gt;执行关注"></a>浏览日记本详情页——&gt;关注日记作者——&gt;校验当前用户登录状态——&gt;执行关注</h5><p>日记模块、关注模块、登录模块，互相之间调用互不依赖</p>
<p>使用接口或者抽象类制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成</p>
<ol>
<li><p>浏览日记本详情页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MMDiaryProtocol.h&quot;</span><br><span class="line"></span><br><span class="line">- (void)demo1 &#123;</span><br><span class="line">    &#x2F;&#x2F; 浏览日记本详情页</span><br><span class="line">    id&lt;MMDiaryProtocol&gt; diary &#x3D; [[BeeHive shareInstance] createService:@protocol(MMDiaryProtocol)];</span><br><span class="line">    [diary jumpToDiaryDetail:@&#123;@&quot;diary_id&quot;:@&quot;1234&quot;&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关注日记作者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MMFollowProtocol.h&quot;</span><br><span class="line"></span><br><span class="line">- (void)demo0 &#123;</span><br><span class="line">    &#x2F;&#x2F; 关注日记作者</span><br><span class="line">    id&lt;MMFollowProtocol&gt; follow &#x3D; [[BeeHive shareInstance] createService:@protocol(MMFollowProtocol)];</span><br><span class="line">    [follow follow:@&#123;@&quot;follow_id&quot;: @&quot;123&quot;&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验登录状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MMLoginProtocol.h&quot;</span><br><span class="line">@BeeHiveService(MMFollowProtocol, MMFollowModule)</span><br><span class="line"></span><br><span class="line">@implementation MMFollowModule</span><br><span class="line">- (void)follow:(NSDictionary *)follow &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,follow[@&quot;follow_id&quot;]);</span><br><span class="line">    id&lt;MMLoginProtocol&gt; login &#x3D; [[BeeHive shareInstance] createService:@protocol(MMLoginProtocol)];</span><br><span class="line">    [login loginIfNeedWithCompleteBlock:^(BOOL success) &#123;</span><br><span class="line">        NSLog(@&quot;%d&quot;,success);</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用关注接口</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/alibaba/BeeHive/blob/master/README-CN.md" target="_blank" rel="noopener">GitHub地址</a></p>
<p><a href="https://tech.meituan.com/2018/06/29/ios-multiterminal-reuse.html" target="_blank" rel="noopener">美团技术博客</a></p>
<p><a href="https://www.jianshu.com/p/4d770ec3cf7d" target="_blank" rel="noopener">组件化工具：BeeHive事件分发</a></p>
<p><a href="https://halfrost.com/beehive/" target="_blank" rel="noopener">BeeHive：一个优雅但还在完善中的解耦工具</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doris AI</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doris AI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
