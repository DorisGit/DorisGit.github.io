<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorisgit.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="泡泡茶壶">
<meta property="og:url" content="https://dorisgit.github.io/index.html">
<meta property="og:site_name" content="泡泡茶壶">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Doris AI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dorisgit.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>泡泡茶壶</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泡泡茶壶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2021/01/13/%E6%8F%90%E9%AB%98iOS%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/%E6%8F%90%E9%AB%98iOS%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">提高iOS编译速度实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-13 15:19:34" itemprop="dateCreated datePublished" datetime="2021-01-13T15:19:34+08:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-25 14:40:20" itemprop="dateModified" datetime="2021-01-25T14:40:20+08:00">2021-01-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="当前项目情况"><a href="#当前项目情况" class="headerlink" title="当前项目情况"></a>当前项目情况</h4><ul>
<li>设置Xcode显示编译时长</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES</span><br></pre></td></tr></table></figure>

<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113164314696.png" alt="image-20210113164314696"></p>
<ul>
<li>获取oc文件代码行数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name "*.m" -or -name "*.h" -or -name "*.xib" -or -name "*.c" |xargs wc -l</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前项目   92011 total</span><br><span class="line">当前项目（包括pod文件）63401 total</span><br></pre></td></tr></table></figure>

<ul>
<li>获取swift文件代码行数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name "*.swift"  -print | xargs wc -l</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前项目    40100 total</span><br><span class="line">当前项目（包括pod文件）271278 total</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编译时长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总耗时 &#x3D; 增量编译 + 链接 + 生成调试信息（dSYM）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="编译时长分析"><a href="#编译时长分析" class="headerlink" title="编译时长分析"></a>编译时长分析</h3><h4 id="Gnomon"><a href="#Gnomon" class="headerlink" title="Gnomon"></a>Gnomon</h4><ul>
<li><p>分析工具</p>
<p><a href="https://link.jianshu.com/?t=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fgnomon" target="_blank" rel="noopener">gnomon</a>是一个命令行工具，可以标记出另外一个命令执行消耗的时间信息，对一些需要长时间运行的命令特别有效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xcpretty https://github.com/supermarin/xcpretty</span><br><span class="line">gnomon https://rubygems.org/gems/gnomon/versions/1.0.0</span><br><span class="line"></span><br><span class="line">xcpretty 安装：gem install xcpretty</span><br><span class="line">gnomon 安装：npm install -g gnomon</span><br></pre></td></tr></table></figure>

<p>出现<code>You don&#39;t have write permissions for the /usr/bin directory</code>的时候，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install xcpretty -n /usr/local/bin</span><br><span class="line">sudo npm install -g gnomon</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -workspace YourName.xcworkspace -scheme YourName -archivePath ~&#x2F;Desktop&#x2F;Momo archive |xcpretty | gnomon</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
</li>
</ul>
<h4 id="speedscope"><a href="#speedscope" class="headerlink" title="speedscope"></a><a href="https://github.com/jlfwong/speedscope" target="_blank" rel="noopener">speedscope</a></h4><h5 id="Importing-from-Instruments-app"><a href="#Importing-from-Instruments-app" class="headerlink" title="Importing from Instruments.app"></a>Importing from Instruments.app</h5><p><img src="https://github.com/DorisGit/DorisGit.github.io/blob/master/images/image-20210114170444533.png" alt="image-20210114170444533"></p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210114171317919.png" alt="image-20210114171317919"></p>
<p>打开<a href="https://www.speedscope.app/" target="_blank" rel="noopener">https://www.speedscope.app</a>，将剪切板内容粘贴过去</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210114183314145.png" alt="image-20210114183314145"></p>
<h4 id="clang-ftime-trace-优化编译时长"><a href="#clang-ftime-trace-优化编译时长" class="headerlink" title="clang(-ftime-trace)优化编译时长"></a>clang(-ftime-trace)优化编译时长</h4><h5 id="ClangBuildAnalyzer-ftime-trace"><a href="#ClangBuildAnalyzer-ftime-trace" class="headerlink" title="ClangBuildAnalyzer(-ftime-trace)"></a>ClangBuildAnalyzer(-ftime-trace)</h5><ul>
<li><p>编译/安装ClangBuildAnalyzer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aras-p/ClangBuildAnalyzer.git</span><br><span class="line">or</span><br><span class="line">git clone https://gitee.com/wangwenchaonj/ClangBuildAnalyzer.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译ClangBuildAnalyzer</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ClangBuildAnalyzer</span><br><span class="line">make -f projects/make/Makefile</span><br></pre></td></tr></table></figure>
</li>
<li><p>将ClangBuildAnalyzer添加到系统路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">cp ClangBuildAnalyzer /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>ClangBuildAnalyzer执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">USAGE: one of</span><br><span class="line">  ClangBuildAnalyzer --start &lt;artifactsdir&gt;</span><br><span class="line">  ClangBuildAnalyzer --stop &lt;artifactsdir&gt; &lt;filename&gt;</span><br><span class="line">  ClangBuildAnalyzer --all &lt;artifactsdir&gt; &lt;filename&gt;</span><br><span class="line">  ClangBuildAnalyzer --analyze &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工程参数设置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CC=/usr/local/bin/clang</span><br><span class="line">export CXX=/usr/local/bin/clang++</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置clang编译器<code>-ftime-trace</code>参数</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210114213116776.png" alt="image-20210114213116776"></p>
</li>
<li><p>对源码进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">ClangBuildAnalyzer --start ./build</span><br><span class="line">make -f projects/make/Makefile</span><br><span class="line">ClangBuildAnalyzer --stop ./build/ ClangBuildAnalyzer.data</span><br><span class="line">ClangBuildAnalyzer --analyze ClangBuildAnalyzer.data</span><br><span class="line">ls</span><br><span class="line">chmod -R 777 *</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="chrome://tracing/">chrome://tracing/</a>加载时长结果</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210114213452231.png" alt="image-20210114213452231"></p>
</li>
<li><p>是</p>
</li>
</ul>
<h4 id="优化工程配置"><a href="#优化工程配置" class="headerlink" title="优化工程配置"></a>优化工程配置</h4><h5 id="调整编译优化等级"><a href="#调整编译优化等级" class="headerlink" title="调整编译优化等级"></a>调整编译优化等级</h5><p>编译优化等级的基本原理是牺牲编译时性能，追求运行时的性能，在编译时删除无用代码，保留调试信息，函数内联等，因此提升打包速度的秘诀就是反其道而行之，牺牲运行时性能来换取编译时性能。对于日常测试打包，可以将 Optimize level 设置为 -O0, 表示不做任何优化, 以提升编译器的编译速度</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113164453714.png" alt="image-20210113164453714"></p>
<h5 id="关闭Bitcode"><a href="#关闭Bitcode" class="headerlink" title="关闭Bitcode"></a>关闭Bitcode</h5><p>BitCode 是 iOS 9 引入的新特性，是由 LLVM 引入的一种中间代码，当这个属性设置为 YES 的时候，Xcode 在打包的时候，会将项目编译成很多个设备对应的安装包，这样在编译打包的时候就比较耗时，但对于内部打包不需要上传 AppStroe, 因此我们可以关闭此特性以减少编译打包时间。</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113164817511.png" alt="image-20210113164817511"></p>
<h5 id="关闭dsYM生成"><a href="#关闭dsYM生成" class="headerlink" title="关闭dsYM生成"></a>关闭dsYM生成</h5><p>在大部分场景下测试，并不需要生成 dSYM 文件，仅当在最终 App Release Test 和提交应用市场的时候开启即可，可以检查一下子工程（尤其开源库）有么有设置正确</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113165021445.png" alt="image-20210113165021445"></p>
<h5 id="将-Build-Active-Architecture-Only-改为-Yes"><a href="#将-Build-Active-Architecture-Only-改为-Yes" class="headerlink" title="将 Build Active Architecture Only 改为 Yes"></a>将 Build Active Architecture Only 改为 Yes</h5><p>Debug 时是不需要生成全架构，可以检查一下子工程（尤其开源库）有没有设置正确</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113211958796.png" alt="image-20210113211958796"></p>
<h5 id="优化头文件搜索路径"><a href="#优化头文件搜索路径" class="headerlink" title="优化头文件搜索路径"></a>优化头文件搜索路径</h5><p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113212600889.png" alt="image-20210113212600889"></p>
<h4 id="优化Swift编译时间"><a href="#优化Swift编译时间" class="headerlink" title="优化Swift编译时间"></a>优化Swift编译时间</h4><h5 id="Swift代码编译耗时分析"><a href="#Swift代码编译耗时分析" class="headerlink" title="Swift代码编译耗时分析"></a>Swift代码编译耗时分析</h5><p>由于项目中swift代码量比较大，首先需要把耗时过长的文件找出来，然后进行重点优化，这里在Other Swift Flags加入两个编译参数：</p>
<ul>
<li>-Xfrontend: 如果编译或类型检查时耗时多长，则在Xcode中输出警告</li>
<li>-debug-time-function-bodies：输出每个函数的编译时长</li>
</ul>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113161127114.png" alt="image-20210113161127114"></p>
<p>然后通过使用<a href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" target="_blank" rel="noopener">BuildTimeAnalyzer-for-Xcode</a>工具分析Xcode编译log，获取分析结果</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113161941564.png" alt="image-20210113161941564"></p>
<h5 id="Swift代码优化建议"><a href="#Swift代码优化建议" class="headerlink" title="Swift代码优化建议"></a>Swift代码优化建议</h5><h6 id="为复杂的Swift属性使用明确的类型"><a href="#为复杂的Swift属性使用明确的类型" class="headerlink" title="为复杂的Swift属性使用明确的类型"></a>为复杂的Swift属性使用明确的类型</h6><p>在 Swift 中定义变量时可以不带类型声明，Xcode 编译器会更具初始化的值推断变量类型，这为 Swift 开发者提供了很大的便利，但这同时也增加的编译器的分析推断时间，从减少编译时间的角度考虑，对于相对复杂代码语句，减少编译器类型推断，可以大大减少 Xcode 的编译时间</p>
<h6 id="拆解复杂的Swift表达式"><a href="#拆解复杂的Swift表达式" class="headerlink" title="拆解复杂的Swift表达式"></a>拆解复杂的Swift表达式</h6><p>对复杂表达式进行简化，简化的代码不仅可以提高编译效率，也具有更好的可读性，例如下面样例代码编译时间相差 30 倍</p>
<h6 id="避免使用加号对字符串或数组进行拼接"><a href="#避免使用加号对字符串或数组进行拼接" class="headerlink" title="避免使用加号对字符串或数组进行拼接"></a>避免使用加号对字符串或数组进行拼接</h6><p>对字符串或数组的拼接，在日常开发中十分常见，需要注意拼接方式对编译时间的影响</p>
<h4 id="CCache（不适合在项目中使用）"><a href="#CCache（不适合在项目中使用）" class="headerlink" title="CCache（不适合在项目中使用）"></a><a href="https://ccache.dev" target="_blank" rel="noopener">CCache</a>（不适合在项目中使用）</h4><p><a href="http://link.zhihu.com/?target=https%3A//ccache.samba.org">CCache</a> 是一个能够把编译的中间产物缓存起来的工具，能够明显的提升编译速度，但是有一个显著的问题<strong>不支持 PCH 和 Clang modules</strong>，导致无法在项目中使用。</p>
<h5 id="安装CCache"><a href="#安装CCache" class="headerlink" title="安装CCache"></a>安装CCache</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ccache</span><br></pre></td></tr></table></figure>

<h5 id="创建CCache脚本"><a href="#创建CCache脚本" class="headerlink" title="创建CCache脚本"></a>创建CCache脚本</h5><p>为了能让 CCache 介入到整个编译的过程，我们要把 CCache 作为项目的 C 编译器，当 CCache 找不到编译缓存时，它会再把编译指令传递给真正的编译器 clang</p>
<p>新建脚本文件ccache-clang，放置于项目中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">if type -p ccache &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">export CCACHE_MAXSIZE=10G</span><br><span class="line">export CCACHE_CPP2=true</span><br><span class="line">export CCACHE_HARDLINK=true</span><br><span class="line">export CCACHE_SLOPPINESS=file_macro,time_macros,include_file_mtime,include_file_ctime,file_stat_matches</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定日志文件路径到桌面，等下排查集成问题有用，集成成功后删除，否则很占磁盘空间</span></span><br><span class="line">export CCACHE_LOGFILE='~/Desktop/CCache.log'</span><br><span class="line">exec ccache /usr/bin/clang "$@"</span><br><span class="line">else</span><br><span class="line">exec clang "$@"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="定义CC常量"><a href="#定义CC常量" class="headerlink" title="定义CC常量"></a>定义CC常量</h5><p>在项目设置Build Setting中，添加常量CC，这个值会让Xcode在编译时把执行路径的可执行文件当作C编译器。</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113175120935.png" alt="image-20210113175120935"></p>
<p>CC常量的值为 $(SRCROOT)/ccache-clang，如果你的脚本不是放在项目根目录，则自行调整路径。如果一运行项目就报错，检查下路径是不是填错了</p>
<h5 id="关闭Clang-Modules"><a href="#关闭Clang-Modules" class="headerlink" title="关闭Clang Modules"></a>关闭Clang Modules</h5><p>因为CCache不支持Clang Modules，需要将Enable Modules的选项关闭。</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113174944003.png" alt="image-20210113174944003"></p>
<p>关闭Clang Modules必须删除所有的@import语句，替换为#import的语言</p>
<p>搜索后发现@import使用处非常多，暂时放弃此种方案</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113174911402.png" alt="image-20210113174911402"></p>
<h4 id="阶段性测试结果"><a href="#阶段性测试结果" class="headerlink" title="阶段性测试结果"></a>阶段性测试结果</h4><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p><img src="http://qn49kho58.bkt.gdipper.com/image-20210113214244160.png" alt="image-20210113214244160"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://cloud.tencent.com/developer/article/1564372" target="_blank" rel="noopener">iOS 微信编译速度优化分享</a></p>
<p><a href="http://www.cocoachina.com/articles/19665" target="_blank" rel="noopener">如何将 iOS 项目的编译速度提高5倍</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/143775034" target="_blank" rel="noopener">iOS如何把编译速度稳定地提高10倍以上</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1645780" target="_blank" rel="noopener">深入剖析 iOS 编译 Clang / LLVM</a></p>
<p><a href="https://releases.llvm.org/download.html#11.0.0" target="_blank" rel="noopener">LLVM</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1645780" target="_blank" rel="noopener">深入剖析 iOS 编译 Clang / LLVM</a></p>
<p><a href="https://blog.csdn.net/wwchao2012/article/details/109147192?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242" target="_blank" rel="noopener">-ftime-trace(clang)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">设计模式-七大设计原则</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-11 16:07:36" itemprop="dateCreated datePublished" datetime="2021-01-11T16:07:36+08:00">2021-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-22 21:15:08" itemprop="dateModified" datetime="2021-01-22T21:15:08+08:00">2021-01-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>软件设计模式（Design-Pattern），又称设计模式，是一套被反复使用、多数人知晓，经过分类、代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性、程序的复用性。可以理解为：“世上本没有设计模式，用的人多了，便总结出了一套设计模式。”</p>
<h4 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h4><p>面向对象的设计模式有七大基本原则：</p>
<ul>
<li>开闭原则（Open Closed Principle, OCP）</li>
<li>单一职责原则（Single Responsibility Principle，SRP）</li>
<li>里氏替换原则（Liskov Substitution Principle，LSP）</li>
<li>依赖倒置原则（Dependcy Inversion Principle，DIP）</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）</li>
<li>合成/聚合原则（Composite/Aggregate Reuse Principle,CAPP）</li>
<li>最小知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）</li>
</ul>
<p>开闭原则是总纲，它指导我们对扩展开放，对修改关闭；单一职责，指导我们实现类要职责单一；里氏替换原则指导我们不要破环继承体系；依赖倒置，指导我们要面向接口编程；接口隔离原则指导我们在接口设计的时候要精简单一；迪米特法则指导我们要降低耦合。</p>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><blockquote>
<p><strong>对扩展开放，对修改关闭</strong></p>
</blockquote>
<p>强调的是，用抽象构建框架，用实现扩展细节；优点是，提高了软件系统的可复用性 和 可维护性</p>
<blockquote>
<p><strong>总结</strong></p>
<ul>
<li>面向对象最基本的设计原则</li>
<li>指导我们构建稳定的系统<ul>
<li>代码不是一次性的，更多时间处于维护阶段</li>
<li>尽量对已有源码很少修改，通过新增扩展、类来修改，降低风险</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="实际举例"><a href="#实际举例" class="headerlink" title="实际举例"></a>实际举例</h5><p>弹性工作时间，时间长度是固定的，时间范围是可变的。</p>
<p>分析：行政可以定义固定的工作时长8h/d，员工可以根据自己实际情况制定个人的上下班时间；固定时长可以定义为一个抽象类（Abstract Subject），而每个具体员工的上班时间（Specific Subject）是其子类。员工可以根据自身情况调整上下班时间，但不可以修改固定时长。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><h6 id="对软件测试的影响"><a href="#对软件测试的影响" class="headerlink" title="对软件测试的影响"></a>对软件测试的影响</h6><p>遵守开闭原则的设计，软件测试时只需要对扩展代码进行测试就可以了，原有的功能完全不受影响</p>
<h6 id="提高代码的可复用性"><a href="#提高代码的可复用性" class="headerlink" title="提高代码的可复用性"></a>提高代码的可复用性</h6><p>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性</p>
<h6 id="提高软件的可维护性"><a href="#提高软件的可维护性" class="headerlink" title="提高软件的可维护性"></a>提高软件的可维护性</h6><p>遵守开闭原则的设计，其稳定性高和延续性强，从而易于扩展和维护</p>
<h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><blockquote>
<p>单一职责规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</p>
</blockquote>
<p>该原则提出，对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p>
<ul>
<li>一个职责的变化可能会消弱或者抑制这个类实现其他职责的能力；</li>
<li>当客户端需要改对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>降低类的复杂度，一个类只负责一项职责</li>
<li>提高类的可读性</li>
<li>提高系统的可维护性</li>
<li>变更引起的风险降低</li>
</ul>
<h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>单一职责是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多种职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<h5 id="实际举例-1"><a href="#实际举例-1" class="headerlink" title="实际举例"></a>实际举例</h5><p>学生工作管理</p>
<p>分析：学生工作管理主要分为学生生活辅导+学生学业指导，最好的做法是生活辅导交由辅导员类负责，学业指导交由学业导师负责。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20210120184950103.png" alt="image-20210120184950103"></p>
<h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><blockquote>
<p>继承必须确保超类所拥有的性质在子类中仍然成立，它反映了基类和子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范</p>
</blockquote>
<h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ul>
<li>里氏替换原则是实现开闭原则的重要方式之一</li>
<li>它克服了继承中重写父类造成的可复用性变差的缺点</li>
<li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低代码出错的可能性</li>
<li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li>
</ul>
<h5 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h5><blockquote>
<p>子类可以扩展父类的功能，但是不能改变父类原有的功能。也就是说，子类继承父类时，除添加新的方法时，尽量不要重写父类方法。</p>
</blockquote>
<h5 id="定义总结"><a href="#定义总结" class="headerlink" title="定义总结"></a>定义总结</h5><ul>
<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</li>
<li>子类中可以增加自己持有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>
<li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类的方法更严格或相等</li>
</ul>
<p>通过重写父类的方法来完成新的功能写起来虽然比较简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率比较大。</p>
<p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。其修正办法是：取消原来的继承关系，重新设计它们之间的关系。</p>
<h5 id="实际举例-2"><a href="#实际举例-2" class="headerlink" title="实际举例"></a>实际举例</h5><p>“几维鸟不是鸟”</p>
<p>分析：鸟一般都会飞行，但是新西兰的几维鸟由于翅膀退化无法飞行。假设设计一个鸟的实例，燕子、几纬鸟类继承至鸟，获取两种鸟飞行300km花费时间。几纬鸟不会飞，结果会发生“除零异常” 或者 “无限大”，不符合预期。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20210120191510026.png" alt="image-20210120191510026"></p>
<p>几维鸟重写了鸟类的setSpeed方法，这违背了里氏替换原则，正确做法是取消几维鸟原来的继承关系，定义鸟 和 几维鸟的父类，动物类</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20210120191742673.png" alt="image-20210120191742673"></p>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><blockquote>
<p>高层模块不应该依赖于低层模块，两者都应该依赖其抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>其核心思想是：要面向接口编程，不要面向实现编程</p>
</blockquote>
<p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合</p>
<h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><p>软件设计中，抽象具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定的多。</p>
<ul>
<li>降低类间的耦合性</li>
<li>提高系统的稳定性</li>
<li>减少并行开发引起的风险</li>
<li>提高代码的可读性和可维护性</li>
</ul>
<h5 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h5><p>依赖倒置的目的是通过面向接口的编程来降低类间的耦合性，实际在使用的过程，满足以下几个规则：</p>
<ul>
<li>每个类尽量提供接口和抽象类，或者两者都具备</li>
<li>变量的声明类型尽量是接口或抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>使用继承时尽量遵循里氏替换原则</li>
</ul>
<h5 id="实际举例-3"><a href="#实际举例-3" class="headerlink" title="实际举例"></a>实际举例</h5><p>“顾客购物”</p>
<p>分析：顾客购物的选择可能会在多个商店，多个商店都提供售卖这个功能，定义抽象类提供售卖方法，不同商店以抽象类为基础进行搭建</p>
<p>建议参考BeeHive具体实现</p>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><blockquote>
<p>客户端不应该被迫依赖于它不适应的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
</blockquote>
<p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p>
<ul>
<li>单一职责注重的是职责，而接口隔离原则注重的是对接口依赖的隔离</li>
<li>单一职责主要是约束类，他针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建</li>
</ul>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>接口隔离原则是为了约束接口，降低类对接口的依赖性，有如下几个优点：</p>
<ul>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性；</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法稳定提供定制服务，给整体项目带来无法预料的风险</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义</li>
<li>能减少项目过程中的代码冗余，过大的接口里面通常放置许多不同的方法，当实现这个接口的时候，被迫设计冗余的代码</li>
</ul>
<h5 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h5><p>在具体应用接口隔离原则时，应该根据一下几个规则来衡量：</p>
<ul>
<li>接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑</li>
<li>为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/28/iOS-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/iOS-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">iOS-启动优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-28 14:19:54" itemprop="dateCreated datePublished" datetime="2020-12-28T14:19:54+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-25 14:40:47" itemprop="dateModified" datetime="2021-01-25T14:40:47+08:00">2021-01-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="检测启动时间"><a href="#检测启动时间" class="headerlink" title="检测启动时间"></a>检测启动时间</h2><h3 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h3><ul>
<li>冷启动：指 <code>App</code>被后台Kill后重新启动</li>
<li>热启动：<code>App</code>的状态由<code>running</code>切换至<code>suspend</code>，<code>App</code>没有被<code>kill</code>仍然在后台运行，再次将<code>App</code>切换至前台</li>
</ul>
<h3 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h3><p>启动时间划分可以把<code>main()</code>函数作为关键点分割成两块</p>
<ul>
<li><code>t1</code>阶段，<code>main()</code>函数之前，成为<code>pre-main</code></li>
<li><code>t2</code>阶段，<code>main()</code>函数及<code>main()</code>函数之后之后处理所需时间</li>
</ul>
<p><img src="http://qn49kho58.bkt.gdipper.com/1723a78c376791a7.png" alt="1723a78c376791a7"></p>
<h4 id="t1阶段：pre-main"><a href="#t1阶段：pre-main" class="headerlink" title="t1阶段：pre-main"></a>t1阶段：<code>pre-main</code></h4><p><img src="http://qn49kho58.bkt.gdipper.com/1723a70f03e23995.png" alt="1723a70f03e23995"></p>
<h4 id="t2阶段"><a href="#t2阶段" class="headerlink" title="t2阶段"></a>t2阶段</h4><p>t2阶段的耗时主要在业务代码，根据打点统计业务耗时</p>
<h3 id="Xcode测量-pre-main-时间"><a href="#Xcode测量-pre-main-时间" class="headerlink" title="Xcode测量 pre-main 时间"></a>Xcode测量 pre-main 时间</h3><p>通过添加环境变量可以获取到 pre-main阶段的时间。</p>
<h4 id="DYLD-PRINT-STATISTICS"><a href="#DYLD-PRINT-STATISTICS" class="headerlink" title="DYLD_PRINT_STATISTICS"></a><code>DYLD_PRINT_STATISTICS</code></h4><p>Xcode中提供了测量pre-main的时间，Edit scheme -&gt; Run -&gt;Augments添加环境变量DYLD_PRINT_STATISTICS，value为YES</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20201228143351368.png" alt="image-20201228143351368"></p>
<p>启动后可以看到启动时长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 2.4 seconds (100.0%)</span><br><span class="line">         dylib loading time: 1.0 seconds (43.9%)</span><br><span class="line">        rebase&#x2F;binding time: 386.35 milliseconds (15.6%)</span><br><span class="line">            ObjC setup time: 199.85 milliseconds (8.0%)</span><br><span class="line">           initializer time: 798.44 milliseconds (32.3%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :   9.73 milliseconds (0.3%)</span><br><span class="line">          libglInterpose.dylib : 504.02 milliseconds (20.3%)</span><br><span class="line">                  AFNetworking :  50.88 milliseconds (2.0%)</span><br><span class="line">                           xxx : 195.11 milliseconds (7.8%)</span><br></pre></td></tr></table></figure>

<h4 id="加载dylib"><a href="#加载dylib" class="headerlink" title="加载dylib"></a>加载dylib</h4><p>分析每个dylib动态链接库，找到其Mach-O文件，打开并读取验证有效性；找到代码签名注册到内核，最后对dylib的每个segment调用mmap()</p>
<p>在dylib的加载过程中为了安全考虑加载ASLR（Address Space Layout Randomization）技术和代码签名</p>
<p>ASLR技术：镜像Image、可执行文件、dylib、bundle在加载的时候会再起指向的地址(preferred_address)前面添加一个随机数偏差(slide)，防止应用内部地址被定位。</p>
<h4 id="Rebase-Bind"><a href="#Rebase-Bind" class="headerlink" title="Rebase/Bind"></a>Rebase/Bind</h4><ul>
<li>dylib加载完成之后，它们处于互相独立的状态，需要绑定起来</li>
<li>Rebase将镜像读入内存，修正镜像内部的指针，性能消耗主要在IO</li>
<li>Bind是查询符号表，设置指向镜像外部的指针，性能消耗主要在CPU计算</li>
</ul>
<h4 id="Objc-setup"><a href="#Objc-setup" class="headerlink" title="Objc setup"></a>Objc setup</h4><p>runtime会维护一张类名与类的方法列表的全局表</p>
<ul>
<li>读取所有类，将类对象其注册到这个全局表中（class registration）</li>
<li>读取所有分类，把分类加载到类对象中（category registration）</li>
<li>检查selector的唯一性（selector uniquing）</li>
</ul>
<h4 id="Initializer-time"><a href="#Initializer-time" class="headerlink" title="Initializer time"></a>Initializer time</h4><p>这部分主要就是load方法的耗时</p>
<h4 id="DYLD-PRINT-STATISTICS-DETAILS"><a href="#DYLD-PRINT-STATISTICS-DETAILS" class="headerlink" title="DYLD_PRINT_STATISTICS_DETAILS"></a><code>DYLD_PRINT_STATISTICS_DETAILS</code></h4><p>为了获取更详细的时间信息，添加环境变量<code>DYLD_PRINT_STATISTICS_DETAILS</code>，value为YES</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  total time: 3.7 seconds (100.0%)</span><br><span class="line">  total images loaded:  735 (658 from dyld shared cache)</span><br><span class="line">  total segments mapped: 306, into 102134 pages</span><br><span class="line">  total images loading time: 2.5 seconds (66.8%)</span><br><span class="line">  total load time in ObjC: 198.07 milliseconds (5.2%)</span><br><span class="line">  total debugger pause time: 1.3 seconds (35.7%)</span><br><span class="line">  total dtrace DOF registration time:   0.00 milliseconds (0.0%)</span><br><span class="line">  total rebase fixups:  1,121,422</span><br><span class="line">  total rebase fixups time: 103.90 milliseconds (2.7%)</span><br><span class="line">  total binding fixups: 86,509</span><br><span class="line">  total binding fixups time: 187.76 milliseconds (4.9%)</span><br><span class="line">  total weak binding fixups time:  18.64 milliseconds (0.4%)</span><br><span class="line">  total redo shared cached bindings time:  30.19 milliseconds (0.7%)</span><br><span class="line">  total bindings lazily fixed up: 0 of 0</span><br><span class="line">  total time in initializers and ObjC +load: 749.00 milliseconds (19.7%)</span><br><span class="line">                         libSystem.B.dylib :   7.93 milliseconds (0.2%)</span><br><span class="line">               libBacktraceRecording.dylib :   7.26 milliseconds (0.1%)</span><br><span class="line">                           libobjc.A.dylib :  11.82 milliseconds (0.3%)</span><br><span class="line">                      libglInterpose.dylib : 464.63 milliseconds (12.2%)</span><br><span class="line">                       libMTLCapture.dylib :  17.50 milliseconds (0.4%)</span><br><span class="line">                              AFNetworking :  50.53 milliseconds (1.3%)</span><br><span class="line">                                 Alamofire :   5.91 milliseconds (0.1%)</span><br><span class="line">                               DoraemonKit :   4.43 milliseconds (0.1%)</span><br><span class="line">                                    NIMSDK :   4.47 milliseconds (0.1%)</span><br><span class="line">                                       NMC :  10.72 milliseconds (0.2%)</span><br><span class="line">                       PLMediaStreamingKit :   5.44 milliseconds (0.1%)</span><br><span class="line">                                   iAdCore :   4.12 milliseconds (0.1%)</span><br><span class="line">                                   		 xxx : 171.85 milliseconds (4.5%)</span><br><span class="line">total symbol trie searches:    184588</span><br><span class="line">total symbol table binary searches:    0</span><br><span class="line">total images defining weak symbols:  80</span><br><span class="line">total images using weak symbols:  173</span><br></pre></td></tr></table></figure>

<h2 id="物理内存和虚拟内存"><a href="#物理内存和虚拟内存" class="headerlink" title="物理内存和虚拟内存"></a>物理内存和虚拟内存</h2><h3 id="内存浪费"><a href="#内存浪费" class="headerlink" title="内存浪费"></a>内存浪费</h3><p>早期计算机需要不断启动应用，到达一定数量以后就会报错，应用无法正常运行，必须先关闭前面的部分应用才能继续开启。</p>
<p>这是因为早期计算机没有虚拟地址，一旦加载都会全部加载到内存中，一但物理内存不够了，那么应用就无法继续开启。</p>
<p>应用在内存中的排序都是顺序排列的，这样进程只需要将自己的地址尾部往右偏移一点就能访问到别的进程中的内存地址，想当不安全。</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/1723b443939cb86a.png" alt="1723b443939cb86a"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>用户使用时并不会使用到全部内存，如果App一启动就全部加载到内存中会浪费很多内存空间，<strong>虚拟内存技术</strong>的出现就是为了解决这个内存浪费情况。</p>
<p>App启动后会认为自己已经获取到了整个App运行所需的内存空间，但实际上并没有在物理内存上为他申请那么大的空间，只是生产了一张 <strong>虚拟内存和物理内存关联的表</strong>。</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/1723b49489c7e84b.png" alt="1723b49489c7e84b"></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>当App需要使用某一块虚拟内存的地址时，会通过这张表查询该虚拟地址是否已经在物理内存中申请了空间。</p>
<ul>
<li>如果已经申请就通过表的记录访问物理内存地址</li>
<li>如果没有申请则申请一块物理内存空间并记录在表中（Page Fault）</li>
</ul>
<p>这个通过进程映射表映射到不同的物理内存空间的操作叫做地址翻译，这个过程需要CPU和操作系统配合。</p>
<h4 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h4><p>当数据未在物理内存会进行下列操作</p>
<ul>
<li>系统阻塞该进程</li>
<li>将磁盘中对应page的数据加载到内存</li>
<li>将虚拟内存指向物理内存</li>
</ul>
<h4 id="灵活内存管理"><a href="#灵活内存管理" class="headerlink" title="灵活内存管理"></a>灵活内存管理</h4><p>虽然解决了浪费问题，但是一旦出现物理内存空间全被申请的情况，还是有可能会产生内存不足的情况，为保证当前App的政策适用，数据加载遵循以下原则：</p>
<ul>
<li>如果有空闲内存空间就放空的内存空间中</li>
<li>如果没有就覆盖其他进程的数据</li>
<li>具体覆盖由操作系统处理</li>
</ul>
<h3 id="解决安全问题"><a href="#解决安全问题" class="headerlink" title="解决安全问题"></a>解决安全问题</h3><p>空间问题已经解决了，但是安全问题呢？</p>
<p>在dylib加载过程中系统为了安全考虑引入了ASLR（Address Space Layout Randomization）技术和代码签名</p>
<p>ASLR技术：镜像Image、可执行文件、dylib、bundle在加载的时候会在其指向的地址（preferred_address）前面添加一个随机数偏差（slide），防止应用内部地址被定位</p>
<h2 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h2><h3 id="为什么进行二进制重排"><a href="#为什么进行二进制重排" class="headerlink" title="为什么进行二进制重排"></a>为什么进行二进制重排</h3><p>虚拟内存技术会产生缺页中断（Page Fault），这个过程是个耗时操作。</p>
<p>每页耗时也会有很大差距，1微妙到0.8毫秒不等。</p>
<p>使用过程中对这点耗时感觉不明显，但是启动时加载大量数据，如果产生大量缺页中断（Page Fault）从而优化启动速度，这就是二进制重排。</p>
<h3 id="重排目的"><a href="#重排目的" class="headerlink" title="重排目的"></a>重排目的</h3><p>二进制重排就是为了减少启动时的缺页异常（Page Fault）从而减少启动时间</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/1723b9a250ed488e.png" alt="1723b9a250ed488e"></p>
<p><img src="http://qn49kho58.bkt.gdipper.com/1723b98983c1778f.png" alt="1723b98983c1778f"></p>
<h3 id="查看Page-Fault"><a href="#查看Page-Fault" class="headerlink" title="查看Page Fault"></a>查看Page Fault</h3><p><img src="http://qn49kho58.bkt.gdipper.com/image-20201228172047101.png" alt="image-20201228172047101"></p>
<p>Page Fault会随着代码和文件的增加而增加，而二进制重排可以很好优化这个问题，其中心思想是重新排列方法符号的顺序，使启动的相关方法，排在最前面从而减少启动Page Fault。</p>
<h3 id="Link-Map-File"><a href="#Link-Map-File" class="headerlink" title="Link Map File"></a>Link Map File</h3><h4 id="什么是Link-Map-File文件？"><a href="#什么是Link-Map-File文件？" class="headerlink" title="什么是Link Map File文件？"></a>什么是Link Map File文件？</h4><p><code>Link Map File</code>直译为链接映射文件，是Xcode生成可执行文件时一起生成的文本，用于记录链接相关信息。</p>
<ul>
<li>可执行文件路径</li>
<li>CPU架构</li>
<li>.o目标路径</li>
<li>方法符号</li>
</ul>
<h4 id="Link-Map-File文件作用"><a href="#Link-Map-File文件作用" class="headerlink" title="Link Map File文件作用"></a>Link Map File文件作用</h4><ul>
<li>查看代码加载顺序</li>
<li>理解内存分段分区</li>
<li><code>Crash</code>时通过<code>Symbols</code>定位源码的机制</li>
<li>分析可执行文件中类和库体积，优化包体积</li>
</ul>
<h4 id="生成Link-Map-File"><a href="#生成Link-Map-File" class="headerlink" title="生成Link Map File"></a>生成Link Map File</h4><p><code>Xcode</code> 在生成可执行文件的时候默认情况下不生成该文件。</p>
<p>在<code>Xcode</code>的配置中 <code>Target -&gt; Build Setting -&gt; Linking</code> 将<code>Write Link Map File</code>设置为<code>YES</code>来生成<code>Link Map File</code>，运行代码即可生成<code>Link Map File</code></p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20201228184414293.png" alt="image-20201228184414293"></p>
<h4 id="查看Link-Map-File文件"><a href="#查看Link-Map-File文件" class="headerlink" title="查看Link Map File文件"></a>查看Link Map File文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Users&#x2F;mikasa&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;xxx-esvlirvezjzdpuataqpznpbhress&#x2F;Build&#x2F;Intermediates.noindex&#x2F;xxx.build&#x2F;Debug-iphoneos&#x2F;xxx.build&#x2F;xxx-LinkMap-normal-arm64.txt</span><br></pre></td></tr></table></figure>

<p><code>Link Map File</code>主要分为3部分</p>
<ul>
<li>路径部分，展示生成的相关文件路径</li>
<li><code>Section</code>部分，展示相关地址段</li>
<li><code>Sybols</code>部分，方法符号段</li>
</ul>
<h5 id="路径部分"><a href="#路径部分" class="headerlink" title="路径部分"></a>路径部分</h5><ul>
<li><code>Path</code>是<code>.app</code>文件路径</li>
<li><code>Object files</code>是<code>.0</code>文件路径</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Path: /Users/mikasa/Library/Developer/Xcode/DerivedData/xxx-esvlirvezjzdpuataqpznpbhress/Build/Products/Debug-iphoneos/xxx.app/xxx</span><br><span class="line"># Arch: arm64</span><br><span class="line"># Object files:</span><br><span class="line">[  <span class="number">0</span>] linker synthesized</span><br><span class="line">[  <span class="number">1</span>] /Users/mikasa/Library/Developer/Xcode/DerivedData/xxx-esvlirvezjzdpuataqpznpbhress/Build/Intermediates.noindex/xxx.build/Debug-iphoneos/xxx.build/Objects-normal/arm64/<span class="built_in">UIView</span>+Transform.o</span><br><span class="line">[  <span class="number">2</span>] /Users/mikasa/Library/Developer/Xcode/DerivedData/xxx-esvlirvezjzdpuataqpznpbhress/Build/Intermediates.noindex/xxx.build/Debug-iphoneos/xxx.build/Objects-normal/arm64/GMCardViewModel.o</span><br><span class="line">[  <span class="number">3</span>] /Users/mikasa/Library/Developer/Xcode/DerivedData/xxx-esvlirvezjzdpuataqpznpbhress/Build/Intermediates.noindex/xxx.build/Debug-iphoneos/xxx.build/Objects-normal/arm64/GMTagSelectChoosedTagsView.o</span><br><span class="line">[  <span class="number">4</span>] /Users/mikasa/Library/Developer/Xcode/DerivedData/xxx-esvlirvezjzdpuataqpznpbhress/Build/Intermediates.noindex/xxx.build/Debug-iphoneos/xxx.build/Objects-normal/arm64/GMPaymentSuccessCell.o</span><br><span class="line">[  <span class="number">5</span>] /Users/mikasa/Library/Developer/Xcode/DerivedData/xxx-esvlirvezjzdpuataqpznpbhress/Build/Intermediates.noindex/xxx.build/Debug-iphoneos/xxx.build/Objects-normal/arm64/GMAreaCodeObject.o</span><br></pre></td></tr></table></figure>

<h5 id="Section部分"><a href="#Section部分" class="headerlink" title="Section部分"></a>Section部分</h5><p><code>Mach-O</code>文件中的虚拟地址最终会映射到物理地址上，这些地址被分为不同的Segment：<code>__TEXT段</code>、<code>__DATA</code>段、<code>__LINKEDIT</code>段</p>
<ul>
<li><code>__TEXT</code>包含<code>Mach Header</code>，被执行的代码和只读常量（如<code>C</code>字符串），只读可执行（<code>r-x</code>）</li>
<li><code>__DATA</code>包含全局变量，静态变量，可读写（<code>rw-</code>）</li>
<li><code>__LINKEDIT</code>包含了加载程序的元数据，比如函数的名称和地址，只读(<code>r-</code>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># Sections:</span><br><span class="line"># Address	Size    	Segment	Section</span><br><span class="line">0x100007CCC	0x02A93384	__TEXT	__text				&#x2F;&#x2F; 代码节，存放机器编译后的代码</span><br><span class="line">0x102A9B050	0x00006264	__TEXT	__stubs				&#x2F;&#x2F; 用于辅助做动态链接代码（dyld）</span><br><span class="line">0x102AA12B4	0x00006108	__TEXT	__stub_helper</span><br><span class="line">0x102AA73BC	0x000F2D75	__TEXT	__objc_methname</span><br><span class="line">0x102B9A131	0x0001BC91	__TEXT	__objc_classname</span><br><span class="line">0x102BB5DC2	0x000267BF	__TEXT	__objc_methtype</span><br><span class="line">0x102BDC584	0x000E2EBC	__TEXT	__gcc_except_tab</span><br><span class="line">0x102CBF440	0x0025DEFF	__TEXT	__cstring</span><br><span class="line">0x102F1D340	0x0000FD74	__TEXT	__ustring</span><br><span class="line">0x102F2D0C0	0x0011BF32	__TEXT	__const</span><br><span class="line">0x103048FF2	0x00004A64	__TEXT	__swift5_typeref</span><br><span class="line">0x10304DA58	0x0000840C	__TEXT	__swift5_fieldmd</span><br><span class="line">0x103055E64	0x00000A08	__TEXT	__swift5_types</span><br><span class="line">0x10305686C	0x000000A0	__TEXT	__swift5_protos</span><br><span class="line">0x103056910	0x00007992	__TEXT	__swift5_reflstr</span><br><span class="line">0x10305E2A4	0x00000424	__TEXT	__swift5_builtin</span><br><span class="line">0x10305E6C8	0x00000A38	__TEXT	__swift5_assocty</span><br><span class="line">0x10305F100	0x000007CC	__TEXT	__swift5_proto</span><br><span class="line">0x10305F8CC	0x000028E4	__TEXT	__swift5_capture</span><br><span class="line">0x1030621B0	0x00080BC8	__TEXT	__unwind_info</span><br><span class="line">0x1030E2D78	0x0000D284	__TEXT	__eh_frame</span><br><span class="line">0x1030F0000	0x00002E18	__DATA	__got</span><br><span class="line">0x1030F2E18	0x00004198	__DATA	__la_symbol_ptr</span><br><span class="line">0x1030F6FB0	0x00000750	__DATA	__mod_init_func</span><br><span class="line">0x1030F7700	0x000A0FB0	__DATA	__const</span><br><span class="line">0x1031986B0	0x000913E0	__DATA	__cfstring</span><br><span class="line">0x103229A90	0x00009018	__DATA	__objc_classlist</span><br><span class="line">0x103232AA8	0x00000058	__DATA	__objc_nlclslist</span><br><span class="line">0x103232B00	0x00000A08	__DATA	__objc_catlist</span><br><span class="line">0x103233508	0x00000048	__DATA	__objc_nlcatlist</span><br><span class="line">0x103233550	0x000015A0	__DATA	__objc_protolist</span><br><span class="line">0x103234AF0	0x00000008	__DATA	__objc_imageinfo</span><br><span class="line">0x103234AF8	0x00501000	__DATA	__objc_const</span><br><span class="line">0x103735AF8	0x0003A320	__DATA	__objc_selrefs</span><br><span class="line">0x10376FE18	0x00000498	__DATA	__objc_protorefs</span><br><span class="line">0x1037702B0	0x00007DF8	__DATA	__objc_classrefs</span><br><span class="line">0x1037780A8	0x000058C0	__DATA	__objc_superrefs</span><br><span class="line">0x10377D968	0x00016B0C	__DATA	__objc_ivar</span><br><span class="line">0x103794478	0x000BD7F0	__DATA	__objc_data</span><br><span class="line">0x103851C70	0x00063DED	__DATA	__data</span><br><span class="line">0x1038B5A60	0x000000B8	__DATA	__swift_hooks</span><br><span class="line">0x1038B5B18	0x000000B8	__DATA	__swift51_hooks</span><br><span class="line">0x1038B5BD0	0x0006E528	__DATA	__bss</span><br><span class="line">0x103924400	0x00007090	__DATA	__common</span><br></pre></td></tr></table></figure>

<p>Segment划分为不同的Section，不同的Section存储着不同的信息，下面是一些常用的Section的介绍</p>
<h6 id="TEXT段的Section"><a href="#TEXT段的Section" class="headerlink" title="__TEXT段的Section"></a><strong><code>__TEXT</code></strong>段的<code>Section</code></h6><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>__text</code></td>
<td>代码节，存放机器编译后的代码</td>
</tr>
<tr>
<td><code>__stubs</code></td>
<td>用于辅助做动态链接代码（<code>dyld</code>）</td>
</tr>
<tr>
<td><code>__stub_helper</code></td>
<td>用于辅助做动态链接</td>
</tr>
<tr>
<td><code>__objc_methname</code></td>
<td>objc的方法名称</td>
</tr>
<tr>
<td><code>__stub_helper</code></td>
<td>用于辅助做动态链接</td>
</tr>
<tr>
<td><code>__cstring</code></td>
<td>代码运行中包含的字符串常量,  例：<code>#define kKey @&quot;123&quot;</code>,  <code>123</code>会存在这个区里</td>
</tr>
<tr>
<td><code>__objc_classname</code></td>
<td>类名</td>
</tr>
<tr>
<td><code>__objc_methtype</code></td>
<td>方法类型</td>
</tr>
<tr>
<td><code>__ustring</code></td>
<td></td>
</tr>
<tr>
<td><code>__gcc_except_tab</code></td>
<td></td>
</tr>
<tr>
<td><code>__const</code></td>
<td>存储<code>const</code>修饰的常量</td>
</tr>
<tr>
<td><code>__dof_RACSignal</code></td>
<td></td>
</tr>
<tr>
<td><code>__dof_RACCompou</code></td>
<td></td>
</tr>
<tr>
<td><code>__unwind_info</code></td>
<td></td>
</tr>
</tbody></table>
<h6 id="DATA段中的-Section"><a href="#DATA段中的-Section" class="headerlink" title="__DATA段中的 Section"></a><strong><code>__DATA</code>段中的 <code>Section</code></strong></h6><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>__got</code></td>
<td>存储引用符号的实际地址，类似于动态符号表</td>
</tr>
<tr>
<td><code>__la_symbol_ptr</code></td>
<td><code>lazy symbol pointers。</code> 懒加载的函数指针地址。 配合<code>__stubs</code>和<code>stub_helper</code>使用。</td>
</tr>
<tr>
<td><code>__mod_init_func</code></td>
<td>模块初始化的方法</td>
</tr>
<tr>
<td><code>__const</code></td>
<td>存储<code>constant</code>常量的数据。 比如使用<code>extern</code>导出的<code>const</code>修饰的常量。</td>
</tr>
<tr>
<td><code>__cfstring</code></td>
<td><code>Core Foundation</code> 字符串</td>
</tr>
<tr>
<td><code>__objc_classlist</code></td>
<td><code>OC</code>类列表和类信息 映射了<code>__objc_data</code>的地址</td>
</tr>
<tr>
<td><code>__objc_nlclslist</code></td>
<td><code>OC</code> 的 <code>+load</code> 函数列表， 比 <code>__mod_init_func</code> 更早执行</td>
</tr>
<tr>
<td><code>__objc_catlist</code></td>
<td><code>categories</code></td>
</tr>
<tr>
<td><code>__objc_nlcatlist</code></td>
<td>categories<code>的</code>+load`函数列表</td>
</tr>
<tr>
<td><code>__objc_protolist</code></td>
<td>协议列表</td>
</tr>
<tr>
<td><code>__objc_imageinfo</code></td>
<td>镜像信息</td>
</tr>
<tr>
<td><code>__objc_const</code></td>
<td><code>OC</code>常量。保存<code>objc_classdata</code>结构体数据。 用于映射类相关数据的地址，比如类名，方法名等</td>
</tr>
<tr>
<td><code>__objc_selrefs</code></td>
<td>引用的 <code>OC</code> 方法</td>
</tr>
<tr>
<td><code>__objc_protorefs</code></td>
<td>引用的 <code>OC</code> 协议</td>
</tr>
<tr>
<td><code>__objc_classrefs</code></td>
<td>引用的 <code>OC</code> 类</td>
</tr>
<tr>
<td><code>__objc_superrefs</code></td>
<td>引用的 <code>OC</code>超类</td>
</tr>
<tr>
<td><code>__objc_ivar</code></td>
<td><code>ivar</code>指针</td>
</tr>
<tr>
<td><code>__objc_data</code></td>
<td>用于保存类需要的数据。 最主要的内容是映射__objc_const地址， 找到类的相关数据。</td>
</tr>
<tr>
<td><code>__data</code></td>
<td>存放了协议和已经初始化的静态量</td>
</tr>
<tr>
<td><code>__bss</code></td>
<td>存储未初始化的静态量</td>
</tr>
<tr>
<td><code>__common</code></td>
<td>存储导出的全局的数据</td>
</tr>
</tbody></table>
<h5 id="Symbols-部分"><a href="#Symbols-部分" class="headerlink" title="Symbols 部分"></a><code>Symbols</code> 部分</h5><ul>
<li>Address：方法代码的地址</li>
<li>Size：方法占有的空间</li>
<li>File：文件的编号</li>
<li>Name：.o文件里面的方法符号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Symbols:</span><br><span class="line"># Address	Size    	File  Name</span><br><span class="line">0x100007CCC	0x00000204	[  1] -[UIView(Transform) setAnchorPoint:]</span><br><span class="line">0x100007ED0	0x0000002C	[  1] _CGPointMake</span><br><span class="line">0x100007EFC	0x0000010C	[  2] -[GMCardViewModel excutedGetCardList:completeBlock:]</span><br><span class="line">0x100008008	0x000003CC	[  2] -[GMCardViewModel excuteSkinDetailCardList:]</span><br><span class="line">0x1000083D4	0x0000019C	[  2] ___44-[GMCardViewModel excuteSkinDetailCardList:]_block_invoke</span><br><span class="line">0x100008570	0x00000058	[  2] ___copy_helper_block_e8_32b40w</span><br><span class="line">0x1000085C8	0x00000048	[  2] ___destroy_helper_block_e8_32s40w</span><br><span class="line">0x100008610	0x000004D8	[  2] -[GMCardViewModel excuteGroupFeedCardList:]</span><br><span class="line">0x100008AE8	0x000001B8	[  2] ___43-[GMCardViewModel excuteGroupFeedCardList:]_block_invoke</span><br><span class="line">0x100008CA0	0x000000A4	[  2] ___43-[GMCardViewModel excuteGroupFeedCardList:]_block_invoke.110</span><br><span class="line">0x100008D44	0x000004D8	[  2] -[GMCardViewModel excuteTopicFeedCardList:]</span><br><span class="line">0x10000921C	0x000001B8	[  2] ___43-[GMCardViewModel excuteTopicFeedCardList:]_block_invoke</span><br><span class="line">0x1000093D4	0x000000A4	[  2] ___43-[GMCardViewModel excuteTopicFeedCardList:]_block_invoke_2</span><br><span class="line">0x100009478	0x00000648	[  2] -[GMCardViewModel excuteAIFeedCardList:]</span><br><span class="line">0x100009AC0	0x00000200	[  2] ___40-[GMCardViewModel excuteAIFeedCardList:]_block_invoke</span><br><span class="line">0x100009CC0	0x00000070	[  2] ___copy_helper_block_e8_32s40b48w</span><br><span class="line">0x100009D30	0x00000064	[  2] ___destroy_helper_block_e8_32s40s48w</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>Symbols部分的File顺序适合<strong><code>Target -&gt; Build Phase -&gt; Compile Sources</code></strong>的文件顺序是一致的</p>
<p>二进制重排就是要重新排列这些方法符号的顺序，中心思想就是将启动用到的代码挪到前面位置加载。</p>
<h3 id="order-file"><a href="#order-file" class="headerlink" title="order_file"></a>order_file</h3><p>Xcode提供了排列符号的设置给开发者，设置order_file即可，苹果在一直在做这方面的优化，objc源码就采用了二进制重排优化。</p>
<h4 id="设置order-file"><a href="#设置order-file" class="headerlink" title="设置order_file"></a>设置order_file</h4><p>在根目录生成link.order文件，这里面就是方法符号的排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim xxx_link.order</span><br></pre></td></tr></table></figure>

<p><code>Target -&gt; Build Setting -&gt; Linking -&gt; Order File</code> 设置 <code>order file</code> 的路径</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20201228192825215.png" alt="image-20201228192825215"></p>
<h4 id="编写order-file文件"><a href="#编写order-file文件" class="headerlink" title="编写order_file文件"></a>编写order_file文件</h4><p>编写<code>order_file</code>文件的方式，可以参考<a href="[opensource.apple.com](https://opensource.apple.com/)">obj源码</a>，查看其<code>order_file</code></p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20201228193020738.png" alt="image-20201228193020738"></p>
<p>Link Map File文件中符号表是先加载<code>-[AppDelegate application:didFinishLaunchingWithOptions:]</code>其他符号信息，再加载<code>-[AppDelegate setupEnterApp]</code></p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20201228193341997.png" alt="image-20201228193341997"></p>
<p>编写一下<code>link.order</code>试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_main</span><br><span class="line">-[AppDelegate setupEnterApp]</span><br><span class="line">-[AppDelegate application:didFinishLaunchingWithOptions:]</span><br></pre></td></tr></table></figure>

<p><code>command + K</code> 后 <code>command + B</code> 再查看一下 <code>Link Map File</code>，顺序已经换过来了</p>
<p><img src="http://qn49kho58.bkt.gdipper.com/image-20201228193941872.png" alt="image-20201228193941872"></p>
<h4 id="自动生成order-file"><a href="#自动生成order-file" class="headerlink" title="自动生成order_file"></a>自动生成order_file</h4><p>全手写容易出现问题，想要自动化就要解决下列问题：</p>
<ul>
<li>保证不遗漏方法</li>
<li>保证方法符号正确</li>
<li>保证方法符号顺序正确</li>
</ul>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><a href="https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q" target="_blank" rel="noopener">《抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%》</a>，抖音团队使用的静态扫描+运行时trace的方案，能够覆盖80～90%的符号，但是该方法也存在性能瓶颈</p>
<ul>
<li>Initialize hook不到</li>
<li>部分block hook不到</li>
<li>C++通过寄存器的间接函数调用静态扫描不出来</li>
</ul>
<p>为了解决这个问题，需要引入另外一个方案 编译器cha z</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/25/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-%E5%92%8C-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-%E5%92%8C-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">虚拟内存 和 物理内存</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-25 10:40:39 / Modified: 20:24:04" itemprop="dateCreated datePublished" datetime="2020-12-25T10:40:39+08:00">2020-12-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先抛出几个让大家思考的问题</p>
<blockquote>
<ul>
<li>汇编代码：mov eax, 0x123456；它的意思是将内存0x123456处的内容送往寄存器。各个应用的数据共同存在于内存中的。假设有一个音乐播放器应用的汇编代码中，引用了0x123456这个内存地址，但是同事运行的应用有很多，那其他应用也完全有可能引用0x123456这个地址，那为什么完全没有冲突和错误呢？</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>进程是计算机领域最重要的概念之一，什么是进程？进程是关于某次数据集合的一次运行活动，是运行在它自己地址空间的一段自包容程序，解析的通俗的点，一个程序在运行时，我们会得到一个假象，改进程好像是独占的使用CPU和内存，CPU是没有间断的一条接一条的执行该程序的指令，所有的内存空间都是供该进程的代码和数据分配使用的。（这点不严谨，其实内存还要一部分分给内核kernel）说起来，这个程序好像得到了全世界一样，但这是假象，这些假象又是如何做到的呢？</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>程序中都会引入库API，比如每个C程序都要引入stdio.h库的printf()，在程序运行时，库代码也要被加入到内存，这么多程序都引用了这个库，难道我内存中需要加很多份？这自然不可能，那么库代码又是怎么被所有进程共享的呢？</li>
</ul>
</blockquote>
<h4 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h4><p>在访问者看来，主存就是一个有M个字节大小的单元组成的数组，每字节都有一个唯一的物理地址（Physical Address,PA）它的访问地址和数组一样，第一个地址为0，后面依次为1，2，3——M-2，M-3；这叫做线性地址空间。这种自然的访问内存的方式我们称之为物理寻址（Physical Addressing）。</p>
<blockquote>
<p>注意：在访问内存时，对于任意一个地址（不管是0，还是1）访问该地址的时间总是相同的。</p>
</blockquote>
<blockquote>
<p>Q：在各种数组结构中，我们都说Hash表是最快的，比红黑树都要快，那么为什么hash是最快的？</p>
<p>A：hash表内部本质是使用了数组，根据数组的起始地址以及某个元素的序号，就可以得到该元素在内存中的地址，而对于内存，访问任意一个地址，访问时间总是相同的。</p>
</blockquote>
<p>使用物理寻址的系统：</p>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834ac115647a.png" alt="1614834ac115647a"></p>
<p>上图是一个使用物理寻址的示例，这是一条加载指令，它读取从物理地址4开始的4个字节，CPU通过内存总线，将指令和地址传递给主存，主存读取物理地址4处开始的4个字节，返回给CPU。</p>
<p>早期计算时使用物理寻址方式，但是到了现在的多任务计算机时代，普遍使用的是虚拟寻址（virtual addressing）如下图所示：</p>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834abb0b6916.png" alt="1614834abb0b6916"></p>
<p>CPU通过虚拟地址（virtual address，VA）来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址，将虚拟地址转换成物理地址的任务叫做地址翻译（address translate）。</p>
<p>地址翻译需要CPU硬件和操作系统之间的配合。CPU芯片上叫做内存管理单元（Menory Management Unit,MMU）的专用硬件，利用存放在主存中的茶轩表来动态翻译虚拟地址，该表的内容由操作系统管理。</p>
<blockquote>
<p>有少数现代计算机系统依旧在使用物理寻址方式，比如DSP，嵌入式系统，超级计算机系统。这些系统的主要任务是执行单一任务，不香通用性计算机那样需要执行多任务，可以想象，物理寻址方式更快。</p>
</blockquote>
<p>解释完虚拟寻址，关于文章开头的提问，已经有一些答案了。那些地址都是虚拟地址，并非真实的物理内存中的地址。</p>
<h4 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h4><p><img src="/Users/mikasa/Downloads/1614834ac31b22d5.png" alt="1614834ac31b22d5"></p>
<p>上图是一个64位的进程地址空间，编译器在编译程序时，将结果编译成32/64位的地址空间，虚拟寻址方式简化了编译器、链接器的工作。同样也因为虚拟内存，每个进程才能有很大的，一致的，私有的地址空间。这方便了内存管理，保护了每个进程的地址空间不被其他进程破坏。同时也方便了共享库。</p>
<h4 id="虚拟内存的缓存"><a href="#虚拟内存的缓存" class="headerlink" title="虚拟内存的缓存"></a>虚拟内存的缓存</h4><p>虚拟内存将主存堪称一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</p>
<p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，也就是字节数组，</p>
<p>每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内存被缓存在主存中，在存储器层次结构中，磁盘的数据被分割成块，这些块作为和主存之间的传输单元，主存作为虚拟内存的缓存。</p>
<p>虚拟内存（VM）系统将虚拟内存分割成为大小固定的虚拟页（Virtual Page,PV），每个虚拟也的大小为固定页。同样的，物理内存被分割为物理页（Physical Page，PP），大小也为固定字节，物理页也称页帧，page Frame。</p>
<p>在任意时刻，虚拟页面都分为三个不相交的部分：</p>
<ul>
<li>为分配的（unallocated）：VM系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间</li>
<li>缓存的（Cached）：当前已缓存在物理内存中的已分配页。</li>
<li>未缓存的（UnCached）:该页已经映射到磁盘上，但是还没缓存中物理内存中。</li>
</ul>
<blockquote>
<p>其中未分配的VP不占用任何的实际物理空间，32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数组，而目前我们的电脑高配也就是2T磁盘，16G内存。如果64位程序每个VP都映射着时间的PP，无论如何也对应不上的，并且也完全没必要一一映射，从上图中可以看到地址空间内有大量的恐怖，毕竟程序不可能实际使用那么大的地址空间。</p>
</blockquote>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834ac0ae8581.png" alt="1614834ac0ae8581"></p>
<p>VM使用主存来作为缓存</p>
<p>上图展示了一个有8个页面的虚拟内存中，虚拟页0和3还未分配，所以在磁盘上不存在，虚拟页1、4、6被缓存在物理内存中，虚拟也2、5、7已经被映射分配了，但是还没有缓存在主存中。</p>
<h4 id="页表（Page-Table）"><a href="#页表（Page-Table）" class="headerlink" title="页表（Page Table）"></a>页表（Page Table）</h4><p>系统需要有办法判定某个虚拟页是否缓存在主存的某个地方。</p>
<ul>
<li>已经在主存中，需要判断该虚拟页存在于哪个物理页中</li>
<li>不在主存中，系统需要判断虚拟页存放在磁盘的哪个位置，并且物理主存中选择一个牺牲页，并将该虚拟页从磁盘复制到主存，替换到主存，替换这个牺牲页。</li>
</ul>
<p>这些功能由软硬件联合提供，包括操作系统，CPU中的内存管理单元（Memory Maneagement Unit，MMU）和一个存放在物理内存中叫页表（page table）的数据结构，页表将虚拟页映射到物理页，每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。</p>
<p>页表：</p>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834af5c46c0f.png" alt="1614834af5c46c0f"></p>
<p>上图展示了一个页表的基本结构，页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址的每个页在页表中都有一个队员的PTE，在这里我们假设每个PTE是由一个有效位（Valid bie）和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在主存中。</p>
<ul>
<li>有效位为1，则主存缓存了该虚拟页，地址字段就表示了主存中相应的物理页的起始位置</li>
<li>有效位为0，则地址字段的null表示这个虚拟页还未被分配，否则该地址就指向该虚拟页在磁盘的起始位置</li>
</ul>
<h4 id="页命中和缺页"><a href="#页命中和缺页" class="headerlink" title="页命中和缺页"></a>页命中和缺页</h4><p>当CPU想要读取包含在某个虚拟页的内容时，如果该页已经缓存在主页中，也就是页命中，但是如果该页没有缓存在主存中，则我们称之为缺页。</p>
<h5 id="Page-Dault"><a href="#Page-Dault" class="headerlink" title="Page Dault"></a>Page Dault</h5><p><img src="/Users/mikasa/Desktop/image_mark/1614834af5d7f384.png" alt="1614834af5d7f384"></p>
<p>图上对VP3中的字的应用会引起不命中</p>
<p>如上图所示，CPU引用了VP3中的内容，VP3并未缓存在主存中，系统从内存中读取PTE3，得知VP3未被缓存，这会触发一个缺页异常。缺页异常会调用kernel的缺页异常处理程序，该程序会选择一个牺牲页，如下图所示，牺牲页选择了存放在PP3中的VP4</p>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834af763527c.png" alt="1614834af763527c"></p>
<p>图中VP4的内容被修改了，kernel会将它复制回磁盘，接下来，kernel从磁盘赋值VP3到内存中的PP3并更新PTE3。随后返回用户进程，当异常处理程序换回时，他回重启执行导致缺页的指令，当重新执行这条指令时，VP3已经在主存中，此时就是页命中了。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834af8ee1780.png" alt="1614834af8ee1780"></p>
<p>VP3被缓存到PP3</p>
<p>根据习惯性叫法，我们在磁盘和内存之间传送页的活动叫做交换 或者 页面调度，这种交换活动，只有当不命中发生时才会发生，也就是说，系统并不会将磁盘内容预存到内存中。这种策略被称之为按需页面调度（demand paging）</p>
<blockquote>
<p>我们刚才说，缺页是一种异常，但是实际上，在计算机系统中，被0除，读写文件，还有之前提到的中断（interrupt），甚至包括我们代码里面常写的（try catch），都是一种异常，比如被0除是intel的CPU规定的第0号故障（fault）类型的异常，而读写文件，分别是linux规定的第0号和第1号陷阱trap类型的异常。多任务的上下文切换，进程的创建、回收等系统中异常流的处理密切相关。</p>
</blockquote>
<h4 id="虚拟内存作为内存管理和内存保护的工具"><a href="#虚拟内存作为内存管理和内存保护的工具" class="headerlink" title="虚拟内存作为内存管理和内存保护的工具"></a>虚拟内存作为内存管理和内存保护的工具</h4><p>理所当然，每个进程都有一个独立的页表和一个独立的虚拟地址空间</p>
<p>回到文章开头，比如每个C程序都要调用stdio这个库，不可能为每个进程都添加一份库，内存中只有一份stdio库的内容，供每个使用该库的进程共享。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834b1b3f3447.png" alt="1614834b1b3f3447"></p>
<p>图18：共享页面</p>
<p>如上图所示：第一个进程的页表将VP2映射到某个物理页面，而第二个进程同样将它的VP2映射到该物理页面，此时物理页面被两个进程共享了。</p>
<blockquote>
<p>此时再看一次“进程地址空间”就会发现在地址空间当中，“共享库的内存映射区域”对于每个进行起始地址都是相同的。再想想进程之前共享内存的通信方式，所以说虚拟内存简化了共享机制。</p>
</blockquote>
<p>大家知道，C语言中存在指针，可以直接进行内存操作，因为有了虚拟内存，所以我们的指针操作不会访问到进程的区域，但是哪怕是对于自己的地址空间，很多内存区域也应该是禁止访问的，这不仅包括kernel的区域，也包括自己的只读代码段。那么虚拟内存就提供了这样的一种内存保护工具。</p>
<p>地址翻译机制 可以使用一种自然的方式来提供内存的访问控制，PTE上添加一些额外的控制位来添加权限，每次CPU生成一个地址时，地址翻译硬件就会读一个PTE。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/1614834b1bd41e06.png" alt="1614834b1bd41e06"></p>
<p>图19:虚拟内存提供内存保护</p>
<p>在上图中每个PTE额外添加了三个控制位，SUP位表示进程是否必须运行内核模式，READ 和 WRITE位分别控制页面的读写权限。如果有指令违法了这些控制权限，那么CPU就会触发一个故障，并将控制传递给内核中的异常处理程序，这种异常一般称为 段错误（segmentation fault）。</p>
<h4 id="段-和-页"><a href="#段-和-页" class="headerlink" title="段 和 页"></a>段 和 页</h4><p>我们明白了页，页是操作系统为了管理主存方便而划分的，对用户不可见，但是思考这种情况，假设一个页的大小是1M，但是某个程序加起来也就0.5M，所以内存和磁盘进行页交换明显的浪费内存了，所以还有一种划分方式就是分段。上面那种情况，我将该段划分为0.5M，在内存和磁盘之间交换，这样就避免了浪费。</p>
<p>段是信息的逻辑单元，是根据用户需求而灵活划分的，所以大小不固定，对用户是可见的，提供的是二维地址空间。</p>
<h4 id="swap分区的作用"><a href="#swap分区的作用" class="headerlink" title="swap分区的作用"></a>swap分区的作用</h4><p>Linux有一个swap分区，Swap空间的作用可简单描述为：当系统的物理内存不够的时候，几句需要将物理内存中的一部分空间释放出来</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/21/%E4%B8%80%E6%AC%A1Crash%E8%B7%9F%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/%E4%B8%80%E6%AC%A1Crash%E8%B7%9F%E8%B8%AA/" class="post-title-link" itemprop="url">一次Crash跟踪</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-21 16:43:40" itemprop="dateCreated datePublished" datetime="2020-12-21T16:43:40+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-22 14:08:47" itemprop="dateModified" datetime="2020-12-22T14:08:47+08:00">2020-12-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一次偶然的机会，线上反馈用户手机出现了打开App即Crash的情况，根据用户提供时间点以及视频信息，我们查看了bugly和尝试本地复现，很遗憾，都没有相关有用信息。</p>
<p>这时想到了，用户分析本机中可能存在log信息。</p>
<h4 id="获取Crash文件"><a href="#获取Crash文件" class="headerlink" title="获取Crash文件"></a>获取Crash文件</h4><p>设置-&gt;分析与改进-&gt;分析数据，找到当天对应的Crash文件，分享到电脑上。</p>
<h4 id="获取-ipa包的UUID"><a href="#获取-ipa包的UUID" class="headerlink" title="获取.ipa包的UUID"></a>获取.ipa包的UUID</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun dwarfdump --uuid xxx.app/xxx</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID: 464A42BE-DB0F-3DF5-ABA7-F3CC4C4944CF (armv7) xxx.app/xxx</span><br><span class="line">UUID: F89C620B-0D6F-3422-A9BE-1C84FC827111 (arm64) xxx.app/xxx</span><br></pre></td></tr></table></figure>

<h4 id="查看Crash文件的UUID"><a href="#查看Crash文件的UUID" class="headerlink" title="查看Crash文件的UUID"></a>查看Crash文件的UUID</h4><p>打开Crash日志，直接搜索<code>Binary Images</code>，对应的就是uuid</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x100110000 - 0x10283ffff xxx arm64  &lt;f89c620b0d6f3422a9be1c84fc827111&gt; /var/containers/Bundle/Application/66BFB77D-3B41-42F2-A283-3F96EB4AD716/xxx.app/xxx</span><br></pre></td></tr></table></figure>

<p>可以看到crash日志中的uuid与ipa包中的uuid对应上了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f89c620b0d6f3422a9be1c84fc827111</span><br></pre></td></tr></table></figure>

<h4 id="查看-dSYM文件的UUID"><a href="#查看-dSYM文件的UUID" class="headerlink" title="查看.dSYM文件的UUID"></a>查看.dSYM文件的UUID</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid xxx.app.dSYM</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID: 464A42BE-DB0F-3DF5-ABA7-F3CC4C4944CF (armv7) xxx.app.dSYM/Contents/Resources/DWARF/xxx</span><br><span class="line">UUID: F89C620B-0D6F-3422-A9BE-1C84FC827111 (arm64) xxx.app.dSYM/Contents/Resources/DWARF/xxx</span><br></pre></td></tr></table></figure>

<h4 id="symbolicatecrash"><a href="#symbolicatecrash" class="headerlink" title="symbolicatecrash"></a>symbolicatecrash</h4><h5 id="获取解析工具symbolicatecrash所在位置"><a href="#获取解析工具symbolicatecrash所在位置" class="headerlink" title="获取解析工具symbolicatecrash所在位置"></a>获取解析工具symbolicatecrash所在位置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;SharedFrameworks&#x2F;DVTFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Resources&#x2F;symbolicatecrash</span><br></pre></td></tr></table></figure>

<p>按照格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbolicatecrash .crash文件 .dSYM文件 &gt;result.log</span><br></pre></td></tr></table></figure>

<p>拼装命令，执行即可获得解析结果result.log</p>
<h5 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash /Users/mikasa/Documents/Crash/xxx-2020-12-20-212420.ips xxx.app.dSYM &gt;result.log</span><br></pre></td></tr></table></figure>

<p>终端可能会出现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: "DEVELOPER_DIR" is not defined at /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash line 69.</span><br></pre></td></tr></table></figure>

<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p>再执行命令，在终端完成以后，在Crash文件夹中就会多出一个result.log文件，可以查看bug的崩溃信息。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201221184525739.png" alt="image-20201221184525739"></p>
<h4 id="如何找回已发布到App-Store的App对应的dSYM文件？"><a href="#如何找回已发布到App-Store的App对应的dSYM文件？" class="headerlink" title="如何找回已发布到App Store的App对应的dSYM文件？"></a>如何找回已发布到App Store的App对应的dSYM文件？</h4><h5 id="通过Xcode找回"><a href="#通过Xcode找回" class="headerlink" title="通过Xcode找回"></a>通过Xcode找回</h5><ul>
<li>打开 Xcode 顶部菜单栏 -&gt; Window -&gt; Organizer 窗口</li>
<li>打开 Xcode 顶部菜单栏，选择 Archive 标签</li>
<li>找到发布的归档包，右键点击对应归档包，选择Show in Finder操作</li>
<li>右键选择定位到的归档文件，选择显示包内容操作</li>
<li>选择dSYMs目录，目录内即为下载到的 dSYM 文件</li>
</ul>
<h5 id="通过iTunes-Connect找回"><a href="#通过iTunes-Connect找回" class="headerlink" title="通过iTunes Connect找回"></a>通过iTunes Connect找回</h5><ul>
<li>登录<a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">iTunes Connect</a></li>
<li>进入“我的App（My Apps）”的“活动（Activity）”页面</li>
<li>在“所有构件版本（All Builds）”中选择某一个版本，点“下载dSYM（Download dSYM）”下载dSYM文件</li>
</ul>
<h5 id="通过mdfind工具找回"><a href="#通过mdfind工具找回" class="headerlink" title="通过mdfind工具找回"></a>通过mdfind工具找回</h5><ul>
<li><p>查询到crash对应的UUID</p>
</li>
<li><p>然后在Mac的Shell中，用mdfind命令定位dSYM文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdfind "com_apple_xcode_dsym_uuids == &lt;UUID&gt;"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，使用mdfind时，UUID需要格式转换（增加“-”）： 12345678-1234-1234-1234-xxxxxxxxxxxx</p>
</blockquote>
</li>
</ul>
<p>例如，要定位的dSYM的UUID为：f89c620b0d6f3422a9be1c84fc827111 则定位dSYM文件的命令如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdfind "com_apple_xcode_dsym_uuids == F89C620B-0D6F-3422-A9BE-1C84FC827111"</span><br></pre></td></tr></table></figure>



<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><blockquote>
<p><a href="https://bugly.qq.com/docs/user-guide/symbol-configuration-ios/?v=20170912151050#app-storeappdsym" target="_blank" rel="noopener">Bugly iOS符号表配置</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/21/%E6%B5%85%E8%B0%88iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E5%8E%8B%E7%BC%A9%E4%BB%8E%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/%E6%B5%85%E8%B0%88iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E5%8E%8B%E7%BC%A9%E4%BB%8E%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">浅谈iOS图片解压缩从文件渲染到屏幕的过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-21 14:28:48" itemprop="dateCreated datePublished" datetime="2020-12-21T14:28:48+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-24 18:15:27" itemprop="dateModified" datetime="2020-12-24T18:15:27+08:00">2020-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>概述</p>
<p>将一张图片从磁盘中加载出来，并最终显示到屏幕上，中间其实经过了一系列复杂的处理过程，从文件到屏幕，其中包括了对图片的解压缩操作。</p>
<h4 id="渲染图片到屏幕的过程"><a href="#渲染图片到屏幕的过程" class="headerlink" title="渲染图片到屏幕的过程"></a>渲染图片到屏幕的过程</h4><p><img src="/Users/mikasa/Desktop/image_mark/16cfbeb484307840.png" alt="16cfbeb484307840"></p>
<p>如上所示，图片渲染到屏幕上，是CPU和GPU协作完成的。</p>
<p>CPU/GPU等这样一次渲染过程中的具体分工：</p>
<ul>
<li>CPU：计算视图frame、图片解码、需要绘制纹理图片通过数据总线交给GPU</li>
<li>GPU：纹理混合、顶点变换与计算、像素点的填充计算、渲染到帧缓冲区</li>
<li>时钟信号：垂直同步信息V-Sync/水平同步信息H-Sync</li>
<li>iOS设备双缓冲机制：显示系统通常会引入两个帧缓冲区，双缓冲机制</li>
</ul>
<h4 id="什么是垂直同步信号和水平同步信息？"><a href="#什么是垂直同步信号和水平同步信息？" class="headerlink" title="什么是垂直同步信号和水平同步信息？"></a>什么是垂直同步信号和水平同步信息？</h4><p><img src="/Users/mikasa/Desktop/image_mark/16cfbeb48572eaa2.png" alt="16cfbeb48572eaa2"></p>
<blockquote>
<p>从上图看，每一行从左到右就叫水平刷新，从上到下就叫垂直信号。整个屏幕刷新完毕，就会发出V-Sync信号。可以简单的用超市买单的扫枪码来理解，扫一个商品二维码后就会出现一个H-Sync信号，扫完所有商品的二维码后，计算商品总价后就相当于发送一个V-Sync信号。从CRT显示器的显示原理来看，单个像素组成了水平扫描线，水平扫描线在垂直方向的堆积形成了完整的画面。显示器的刷新率受显卡DAC控制，显卡DAC完成一帧的扫描后就会产生一个垂直同步信号。</p>
</blockquote>
<h4 id="图片加载的工作流程"><a href="#图片加载的工作流程" class="headerlink" title="图片加载的工作流程"></a>图片加载的工作流程</h4><p>iOS从磁盘加载一张图片，使用UIImageView显示在屏幕上，加载流程如下：</p>
<ul>
<li><p>使用<code>+ (nullable UIImage *)imageWithContentsOfFile:(NSString *)path;</code>（使用Image/IO创建CGImageRef内存映射数据）方法从磁盘加载一张图片，此时图像尚未解码。</p>
<blockquote>
<p>这个过程先把磁盘拷贝数据到内核缓冲区，再从内核缓冲区复制数据到用户空间</p>
</blockquote>
</li>
<li><p>生成UIImageView，将图像数据赋值给UIImageView，如果图像数据为解码（PNG/JPG），解码为位图数据</p>
</li>
<li><p>隐式CATransaction捕获UIImageView layer树变化</p>
</li>
<li><p>在主线程的下一次runloop到来时，Core Animation提交了这个隐式的transaction，这个过程可能会对图片进行copy操作，如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐，看你会涉及到以下操作：</p>
<ul>
<li>分配内存缓冲区用于管理文件IO和解压缩操作</li>
<li>将文件数据从磁盘读取到内存中</li>
<li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的CPU操作，并且解码出来的图片体积和图片的宽高有关系，而与图片原来的体积无关。</li>
<li>最后Core Animation中CALayer使用未压缩的位图数据渲染UIImageView的图层</li>
<li>CPU计算好图片的Frame，对图片解码之后，就会交给GPU，GPU处理位图数据，进行渲染</li>
</ul>
</li>
<li><p>渲染流程</p>
<ul>
<li>GPU获取图片的坐标</li>
<li>将坐标交给顶点着色器VertexShader(顶点计算)</li>
<li>将图片光栅化（获取图片对应屏幕上的像素点，实际绘制或填充每个顶点之间的像素）</li>
<li>片元着色器FragmentShader计算（计算每个像素点的最终显示的颜色值）</li>
<li>从帧缓冲区渲染到屏幕上</li>
</ul>
</li>
</ul>
<blockquote>
<p>CPU 和 GPU的互相配合</p>
<p><img src="/Users/mikasa/Desktop/image_mark/16cfbeb485755223.png" alt="16cfbeb485755223"></p>
</blockquote>
<h4 id="为什么需要解压缩"><a href="#为什么需要解压缩" class="headerlink" title="为什么需要解压缩"></a>为什么需要解压缩</h4><p>图片的解压缩是需要消耗大量CPU时间，那为什么还需要对图片进行解压缩操作呢？首先需要了解什么是位图：</p>
<blockquote>
<p>位图（Bitmap）</p>
<p>又称栅格图（Raster grphics）或点阵图，是使用像素阵列（Pixel-array/Dot-matrix点阵）来表示的图像。</p>
</blockquote>
<p>其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点，我们在应用中经常用到的JPEG 和 PNG图片就是位图。</p>
<p>获取图片的原始像素数据</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"2.png"</span>];</span><br><span class="line"><span class="built_in">CFDataRef</span> dataRef = <span class="built_in">CGDataProviderCopyData</span>(<span class="built_in">CGImageGetDataProvider</span>(image.CGImage));</span><br></pre></td></tr></table></figure>

<p>解压缩后的图片大小和原始文件大小之间没有任何关系，而只与图片的像素有关：<code>解压缩后的图片大小=图片的像素宽*图片的像素高*每个像素所占的字节数</code></p>
<p>事实上，不管是JPEG还是PNG图片，都是一种压缩的位图图形。只不过PNG图片是无损压缩，并且支持alpha通道，而JPEG图片是无损压缩，可以指定0～100%。值得关注的是，苹果在SDK中提供了两个函数用来生成PNG和JPEG图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span>  <span class="built_in">NSData</span> * __<span class="keyword">nullable</span> <span class="built_in">UIImagePNGRepresentation</span>(<span class="built_in">UIImage</span> * __<span class="keyword">nonnull</span> image);                               <span class="comment">// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span>  <span class="built_in">NSData</span> * __<span class="keyword">nullable</span> <span class="built_in">UIImageJPEGRepresentation</span>(<span class="built_in">UIImage</span> * __<span class="keyword">nonnull</span> image, <span class="built_in">CGFloat</span> compressionQuality);  <span class="comment">// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。</p>
</blockquote>
<h4 id="解压缩原理"><a href="#解压缩原理" class="headerlink" title="解压缩原理"></a>解压缩原理</h4><p>当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，通常会在子线程提前对图片进行强制解压缩。</p>
<p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是<code>CGBitmapContextCreate</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">CGContextRef</span> __<span class="keyword">nullable</span> <span class="built_in">CGBitmapContextCreate</span>(<span class="keyword">void</span> * __<span class="keyword">nullable</span> data,</span><br><span class="line">    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cg_nullable space, uint32_t bitmapInfo)</span><br><span class="line">    <span class="built_in">CG_AVAILABLE_STARTING</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>函数创建一个位图上下文，用来绘制一个宽width，高height像素的位图</p>
<ul>
<li>Data：如果不为NULL，那么它应该指向一块大小至少为bytesPerRow*height字节的内存；如果为NULL，那么系统会为我们自动分配和释放所需的内存，所以一般指定NULL即可；</li>
<li>width 和 height ：位图的宽度和高度，分别复制为图片的像素宽度和像素高度即可。</li>
<li>bitesPerComponent：像素的每个颜色分量使用的bit数，在RGB颜色空间下指定8即可；</li>
<li>bitesPerRow：位图的每一行使用字节数，大小至少是width * bytes per pixel字节。有一丝的是，当我们指定0，系统不仅会为我们自动计算，而且还会cache line alignment的优化<a href="https://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters" target="_blank" rel="noopener">what is byte alignment (cache line alignment) for Core Animation? Why it matters?</a></li>
</ul>
<h4 id="YYImage-SDWebImage开源框架实现"><a href="#YYImage-SDWebImage开源框架实现" class="headerlink" title="YYImage/SDWebImage开源框架实现"></a>YYImage/SDWebImage开源框架实现</h4><p>用于解压缩图片的函数YYCGImageCreateDecodedCopy函数存在于YYImageCoder类中，核心代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> YYCGImageCreateDecodedCopy(<span class="built_in">CGImageRef</span> imageRef, <span class="built_in">BOOL</span> decodeForDisplay) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!imageRef) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (decodeForDisplay) &#123; <span class="comment">//decode with redraw (may lose some precision)</span></span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BGRA8888 (premultiplied) or BGRX8888</span></span><br><span class="line">        <span class="comment">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span></span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef); <span class="comment">// decode</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(context);</span><br><span class="line">        <span class="keyword">return</span> newImage;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CGColorSpaceRef</span> space = <span class="built_in">CGImageGetColorSpace</span>(imageRef);</span><br><span class="line">        size_t bitsPerComponent = <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef);</span><br><span class="line">        size_t bitsPerPixel = <span class="built_in">CGImageGetBitsPerPixel</span>(imageRef);</span><br><span class="line">        size_t bytesPerRow = <span class="built_in">CGImageGetBytesPerRow</span>(imageRef);</span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef);</span><br><span class="line">        <span class="keyword">if</span> (bytesPerRow == <span class="number">0</span> || width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGDataProviderRef</span> dataProvider = <span class="built_in">CGImageGetDataProvider</span>(imageRef);</span><br><span class="line">        <span class="keyword">if</span> (!dataProvider) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CFDataRef</span> data = <span class="built_in">CGDataProviderCopyData</span>(dataProvider); <span class="comment">// decode</span></span><br><span class="line">        <span class="keyword">if</span> (!data) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGDataProviderRef</span> newProvider = <span class="built_in">CGDataProviderCreateWithCFData</span>(data);</span><br><span class="line">        <span class="built_in">CFRelease</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (!newProvider) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGImageCreate</span>(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, bitmapInfo, newProvider, <span class="literal">NULL</span>, <span class="literal">false</span>, kCGRenderingIntentDefault);</span><br><span class="line">        <span class="built_in">CFRelease</span>(newProvider);</span><br><span class="line">        <span class="keyword">return</span> newImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>YYImage加载流程：</p>
<ul>
<li>CGDataProviderCopyData获取图片二进制数据</li>
<li>使用CGBitmapContextCreate方法创建一个上下文对象</li>
<li>使用CGContextDrawImage方法绘制到上下文</li>
<li>使用CGBitmapContextCreateImage生成一个CGImageRef对象</li>
<li>使用imageWithCGImage方法将CGImage转化为UIImage</li>
</ul>
<blockquote>
<p>性能对比：</p>
<p>解压PNG图片：SDWebImageView &gt; YYImage</p>
<p>解压JPEG图片：SDWebImageView &lt; YYImage</p>
</blockquote>
<p>总结</p>
<ul>
<li>图片文件只有确认在要显示的时候，CPU才会对齐进行解压缩，因为解压缩是非常消耗性能的操作，解压缩后的图片不会重复解压，会缓存起来</li>
<li>UIImage有两种缓存，一种是UIImage类的缓存，这种缓存保证imageNamed初始化，UIImage只会被解码一次；另一种是UIImage对象的缓存，这种缓存保证只要UIImage没有被释放，就不会被再次解码</li>
<li>图片渲染到屏幕的过程：<ol>
<li>读取文件</li>
<li>图片解码</li>
<li>解码后纹理图片位图数据通过数据总线交给GPU</li>
<li>GPU获取图片Frame</li>
<li>顶点变换计算</li>
<li>光栅化</li>
<li>根据纹理坐标获取每个像素点的颜色值（如果出现透明值需要将每个像素点的颜色*透明度值）</li>
<li>渲染到帧缓冲区</li>
<li>渲染到屏幕</li>
</ol>
</li>
</ul>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕上</a></p>
<p><a href="https://juejin.cn/post/6847902216238399496" target="_blank" rel="noopener">iOS - 图形高级处理 (一、图片显示相关理论)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/17/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/" class="post-title-link" itemprop="url">知识小集</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-17 14:01:13" itemprop="dateCreated datePublished" datetime="2020-12-17T14:01:13+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-15 14:39:56" itemprop="dateModified" datetime="2021-01-15T14:39:56+08:00">2021-01-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><h4 id="UIView-和-CALayer的区别？"><a href="#UIView-和-CALayer的区别？" class="headerlink" title="UIView 和 CALayer的区别？"></a>UIView 和 CALayer的区别？</h4><ul>
<li>UIView继承至UIRespond，可以处理手势响应事件；CALayer继承至NSObject，不可以处理处理响应事件</li>
<li>UIView着重于内容管理，CALayer着重于内容绘制</li>
<li>UIView与CALayer之间存在依赖关系，UIView的显示依赖于CALayer的内容，CALayer依赖UIView的容器来绘制显示的内容</li>
<li>UIView来自CALayer，高于CALayer，是CALayer的高层展示与封装，UIView的特性均来来自于CALayer</li>
</ul>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><h4 id="dispatch-get-global-queue（全局队列）-和-dispatch-queue-create（自定义队列）区别？"><a href="#dispatch-get-global-queue（全局队列）-和-dispatch-queue-create（自定义队列）区别？" class="headerlink" title="dispatch_get_global_queue（全局队列） 和 dispatch_queue_create（自定义队列）区别？"></a><a href="https://stackoverflow.com/questions/10984885/what-is-the-difference-between-dispatch-get-global-queue-and-dispatch-queue-crea" target="_blank" rel="noopener">dispatch_get_global_queue（全局队列） 和 dispatch_queue_create（自定义队列）区别？</a></h4><p>1、全局队列是并发队列，可设置队列的优先级（只有三种），不需要创建销毁；自定义队列可自定义创建队列为串行队列或并发队列，不能设置优先级，需要自行管理创建销毁<br>2、不建议再全局队列中使用barrier; 建议在自定义队列中使用barrier<br>3、自定义队列支持设置标识符，在debug时候可以方便的去区分队列</p>
<p>参考资料：</p>
<p><a href="https://amattn.com/p/grand_central_dispatch_gcd_summary_syntax_best_practices.html" target="_blank" rel="noopener">https://amattn.com/p/grand_central_dispatch_gcd_summary_syntax_best_practices.html</a></p>
<p><a href="https://blog.yuhanle.com/2017/04/28/gcd-sync-barriers-groups-semaphore/" target="_blank" rel="noopener">GCD 同步操作之 Resource Competition</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/14/%E6%9B%B4%E6%94%B9AppStore%E5%85%AC%E5%8F%B8%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/%E6%9B%B4%E6%94%B9AppStore%E5%85%AC%E5%8F%B8%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">更改AppStore公司信息</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-14 15:36:27" itemprop="dateCreated datePublished" datetime="2020-12-14T15:36:27+08:00">2020-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-13 12:14:46" itemprop="dateModified" datetime="2021-01-13T12:14:46+08:00">2021-01-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>公司更改的企业名称，App Store中的需要同步更改。</p>
<h4 id="账号持有者"><a href="#账号持有者" class="headerlink" title="账号持有者"></a>账号持有者</h4><p><a href="https://developer.apple.com/account/#/membership" target="_blank" rel="noopener">查看账户持有者</a>，只有是苹果开发者账户持有者，才会给你修改。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214154119454.png" alt="image-20201214154119454"></p>
<h4 id="更改名称"><a href="#更改名称" class="headerlink" title="更改名称"></a>更改名称</h4><h5 id="联系苹果客服"><a href="#联系苹果客服" class="headerlink" title="联系苹果客服"></a>联系苹果客服</h5><p>拨打苹果开发者(中国)电话 400-670-1855 告诉客服你要更改公司名称，必须要说你是代理人。或者用代理人的邮箱直接写邮件：“我需要更改公司名称”发送到 <a href="mailto:chinadev@asia.apple.com">chinadev@asia.apple.com</a>。</p>
<h5 id="提供公司信息"><a href="#提供公司信息" class="headerlink" title="提供公司信息"></a>提供公司信息</h5><p>然后客服会给你发一封邮件，邮件中包括需要你提供的信息和邓白氏的联系方式。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214163025028.png" alt="image-20201214163025028"></p>
<p>提供邮件信息进行回复后，苹果接着会回复邮件（基本1个小时左右会收到回复）</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214163248859.png" alt="image-20201214163248859"></p>
<h5 id="联系邓白氏"><a href="#联系邓白氏" class="headerlink" title="联系邓白氏"></a>联系邓白氏</h5><p>因为我们需要同时变更英文名称，苹果让我们显联系邓白氏，因为一个公司只有一个邓白氏编码，为了保证，你现在的新名称公司将沿用之前的邓白氏码。</p>
<p>点击邮件中链接，会直接来到<a href="https://support.dnb.com/?CUST=APPLEDEV" target="_blank" rel="noopener">D-U-N-S</a>网站，填写邮箱信息</p>
<blockquote>
<p>注意：邮箱只能使用企业邮箱，个人邮箱会直接不予通过</p>
</blockquote>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214163825700.png" alt="image-20201214163825700"></p>
<h5 id="获取D-U-N-S"><a href="#获取D-U-N-S" class="headerlink" title="获取D-U-N-S"></a>获取D-U-N-S</h5><p><a href="https://developer.apple.com/cn/support/D-U-N-S/" target="_blank" rel="noopener">相关信息查询网站</a></p>
<p><a href="https://developer.apple.com/enroll/duns-lookup/" target="_blank" rel="noopener">获取D-U-N-S编号</a></p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214164756200.png" alt="image-20201214164756200"></p>
<blockquote>
<p>注意：在获取DUNS信息时，填写的法人代表与开发者账户中的“Team Name”一致</p>
</blockquote>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214164225552.png" alt="image-20201214164225552"></p>
<p>接着会收到D-U-N-S 编号邮件</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214164410118.png" alt="image-20201214164410118"></p>
<p>根据D-U-N-S 编号，继续去填写Request</p>
<h5 id="填写更新信息"><a href="#填写更新信息" class="headerlink" title="填写更新信息"></a>填写更新信息</h5><p>选择提交申请</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214160714384.png" alt="image-20201214160714384"></p>
<p>填写完毕</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214161118176.png" alt="image-20201214161118176"></p>
<p>邮箱会收到邮件</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214161223146.png" alt="image-20201214161223146"></p>
<p>接着就是等待邓白氏那边更新了，更新完毕后再联系苹果开发者。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/08/iOS%E2%80%94%E2%80%94KVO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/iOS%E2%80%94%E2%80%94KVO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">iOS——KVO相关总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-08 20:26:57" itemprop="dateCreated datePublished" datetime="2020-12-08T20:26:57+08:00">2020-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-11 17:50:28" itemprop="dateModified" datetime="2020-12-11T17:50:28+08:00">2020-12-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="KVO概述"><a href="#KVO概述" class="headerlink" title="KVO概述"></a>KVO概述</h3><ul>
<li>KVO全称是key value observing，俗称“键值监听/观察”，是苹果提供的一套事件通知机制，允许一个对象观察/监听另一个对象指定属性值的变化，当被观察对象属性值发生变化时，会触发KVO的监听方法来通知观察者，KVO时MVC应用程序中的各层之前进行通信的非常有用的技术。</li>
<li>KVO 和 NSNotification都是ios中观察者模式的一种实现</li>
<li>KVO可以监听单个属性的变化，也可以监听集合对象的变化，监听集合对象变化时，需要通过KVC的mutableValueForKey:等可变代理方法获得集合代理对象，并使用代理对象进行操作，当代理对象的内部对象发生变化时，会触发KVO的监听方法。集合对象包含NSArray 和 NSSet。</li>
</ul>
<h3 id="KVO的基本使用"><a href="#KVO的基本使用" class="headerlink" title="KVO的基本使用"></a>KVO的基本使用</h3><p>KVO使用步骤：添加/注册KVO监听、实现监听方法以接受属性变化通知、移除KVO监听</p>
<ol>
<li><p>调用方法给被观察对象添加观察者</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSArray 添加</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer toObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在观察者类中实现方法以接受属性变化的通知消息</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当观察者不需要再监听时，调用方法将观察者移除。需要注意的是，至少在观察者销毁之前，进行移除，否则可能会导致Crash</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSArray 移除</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer fromObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer fromObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="注册方法"><a href="#注册方法" class="headerlink" title="注册方法"></a>注册方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 注册观察者</span></span><br><span class="line"><span class="comment">/// @param observer 观察者对象</span></span><br><span class="line"><span class="comment">/// @param keyPath 观察对象属性路径</span></span><br><span class="line"><span class="comment">/// @param options</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionNew 观察新值</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionOld 观察旧值</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionInitial 观察初始值（如果想在注册观察者后立即收到一次通知，可以加入此值）</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionPrior 分别在值改变前后触发方法（即一次修改有两次触发）</span></span><br><span class="line"><span class="comment">/// @param context  可以传入任意数据（任意类型的对象或者C指针），在监听方法中可以接收到这个数据，是KVO中的一种传值方式，</span></span><br><span class="line"><span class="comment">///                 如果传的是一个对象，必须在移除观察之前持有它的强引用，否则在监听方法中访问context就可能导致Crash</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<h4 id="监听方法"><a href="#监听方法" class="headerlink" title="监听方法"></a>监听方法</h4><p>如果对象被注册成为观察者，则该对象必须能响应一下监听方法，即该对象所属类中必须实现监听方法。当被观察对象属性发生改变时会调用监听方法，如果没有实现则会Crash。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 监听方法</span></span><br><span class="line"><span class="comment">/// @param keyPath 观察对象属性路径</span></span><br><span class="line"><span class="comment">/// @param object 观察对象</span></span><br><span class="line"><span class="comment">/// @param change</span></span><br><span class="line"><span class="comment">/// 字典 NSDictionary&lt;NSKeyValueChangeKey, id&gt;，属性值更改的详细信息，根据注册方法中options参数传入的枚举来返回</span></span><br><span class="line"><span class="comment">/// key为 NSKeyValueChangeKey 枚举类型</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">/// 1.NSKeyValueChangeKindKey：存储本次改变的信息（change字典中默认包含这个key）</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">/// 对应枚举类型 NSKeyValueChange</span></span><br><span class="line"><span class="comment">///     typedef NS_ENUM(NSUInteger, NSKeyValueChange) &#123;</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeSetting     = 1,</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeInsertion   = 2,</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeRemoval     = 3,</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeReplacement = 4</span></span><br><span class="line"><span class="comment">///&#125;;</span></span><br><span class="line"><span class="comment">/// 如果是对被观察对象属性（包括集合）进行赋值操作，kind 字段的值为 NSKeyValueChangeSetting</span></span><br><span class="line"><span class="comment">/// 如果被观察的是集合对象，且进行的是（插入、删除、替换）操作，则会根据集合对象的操作方式来设置 kind 字段的值</span></span><br><span class="line"><span class="comment">/// 插入：NSKeyValueChangeInsertion</span></span><br><span class="line"><span class="comment">/// 删除：NSKeyValueChangeRemoval</span></span><br><span class="line"><span class="comment">/// 替换：NSKeyValueChangeReplacement</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&#125;</span></span><br><span class="line"><span class="comment">/// 2.NSKeyValueChangeNewKey：存储新值（如果options中传入NSKeyValueObservingOptionNew，change字典中就会包含这个key）</span></span><br><span class="line"><span class="comment">/// 3.NSKeyValueChangeOldKey：存储旧值（如果options中传入NSKeyValueObservingOptionOld，change字典中就会包含这个key）</span></span><br><span class="line"><span class="comment">/// 4.NSKeyValueChangeIndexesKey：如果被观察的是集合对象，且进行的是（插入、删除、替换）操作，则change字典中就会包含这个key，</span></span><br><span class="line"><span class="comment">/// 这个key的value是一个NSIndexSet对象，包含更改关系中的索引</span></span><br><span class="line"><span class="comment">/// 5.NSKeyValueChangeNotificationIsPriorKey：如果options中传入NSKeyValueObservingOptionPrior，则在改变前通知的change字典中会包含这个key。</span></span><br><span class="line"><span class="comment">/// 这个key对应的value是NSNumber包装的YES，我们可以这样来判断是不是在改变前的通知[change[NSKeyValueChangeNotificationIsPriorKey] boolValue] == YES]</span></span><br><span class="line"><span class="comment">/// @param context 注册方法中传入的context</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<h4 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h4><p>在调用注册方法后，KVO不会对观察者进行强引用，所以需要注意观察者的生命周期，至少需要在观察者销毁之谦，调用移除监听方法，否则在观察者被释放后，再次触发KVO监听方法就会Crash。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 移除观察者</span></span><br><span class="line"><span class="comment">/// @param observer 观察对象</span></span><br><span class="line"><span class="comment">/// @param keyPath 观察对象路径</span></span><br><span class="line"><span class="comment">/// @param context 注册传入的context</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<h4 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)add_newKey_kvo &#123;</span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionInitial</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context; &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@--%@--%@--%@"</span>,keyPath,object,change,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>======Log======</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">15</span>:<span class="number">57</span>:<span class="number">49</span>] -[MMKVO observeValueForKeyPath:ofObject:change:context:] [第<span class="number">61</span>行] 💕 name--&lt;MMKVOPerson: <span class="number">0x600002a04100</span>&gt;--&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125;--(null)</span><br><span class="line"></span><br><span class="line">[<span class="number">15</span>:<span class="number">57</span>:<span class="number">49</span>] -[MMKVO observeValueForKeyPath:ofObject:change:context:] [第<span class="number">61</span>行] 💕 name--&lt;MMKVOPerson: <span class="number">0x600002a04100</span>&gt;--&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">123</span>;</span><br><span class="line">&#125;--(null)</span><br></pre></td></tr></table></figure>

<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>KVO主要用来做键值观察操作，想要一个值发生改变后通知另一个对象，则用KVO实现最为合适。</p>
<p>View-Model-Controller之间数据传递</p>
<h4 id="KVO触发监听方法的方式"><a href="#KVO触发监听方法的方式" class="headerlink" title="KVO触发监听方法的方式"></a>KVO触发监听方法的方式</h4><p>KVO触发分为手动触发和自动触发</p>
<h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><ul>
<li>如果是监听对象特定属性值的改变，通过以下方式改变属性值会触发KVO；<ol>
<li>使用点语法</li>
<li>使用setter方法</li>
<li>使用KVC的setValue:ForKey:方法（key为<code>&lt;key&gt;</code>，<code>_&lt;key&gt;</code>不会触发）</li>
<li>使用KVC的setValue:ForKeyPath:方法（key为<code>&lt;key&gt;</code>，<code>_&lt;key&gt;</code>不会触发）</li>
</ol>
</li>
<li>如果是监听集合对象的改变，需要通过KVC的mutableArrayValueForKey:等方法获取代理对象，并使用代理对象进行操作，当代理对象的内部对象发生改变时，会触发KVO。集合对象包含NSArray 和 NSSet。</li>
</ul>
<h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul>
<li><p>普通对象属性或是成员变量使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSArray、NSSet对象使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="KVO的进阶使用"><a href="#KVO的进阶使用" class="headerlink" title="KVO的进阶使用"></a>KVO的进阶使用</h3><h4 id="observationInfo属性"><a href="#observationInfo属性" class="headerlink" title="observationInfo属性"></a>observationInfo属性</h4><ul>
<li><code>observationInfo</code>属性是<code>NSKeyValueObserving.h</code>文件中系统通过分类给<code>NSObject</code>添加的属性，所以所有继承于<code>NSObject</code>的对象都含有该属性；</li>
<li>可以通过<code>observationInfo</code>属性查看被观察对象的全部观察信息，包括<code>observer</code>、<code>keyPath</code>、<code>options</code>、<code>context</code>等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable) void *observationInfo NS_RETURNS_INNER_POINTER;</span><br></pre></td></tr></table></figure>

<h4 id="context的使用"><a href="#context的使用" class="headerlink" title="context的使用"></a>context的使用</h4><p>注册方法addObserver:forKey:options:context:中context可以传入任意数据，并且可以在监听方法中接收到这个数据。</p>
<ul>
<li><p>context左右：标签，可以更精确的确定被观察对象属性，用于继承、多监听；也可用于传值</p>
<p>KVO只有一个监听回调方法<code>observeValueForKeyPath:ofObject:change:context:</code>，我们通常情况下可以在注册方法中指定context为NULL，并在监听方法中通过object 和 keyPath来判断触发KVO的来源</p>
<p>但是如果存在继承的情况，子类和父类都对同一个属性进行了观察，当属性变化时候由谁来进行处理，通过context就能很好的解决这个问题，在注册方法中为context设置一个独立无二的值，然后在监听方法中对context进行校验即可</p>
</li>
<li><p>苹果推荐用法：用context来准确的缺点被观察对象属性，使用唯一命名的静态变量地址作为context的值。可以为整个类设置一个context，然后在监听方法中通过object 和 keypath来确定被观察属性，这样存在继承的情况就可以通过context来判断，也可以为每个被观察对象数量设置不同的context，这样使用context就能精确的确定被观察对象属性。</p>
</li>
</ul>
<p>以SDWebImage源码为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * SDMemoryCacheContext = &amp;SDMemoryCacheContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册监听</span></span><br><span class="line">[config addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxMemoryCost)) options:<span class="number">0</span> context:SDMemoryCacheContext];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == SDMemoryCacheContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxMemoryCost))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.totalCostLimit = <span class="keyword">self</span>.config.maxMemoryCost;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxMemoryCount))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.countLimit = <span class="keyword">self</span>.config.maxMemoryCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>context优点：嵌套少，性能高，更安全、扩展性强</li>
<li>context注意点：<ol>
<li>如果传的是一个对象，必须在移除观察之前持有它的强引用，否则在监听方法中访问<code>context</code>就可能Crash</li>
<li>空传NULL 而不应该传nil</li>
</ol>
</li>
</ul>
<p>直接出现Crash</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MMKVOPerson *person = [MMKVOPerson new];</span><br><span class="line">person.name = <span class="string">@"person"</span>;</span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionInitial</span> context:(__bridge <span class="keyword">void</span> * _Nullable)(person)];</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span>: EXC_BAD_ACCESS (code=<span class="number">1</span>, address=<span class="number">0x64b6f2e7498c</span>)</span><br></pre></td></tr></table></figure>

<h4 id="KVO的自动触发控制"><a href="#KVO的自动触发控制" class="headerlink" title="KVO的自动触发控制"></a>KVO的自动触发控制</h4><p>通过在被观察对象的类中重写<code>automaticallyNotifiesObserversForKey:</code>方法来控制<code>KVO</code>的自动触发，通过控制，我们可以只让外界观察类中的某些属性的变化</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">20</span>:<span class="number">03</span>:<span class="number">19</span>] -[MMKVO observeValueForKeyPath:ofObject:change:context:] [第<span class="number">108</span>行] 💕 name--&lt;MMKVOPerson: <span class="number">0x600000e28dd0</span>&gt;--&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于注册监听<code>option</code>包含的<code>NSKeyValueObservingOptionInitial</code>的观察对象，会在注册观察者后立即收到一次通知。</p>
<p>也可以实现遵循命名规则为<code>+ (BOOL)automaticallyNotifiesObserversOf&lt;Key&gt;</code>的方法来单一控制属性的KVO自动触发，<code>&lt;key&gt;</code>为属性名（首字母大写）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversOfName;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>第一个方法的优先级高于第二个方法。如果实现了<code>automaticallyNotifiesObserversForKey:</code>方法，并对<code>&lt;key&gt;</code>做了处理，则系统不会再调用 <code>&lt;key&gt;</code>的<code>automaticallyNotifiesObserversOf&lt;Key&gt;</code></li>
<li>options指定的<code>NSKeyValueObservingOptionInitial</code>触发的<code>KVO</code>通知，是无法被<code>automaticallyNotifiesObserversForKey:</code>阻止</li>
</ul>
</blockquote>
<h4 id="KVO的手动触发"><a href="#KVO的手动触发" class="headerlink" title="KVO的手动触发"></a>KVO的手动触发</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>使用KVO监听成员变量值的改变；</li>
<li>在某些需要控制监听过程的场景下：<ol>
<li>为了尽量减少不必要的触发通知操作</li>
<li>当多个更改同时具备的时候才调用属性改变的监听方法</li>
</ol>
</li>
</ul>
<h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h5><ul>
<li>由于KVO的本质，重写setter方法来达到可以通知所有观察者对象的目的，所以只有通过setter方法或者KVC方法去修改属性变量值的时候，才会触发KVO，直接修改成员变量是不会触发KVO。</li>
<li>当我们要使用KVO监听成员变量值改变的时候，可以通过在为成员变量赋值的前后手动调用willChangeValueForKey: 和 didChangeValueForKey:两个方法来手动触发KVO。</li>
<li>NSKeyValueObservingOptionPrior（分别在值改变前后触发方法，即一次修改有两次触发），两次触发分别在willChangeValueForKey: 和 didChangeValueForKey:的时候进行。</li>
<li>如果注册方法中options传入NSKeyValueObservingOptionPrior，那么可以通过值调用willChangeValueForKey:来触发改变前的那次KVO，可以用于在属性即将改变时做一些操作。</li>
</ul>
<h4 id="KVO新旧值相等时不触发"><a href="#KVO新旧值相等时不触发" class="headerlink" title="KVO新旧值相等时不触发"></a>KVO新旧值相等时不触发</h4><p>控制KVO监听的属性值修改前后相等时，不触发KVO的监听方法，可以结合自动触发和手动触发来实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        automatic = <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![_name isEqualToString:name]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">        _name = name;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动观察集合属性"><a href="#手动观察集合属性" class="headerlink" title="手动观察集合属性"></a>手动观察集合属性</h4><p>手动触发监听方法API（数组）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，根据<code>KVC</code>的<code>NSMutableArray</code>搜索模式：</p>
<ul>
<li>至少要实现一个插入和一个删除方法，都在不会触发<code>KVO</code><ol>
<li>插入方法：<code>insertObject:in&lt;Key&gt;AtIndex:</code>或<code>insert&lt;Key&gt;:atIndexes:</code> </li>
<li>删除方法：<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>或<code>remove&lt;Key&gt;AtIndexes:</code></li>
</ol>
</li>
<li>可以不实现替换方法，但是如果不实现替换方法，执行替换操作时，KVO会把它当成先删除后添加，即会触发两次<code>KVO</code>。第一次触发<code>KVO</code>中<code>change</code>字典的<code>old</code>键的值为替换前的元素，第二次触发的<code>KVO</code>中<code>change</code>字典的<code>new</code>键的值为替换后的元素，前提条件是注册方法中的<code>options</code>传入对于的枚举值。</li>
<li>如果实现替换方法，则执行替换操作只会触发一次<code>KVO</code>，并且<code>change</code>字典会同时包含<code>new</code>和<code>old</code>，前提条件是注册方法中的<code>options</code>中传入了对于的枚举值。<ol>
<li>替换方法：<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></li>
</ol>
</li>
<li>建议实现替换方法以提高性能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    BOOL automatic &#x3D; NO;</span><br><span class="line">    if ([key isEqualToString:@&quot;mArray&quot;]) &#123;</span><br><span class="line">        automatic &#x3D; NO;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        automatic &#x3D; [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    return automatic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)insertMArray:(NSArray *)array atIndexes:(NSIndexSet *)indexes</span><br><span class="line">&#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeInsertion valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">    [self.mArray insertObjects:array atIndexes:indexes];</span><br><span class="line">    [self didChange:NSKeyValueChangeInsertion valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeMArrayAtIndexes:(NSIndexSet *)indexes</span><br><span class="line">&#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">    [self.mArray removeObjectsAtIndexes:indexes];</span><br><span class="line">    [self didChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)replaceMArrayAtIndexes:(NSIndexSet *)indexes withMArray:(NSArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeReplacement valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">    [self.mArray replaceObjectsAtIndexes:indexes withObjects:array];</span><br><span class="line">    [self didChange:NSKeyValueChangeReplacement valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KVO的依赖观察"><a href="#KVO的依赖观察" class="headerlink" title="KVO的依赖观察"></a>KVO的依赖观察</h4><h5 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h5><p>有些情况下，一个属性的改变依赖于背的一个或多个属性的改变，也就是说当别的属性遍了，这个属性也会跟着改变。</p>
<p>比如我们对<code>Download</code>类中的<code>downloadProgress</code>属性进行<code>KVO</code>监听，改属性的改变依赖于<code>writtenData</code> 和 <code>totalData</code>属性的改变。观察者监听了<code>downloadProgress</code>，当<code>writtenData</code> 和 <code>totalData</code>属性值发生改变时，观察者也应该被通知。</p>
<ol>
<li><p>重写<code>keyPathsForValuesAffectingValueForKey:</code>方法指明属性依赖于 <code>writtenData</code> 和 <code>totalData</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"downloadProgress"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@"writtenData"</span>,<span class="string">@"totalData"</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个遵循命名规则为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的类方法，<code>&lt;key&gt;</code>是依赖于其他值的属性名（首字母大小）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingDownloadProgress</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"writtenData"</span>,<span class="string">@"totalData"</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>注意：以上两个方法可以同时存在，且都会调用，但是最终结果会以<code>keyPathsForValuesAffectingValueForKey:</code>为准。</p>
</blockquote>
<h5 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h5><p>以上方法在观察集合属性时就不管用了。例如，假如你有一个 Department 类，它有一个装有 Employee 类的实例对象的数组，Employee 类有 salary 属性。你希望 Department 类有一个 totalSalary 属性来计算所有员工的薪水，也就是在这个关系中 Department 的 totalSalary 依赖于所有 Employee 实例对象的 salary 属性。以下有两种方法可以解决这个问题。</p>
<ol>
<li><p>你可以用<code>KVO</code>将 parent（比如 Department ）作为所有 children（比如 Employee ）相关属性的观察者。你必须在把 child 添加或删除到 parent 时把 parent 作为 child 的观察者添加或删除。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中我们可以针对被依赖项的变更来更新依赖项的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Department.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *totalSalaryContext = &amp;totalSalaryContext;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Department</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSArray</span>&lt;Employee *&gt; *employees;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSNumber</span> *totalSalary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Department</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEmployees:(<span class="built_in">NSArray</span> *)employees</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.employees = [employees <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">for</span> (Employee *em <span class="keyword">in</span> <span class="keyword">self</span>.employees) &#123;</span><br><span class="line">            [em addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"salary"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:totalSalaryContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == totalSalaryContext) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setTotalSalary:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"employees.@sum.salary"</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)setTotalSalary:(<span class="built_in">NSNumber</span> *)totalSalary</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_totalSalary != totalSalary) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">        _totalSalary = totalSalary;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (Employee *em <span class="keyword">in</span> <span class="keyword">self</span>.employees) &#123;</span><br><span class="line">        [em removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"salary"</span> context:totalSalaryContext];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用iOS中观察者模式的另外一种实现方式：通知（NSNotification）</p>
</li>
</ol>
<h3 id="KVO的使用注意"><a href="#KVO的使用注意" class="headerlink" title="KVO的使用注意"></a>KVO的使用注意</h3><h4 id="移除观察者的注意点"><a href="#移除观察者的注意点" class="headerlink" title="移除观察者的注意点"></a>移除观察者的注意点</h4><ul>
<li>在调用KVO注册方法后，KVO并不会对观察者进行强引用，所以需要注意观察者的生命周期。至少需要在观察者销毁之前，调用KVO移除方法移除观察者，否则如果观察者被释放后，再次触发KVO监听方法就会Crash。</li>
<li>KVO的注册方法和移除方法应该是成对的，如果重复调用移除方法，就会抛出NSRangeException并导致Crash。</li>
<li>苹果推荐的方式是，在观察者初始化期间（init 或 viewDidLoad的时候）注册为观察者，在释放（dealloc）时调用移除方法，这样可以保证他们是成对出现的，是一种比较理想的方式。</li>
</ul>
<h4 id="防止多次注册-和-移除相同的KVO"><a href="#防止多次注册-和-移除相同的KVO" class="headerlink" title="防止多次注册 和 移除相同的KVO"></a>防止多次注册 和 移除相同的KVO</h4><p>有时候我们难以避免多次注册 和 移除KVO，或者移除了一个未注册的观察者，从而产生可能会导致Crash的风险。</p>
<h5 id="黑科技防止多次添加删除KVO出现的问题"><a href="#黑科技防止多次添加删除KVO出现的问题" class="headerlink" title="黑科技防止多次添加删除KVO出现的问题"></a>黑科技防止多次添加删除KVO出现的问题</h5><p>核心：利用runtime实现方法交换，进行拦截<code>add</code>  和 <code>remove</code> 进行操作。</p>
<h6 id="方案一：利用-try-catch"><a href="#方案一：利用-try-catch" class="headerlink" title="方案一：利用@try @catch"></a>方案一：利用@try @catch</h6><p>利用@try @catch捕获异常，不让程序Crash，但是只能针对多次删除<code>KVO</code>的处理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">kvoRemove</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzleInstanceMethod:<span class="keyword">@selector</span>(removeObserver:forKeyPath:) withSelector:<span class="keyword">@selector</span>(swizzle_removeObserver:forKeyPath:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzle_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> swizzle_removeObserver:observer forKeyPath:keyPath];</span><br><span class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h6 id="方案二：利用模型数组进行存储数据"><a href="#方案二：利用模型数组进行存储数据" class="headerlink" title="方案二：利用模型数组进行存储数据"></a>方案二：利用模型数组进行存储数据</h6><p>利用模型数据进行存储记录</p>
<ul>
<li>利用<code>runtime</code>，拦截监听对象 和 <code>keyPath</code></li>
<li>利用模型存储执行<code>addObserver</code>对象 和 监听的<code>KeyPath</code></li>
<li>进行存储校验，不存在于模型中的<code>addObserver</code>对象 和 监听的<code>KeyPath</code>，才进行<code>addObserver</code></li>
<li><code>remove</code>的时候同样进行校验一下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSKVOCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/// arrayM</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="built_in">NSMutableArray</span> *&gt; *dictM;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSKVOCache</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareInshance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSKVOCache</span> *_instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [<span class="built_in">NSKVOCache</span> new];</span><br><span class="line">        _instance.dictM = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">kvoRemove</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzleInstanceMethod:<span class="keyword">@selector</span>(removeObserver:forKeyPath:)</span><br><span class="line">                   withSelector:<span class="keyword">@selector</span>(swizzle_removeObserver:forKeyPath:)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> swizzleInstanceMethod:<span class="keyword">@selector</span>(addObserver:forKeyPath:options:context:)</span><br><span class="line">                   withSelector:<span class="keyword">@selector</span>(swizzle_addObserver:forKeyPath:options:context:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzle_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSKVOCache</span> *kvo = [<span class="built_in">NSKVOCache</span> shareInshance];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arrayM = kvo.dictM[keyPath];</span><br><span class="line">    <span class="keyword">if</span> (arrayM &amp;&amp; [arrayM containsObject:observer]) &#123;</span><br><span class="line">        [arrayM removeObject:observer];</span><br><span class="line">        [<span class="keyword">self</span> swizzle_removeObserver:observer forKeyPath:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzle_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSKVOCache</span> *kvo = [<span class="built_in">NSKVOCache</span> shareInshance];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arrayM = kvo.dictM[keyPath];</span><br><span class="line">    <span class="keyword">if</span> (!arrayM) &#123;</span><br><span class="line">        arrayM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        [kvo.dictM setObject:arrayM forKey:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![arrayM containsObject:observer]) &#123;</span><br><span class="line">        [arrayM addObject:observer];</span><br><span class="line">        [<span class="keyword">self</span> swizzle_addObserver:observer forKeyPath:keyPath options:options context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h6 id="方案三：利用obserationInfo里私有属性"><a href="#方案三：利用obserationInfo里私有属性" class="headerlink" title="方案三：利用obserationInfo里私有属性"></a>方案三：利用<code>obserationInfo</code>里私有属性</h6><p><code>obserationInfo</code>属性包含属性的监听者，通知者，以及监听的<code>keyPath</code>，通过私有属性直接拿到当前对象所监听的<code>keyPath</code>，和<code>observer</code></p>
<p>实现上和方案二基本一直，只不过可以通过<code>obserationInfo</code>充当我们前面的<code>NSKVOCache</code>的功能，进行校验</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行检索获取Key</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)observerKeyPath:(<span class="built_in">NSString</span> *)key observer:(<span class="keyword">id</span> )observer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> info = <span class="keyword">self</span>.observationInfo;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = [info valueForKey:<span class="string">@"_observances"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> objc <span class="keyword">in</span> array) &#123;</span><br><span class="line">        <span class="keyword">id</span> Properties = [objc valueForKeyPath:<span class="string">@"_property"</span>];</span><br><span class="line">        <span class="keyword">id</span> newObserver = [objc valueForKeyPath:<span class="string">@"_observer"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *keyPath = [Properties valueForKeyPath:<span class="string">@"_keyPath"</span>];</span><br><span class="line">        <span class="keyword">if</span> ([key isEqualToString:keyPath] &amp;&amp; [newObserver isEqual:observer]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h4><ul>
<li>如果对象被注册成为观察者，则该对象必须实现能响应的监听方法，当对象的属性发生改变时就会调用监听方法。如果没有实现，会直接Crash。</li>
<li><code>keyPath</code>传入的是一个字符串，为避免写错，可以使用<code>NSStringFromSelector(@selector(propertyName))</code>，将属性的getter方法SEL转换成字符串，在编译阶段对keyPath进行校验</li>
<li>如果注册方法中<code>context</code>传的是一个对象，必须在移除观察之前持有它的强引用，否则监听方法中访问<code>context</code>就可能导致Crash。</li>
<li>如果监听集合对象的改变，需要通过<code>KVC</code>的<code>mutableArrayValueForKey:</code>等方法获得代理对象，并使用代理对象进行操作，当代理对象的内部对象发生改变时，会触发<code>KVO</code>。如果直接对集合对象进行操作改变，不会触发<code>KVO</code>。</li>
<li>在观察者类的监听方法中，应该为无法识别的<code>context</code> 或者 <code>object</code>、keyPath调用父类的<code>[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</code></li>
</ul>
<h3 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h3><h4 id="isa-swizzling"><a href="#isa-swizzling" class="headerlink" title="isa-swizzling"></a>isa-swizzling</h4><p>苹果使用了isa混写技术（isa-swizzling）来实现KVO，当我们调用addObserver:forKeyPath:options:context:方法为instance添加KVO监听后，系统会在运行时利于Runtime API动态创建instance对象所属类的子类NSKVONotifying_A，并且让instance对象的isa指针指向这个全新的子类，并重写原类的被观察属性的setter方法来达到可以通知所有观察者对象的目的。</p>
<ul>
<li>这个子类指向它自己的meta-class对象，而不是原类的meta-class对象</li>
<li>重写的setter方法的SEL对象的IMP为Foundation中的<code>_NSSetXXXValueAndNotify</code>函数（XXX为key的数据类型），当被观察的属性发生变化时，会调用_NSSetXXXValueAndNotify函数，这个函数中调用：<ol>
<li>willChangeValueForKey:方法</li>
<li>父类原来的setter方法</li>
<li>didChangeValueForKey:方法（内部触发observer监听方法observeValueForKeyPath:ofObject:change:context:）</li>
</ol>
</li>
<li>在移除KVO监听后，被观察对象的isa会指回原类A，但是NSKVONotifying_A类并没有销毁，还是保存在内存中</li>
</ul>
<h4 id="KVO动态生成的子类都有哪些方法"><a href="#KVO动态生成的子类都有哪些方法" class="headerlink" title="KVO动态生成的子类都有哪些方法"></a>KVO动态生成的子类都有哪些方法</h4><p>NSKVONotifying_A除了重写setter方法，还是重写了class、dealloc、_isKVO这三个方法（可以使用runtime的class_copyMethodList函数打印方法列表获取），其中：</p>
<ul>
<li>Class:class 方法返回的是父类的class对象，目的是为了不让外界知道KVO动态生成类的存在；</li>
<li>Dealloc:释放KVO使用过程产生的东西</li>
<li>_isKVO:用来标示它是一个KVO的类</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/11/17/iOS%E2%80%94%E2%80%94KVC%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/iOS%E2%80%94%E2%80%94KVC%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">iOS——KVC相关总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-17 16:02:22" itemprop="dateCreated datePublished" datetime="2020-11-17T16:02:22+08:00">2020-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-08 20:26:04" itemprop="dateModified" datetime="2020-12-08T20:26:04+08:00">2020-12-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ul>
<li>KVC 全称是（Key-Value Coding）键值编码，是有<code>NSKeyValueCoding</code>非正式协议启用的一种机制，对象采用这种机制来提供对其属性的间接访问，可以通过字符串来访问一个对象的成员变量或其关联的存取方法（<code>setter</code> or <code>getter</code>）。</li>
<li>通常，我们可以直接通过存储方法或变量名来访问对象的属性，我们也可以通过<code>KVC</code>间接访问对象的属性，并且<code>KVC</code>还可以访问私有变量。某些情况下，<code>KVC</code>还可以帮助简化代码</li>
<li><code>KVC</code>是许多其他Cocoa技术的基础，比如<code>KVO</code>、<code>Cocoa bingdings</code>，<code>Core Data</code>，<code>AppleScript-ability</code>等。</li>
</ul>
<p>访问对象属性</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return an array containing the results of invoking -valueForKey: on each of the receiver's elements. The returned array will contain NSNull elements for each instance of -valueForKey: returning nil.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;<span class="comment">// 通过key来取值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Invoke -setValue:forKey: on each of the receiver's elements.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Key-path-taking variants of like-named methods. The default implementation of each parses the key path enough to determine whether or not it has more than one component (key path components are separated by periods). If so, -valueForKey: is invoked with the first key path component as the argument, and the method being invoked is invoked recursively on the result, with the remainder of the key path passed as an argument. If not, the like-named non-key-path-taking method is invoked.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath; <span class="comment">// 通过keyPath来取值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given an array of keys, return a dictionary containing the keyed attribute values, to-one-related objects, and/or collections of to-many-related objects. Entries for which -valueForKey: returns nil have NSNull as their value in the returned dictionary.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given a dictionary containing keyed attribute values, to-one-related objects, and/or collections of to-many-related objects, set the keyed values. Dictionary entries whose values are NSNull result in -setValue:nil forKey:key messages being sent to the receiver.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>

<h5 id="setValue-forKey"><a href="#setValue-forKey" class="headerlink" title="setValue:forKey"></a>setValue:forKey</h5><p>通过<code>KVC</code>间接为属性赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];</span><br></pre></td></tr></table></figure>

<h5 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey"></a>valueForKey</h5><p>通过<code>KVC</code>间接取值，通过其<code>key</code>获取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myAccount valueForKey:@&quot;currentBalance&quot;];</span><br></pre></td></tr></table></figure>

<h5 id="setValue-forKeyPath"><a href="#setValue-forKeyPath" class="headerlink" title="setValue:forKeyPath"></a>setValue:forKeyPath</h5><p>KVC<code>还支持多级访问</code>，KeyPath用法和点语法相同。例如：我们想对<code>myAccount</code>的<code>owner</code>属性的<code>address</code>属性的<code>street</code>属性赋值，其<code>keyPath</code>为<code>myAccount.owner.address.</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myAccount setValue:<span class="string">@"地址"</span> forKeyPath:<span class="string">@"owner.address.street"</span>];</span><br></pre></td></tr></table></figure>

<h4 id="多值操作"><a href="#多值操作" class="headerlink" title="多值操作"></a>多值操作</h4><p>给定一组<code>Key</code>，获得一组<code>Value</code>，以字典的形式返回。该方法为数组中的每个<code>key</code>调用<code>valueForKey</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure>

<p>将指定字典中的值设置到消息接受者的属性中，使用字典的key标示属性。默认实现市委每个键值调用setValue:forKey:方法，会根据需要用nil替换NSNull对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>

<h4 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h4><p>我们可以像访问其他对象一样使用<code>valueForKey:</code>或<code>setValue:forKey:</code>方法获取或设置集合对象（主要包括<code>NSArray</code>或<code>NSSet</code>）。但是，当我们要操作集合对象的内容，比如添加或者删除元素时，通过KVC的可变代理方法获取集合代理对象是有效的。</p>
<p>根据<code>KVO</code>的实现原理，是在运行时动态生成子类并重写<code>setter</code>方法来达到可以通知所有观察者对象的目的，因此我们对集合对象进行操作是不会触发<code>KVO</code>的。当我们要使用<code>KVO</code>监听集合对象变化时，需要通过<code>KVC</code>的可变代理方法获取集合代理对象，然后对代理对象进行操作，当代理对象内部对象发生变化时，会触发<code>KVO</code>的监听方法。</p>
<p><code>KVC</code>提供了三种不同的代理对象访问的代理方法，每种都有<code>key</code> 和 <code>keyPath</code>两种方法。</p>
<ul>
<li><p>返回NSMutableArray对象的代理对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回NSMutableSet对象的代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回NSMutableOrderedSet对象的代理对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="built_in">NSString</span> *)key API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h4><p>KVC的valueForKeyPath:方法除了可以取出属性值以外，还可以在keyPath中嵌套集合运算符，来对集合对象进行操作。</p>
<p>KeyPath 分为三部分，left key path（左键路径）、Collection operation（集合运算符）、right key path（右键路径，要进行运算的集合中的属性）</p>
<p>集合运算符分为三类：</p>
<ul>
<li>聚合运算符：以某种方式合并集合中的对象，并返回右键路径中指定的属性的数据类型匹配的一个对象，一般返回NSNumber对象</li>
<li>数组运算符：根据运算符的条件，将符合条件的对象以一个NSArray对象返回</li>
<li>嵌套运算符：处理集合对象中嵌套其他集合对象的情况，并根据运算符返回一个NSArray 或 NSSet对象</li>
</ul>
<h5 id="聚合运算符"><a href="#聚合运算符" class="headerlink" title="聚合运算符"></a>聚合运算符</h5><p>以某种方式合并集合中的对象，并返回右键路径中指定的属性的数据类型匹配的一个对象，一般返回NSNumber对象</p>
<h6 id="avg"><a href="#avg" class="headerlink" title="@avg"></a>@avg</h6><p>读取集合中每个元素的右键路径指定的属性，将其转换为double类型（nil 用 0代替），并计算这些值的算术平均值，然后将结果以NSNumber对象返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算集合中amount属性的平均值</span></span><br><span class="line"><span class="built_in">NSNumber</span> *transactionAverage = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@"@avg.amount"</span>];</span><br></pre></td></tr></table></figure>

<h6 id="count"><a href="#count" class="headerlink" title="@count"></a>@count</h6><p>计算集合中的元素个数，以NSNumber实例返回</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 transactions 集合中的元素个数。</span></span><br><span class="line"><span class="built_in">NSNumber</span> *numberOfTransactions = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@"@count"</span>];</span><br><span class="line"><span class="comment">// numberOfTransactions 的值为 13。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：@count运算符比较特别，它不需要写右键路径，即使写了也会被忽略</p>
</blockquote>
<h6 id="sum"><a href="#sum" class="headerlink" title="@sum"></a>@sum</h6><p>读取集合中每个元素的右键路径指定的属性，将其转换为double类型(nil 用 0代替)，并计算这些值的总和，然后将结果以NSNumber实例返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算amount 的总和</span><br><span class="line">NSNumber *amountSum &#x3D; [self.transactions valueForKeyPath:@&quot;@sum.amount&quot;];</span><br></pre></td></tr></table></figure>

<h6 id="max"><a href="#max" class="headerlink" title="@max"></a>@max</h6><p>返回集合右键路径指定的属性的最大值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取日期的最大值</span><br><span class="line">NSDate *latestDate &#x3D; [self.transactions valueForKeyPath:@&quot;@max.date&quot;];</span><br></pre></td></tr></table></figure>

<p>@min</p>
<p>返回集合右键路径指定的属性的最小值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取日期的最小值</span></span><br><span class="line"><span class="built_in">NSDate</span> *earliestDate = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@"@min.date"</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：@max 和 @min根据右键路径指定的属性在集合中搜索，搜索使用compare:方法进行。因此，右键路径指定的属性必须能响应compare:消息。搜索忽略值为nil的集合项，也可通过重写compare:方法对搜索结果进行控制。</p>
</blockquote>
<h5 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h5><p>根据运算符的条件，将符合条件的对象以一个NSArray实例返回。</p>
<h6 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="@unionOfObjects"></a>@unionOfObjects</h6><p>读取数组中每个元素的右键路径指定的属性，放在一个NSArray实例中返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取集合中的所有payee对象</span><br><span class="line">NSArray *payees &#x3D; [self.transactions valueForKeyPath:@&quot;@unionOfObjects.payee&quot;];</span><br><span class="line">&#x2F;&#x2F; payees 数组中包含所有payee元素的字符串</span><br></pre></td></tr></table></figure>

<h6 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="@distinctUnionOfObjects"></a>@distinctUnionOfObjects</h6><p>读取数组中每个元素的右键路径指定的属性，放在一个NSArray实例中，将数组进行去重后返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取集合中的所有不同的 payee 对象。</span><br><span class="line">NSArray *distinctPayees &#x3D; [self.transactions valueForKeyPath:@&quot;@distinctUnionOfObjects.payee&quot;];</span><br><span class="line">&#x2F;&#x2F; distinctPayees 数组包含以下字符串：Car Loan, General Cable, Animal Hospital, Green Power, Mortgage</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在使用数组运算符时，如果有任何操作的对象为nil，则valueForKeyPath:方法将引发异常</p>
</blockquote>
<h5 id="嵌套运算符"><a href="#嵌套运算符" class="headerlink" title="嵌套运算符"></a>嵌套运算符</h5><p>处理集合对象中嵌套其他集合对象的情况，并根据运算符返回一个NSArray 和 NSSet实例。</p>
<p>如下，一个数组中放着另外两个数组</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>* moreTransactions = @[&lt;<span class="meta"># transaction data #&gt;];</span></span><br><span class="line"><span class="built_in">NSArray</span>* arrayOfArrays = @[<span class="keyword">self</span>.transactions, moreTransactions];</span><br></pre></td></tr></table></figure>

<h6 id="unionOfArrays"><a href="#unionOfArrays" class="headerlink" title="@unionOfArrays"></a>@unionOfArrays</h6><p>读取集合中每个集合中每个元素的右键路径指定的属性，放在一个NSArray实例中返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 arrayOfArrays 集合中的每个集合中的所有 payee 对象。</span></span><br><span class="line"><span class="built_in">NSArray</span> *collectedPayees = [arrayOfArrays valueForKeyPath:<span class="string">@"@unionOfArrays.payee"</span>];</span><br></pre></td></tr></table></figure>

<h6 id="distinctUnionOfArrays"><a href="#distinctUnionOfArrays" class="headerlink" title="@distinctUnionOfArrays"></a>@distinctUnionOfArrays</h6><p>读取集合中每个集合每个元素的右键路径指定的属性，放在一个NSArray实例中，将数组进行去重后返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 arrayOfArrays 集合中的每个集合中的所有不同的 payee 对象。</span></span><br><span class="line"><span class="built_in">NSArray</span> *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:<span class="string">@"@distinctUnionOfArrays.payee"</span>];</span><br></pre></td></tr></table></figure>

<h6 id="distinctUnionOfSets"><a href="#distinctUnionOfSets" class="headerlink" title="@distinctUnionOfSets"></a>@distinctUnionOfSets</h6><p>读取集合中每个集合每个元素的右键路径指定的属性，放在一个NSSet实例中，去重后返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSSet</span> *collectedDistinctPayees = [setOfSets valueForKeyPath:<span class="string">@"@distinctUnionOfSets.payee"</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>在使用嵌套运算符时，valueForKeyPath:内部会根据运算符创建一个NSMuatbleArray 或 NSMuatbleSet对象，将集合中的array 和 set添加进去在进行操作。如果集合中有非集合元素，会导致Crash</li>
<li>使用unionArrays 或 distionctUnionOfArrays运算符，消息接收者应该是arrayOfArrays类型，即<code>NSArray&lt;NASrray *&gt; *arrayOfArrays;</code>；使用distinctUnionOfSets运算符，消息接收者的类型应该是setOfSets或者arrayOfSets类型，否则会发生异常。</li>
<li>在使用嵌套运算符时，如果有任何操作对象为nil，则valueForKeyPath:方法将引发异常</li>
</ul>
</blockquote>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>如果集合对象都是NSNumber，右键路径可以用self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array &#x3D; @[@1, @2, @3, @4, @5];</span><br><span class="line">NSNumber *sum &#x3D; [array valueForKeyPath:@&quot;@sum.self&quot;];</span><br><span class="line">NSLog(@&quot;%d&quot;,[sum intValue]);</span><br></pre></td></tr></table></figure>

<h4 id="自定义集合运算符"><a href="#自定义集合运算符" class="headerlink" title="自定义集合运算符"></a>自定义集合运算符</h4><p>根据<code>Runtime</code>获取<code>NSArray</code>类的方法列表</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)print_arrayMethodList &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    Method *methods = class_copyMethodList([<span class="built_in">NSArray</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果(未完全截图)：</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201208151209139.png" alt="image-20201208151209139"></p>
<p>方法很多，搜索关键字<code>avg</code>、<code>count</code>、<code>sum</code>等<code>KVC</code>为我们提供的集合运算符，发现都有对象的方法<code>_&lt;operatorKey&gt;ForKeyPath:</code></p>
<blockquote>
<p>注意：再来看一下<code>NSSet</code>类支持的集合运算符：</p>
<p>可见<code>NSSet</code>类不支持<code>@unionOfObjects</code> 和 <code>@unionOfArrays</code>运算符，如果使用了就会抛出<code>NSInvalidArgumentException</code>异常并崩溃，reason：<code>[&lt;__NSSetI 0x6000017a12f0&gt; valueForKeyPath:]: this class does not implement the unionOfArrays operation.</code>不支持该运算符。</p>
<p>而<code>NSArray</code>类虽然支持<code>@distinctUnionOfSets</code>运算符，但是必须是<code>arrayOfSets</code>类型，即<code>NSArray&lt; NSSet* &gt;* arrayOfSets;</code>，因为<code>_distinctUnionOfSetsForKeyPath</code>方法中会创建一个<code>NSMutableSet</code>实例，并调用<code>unionSet:</code>方法将集合中的set元素添加进去再进行操作，如果是<code>arrayOfArrays</code>类型就会抛出<code>NSInvalidArgumentException</code>并导致程序崩溃，reason: <code>&#39;*** -[NSMutableSet unionSet:]: set argument is not an NSSet&#39;</code>即集合中有非<code>NSSet</code>元素。</p>
</blockquote>
<p>我们尝试为NSArray添加一个分类，并定义一个_medianForKeyPath:方法，用来获取NSArray中的中位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface NSArray (kvc)</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (kvc)</span><br><span class="line">- (NSNumber *)_medianForKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    &#x2F;&#x2F;排序</span><br><span class="line">    NSArray *sortedArray &#x3D; [self sortedArrayUsingSelector:@selector(compare:)];</span><br><span class="line">    double median;</span><br><span class="line">    if (self.count % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        NSInteger index1 &#x3D; sortedArray.count * 0.5;</span><br><span class="line">        NSInteger index2 &#x3D; sortedArray.count * 0.5 - 1;</span><br><span class="line">        median &#x3D; ([[sortedArray objectAtIndex:index1] doubleValue] + [[sortedArray objectAtIndex:index2] doubleValue]) * 0.5;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSInteger index &#x3D; (sortedArray.count-1) * 0.5;</span><br><span class="line">        median &#x3D; [[sortedArray objectAtIndex:index] doubleValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return [NSNumber numberWithDouble:median];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)medianObject_kvc &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *arr = @[@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">8</span>,@<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSNumber</span> *num = [arr valueForKeyPath:<span class="string">@"@median.self"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,num);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">15</span>:<span class="number">55</span>:<span class="number">06</span>] +[MMKVC medianObject_kvc] [第<span class="number">67</span>行] 💕 <span class="number">3.5</span></span><br></pre></td></tr></table></figure>

<h4 id="非对象值处理"><a href="#非对象值处理" class="headerlink" title="非对象值处理"></a>非对象值处理</h4><p><code>KVC</code>支持基础数据类型和结构体，在使用<code>KVC</code>赋值或取值的时候，会自动在非对象值和对象值之间转换</p>
<ul>
<li>当进行取值如<code>valueForKey:</code>时，如果返回值非对象，会使用该值初始化一个<code>NSNumber</code>或 <code>NSValue</code>实例，然后返回该实例。</li>
<li>当进行赋值如<code>setValue:forKey:</code>时，如果key的数据类型非对象，则会发送一条<code>&lt;type&gt;Value</code>消息给value对象以提取基础数据，然后复制给<code>key</code></li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>因为swift中的所有属性都是对象，所以这里仅适用于Objective-C属性。当进行赋值如setValue:forKey时，如果key 的数据类是非对象类型，则value就禁止传nil。否则调用setNilValueForKey:方法，该方法的默认实现抛出异常NSInvalidArgumentException，并导致Crash</li>
</ul>
</blockquote>
<h4 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h4><p><code>KVC</code>提供了属性验证的方法，如下，我们可以在使用<code>KVC</code>赋值前验证能否为这个<code>key</code>赋值指定的<code>value</code>。</p>
<p><code>validateValue</code>方法的默认实现是查看消息接收者类中是否实现了遵循命名规则为<code>validate&lt;key&gt;:error:</code>的方法，如果有就返回调用该方法的结果，如果没有，就默认验证成功并返回YES，我们可以在消息接收者类中实现<code>validate&lt;key&gt;:error:</code>方法来定义逻辑返回YES 或 NO</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKeyPath:(<span class="built_in">NSString</span> *)inKeyPath error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p>在Person类中实现了validateName:error:方法，验证给name赋的值是不是Jack。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.m</span></span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    <span class="built_in">NSString</span> *value = <span class="string">@"rose"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@"name"</span>;</span><br><span class="line">    <span class="built_in">NSError</span>  *error;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [person validateValue:&amp;value forKey:key error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error = %@"</span>, error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateName:(<span class="keyword">id</span> *)value error:(<span class="keyword">out</span> <span class="built_in">NSError</span> * _Nullable __autoreleasing *)outError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name = *value;</span><br><span class="line">    <span class="built_in">BOOL</span> result = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"jack"</span>]) &#123;</span><br><span class="line">        result = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：默认情况下，KVC是不会自动验证属性的。</p>
</blockquote>
<h4 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h4><h5 id="基本的getter搜索模式"><a href="#基本的getter搜索模式" class="headerlink" title="基本的getter搜索模式"></a>基本的getter搜索模式</h5><p>以下是valueForKey:方法的默认实现，给定一个key作为输入参数，在消息接收者类中操作，执行以下过程。</p>
<ol>
<li>按照<code>get&lt;key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code>、<code>_&lt;key&gt;</code>顺序查找，如果找到就调用取值直接执行5，否则执行2</li>
<li>查找countOf<key>、objectIn<key>AtIndex:、<key>AtIndexes:命名的方法。如果找到第一个和后面两个中的至少一个，则创建一个能够响应所有NSArray的方法的集合代理对象（类型为NSKeyValueArray，继承NSArray），并返回该对象。否则执行3<ul>
<li>代理对象随后将将其接收到的任何NSArray消息转换为countOf<key>、objetIn<key>AtIndex:、<key>AtIndexes:消息的组合，并将其发送给KVC调用方。如果原始对象还实现了一个名为get<key>:range:的可选方法，则代理对象也会在适当时使用该方法</li>
<li>当KVC调用方与代理对象一起工作时，允许底层属性的行为如果NSArray一样，即使它不是NSArray</li>
</ul>
</li>
<li>查找<code>countOf&lt;key&gt;</code>、<code>enumeratorOf&lt;key&gt;</code>、<code>memberOf&lt;key&gt;:</code>命名的方法，如果三个方法都找到，则创建一个能够响应所有NSSet的方法的集合代理对象（类型为NSKeyValueSet，继承自NSSet），并返回该对象。否则执行4<ul>
<li>代理对象随后将其接收到的任何NSSet消息转换为<code>countOf&lt;key&gt;</code>、<code>enumeratorOf&lt;key&gt;</code>、<code>memberOf&lt;key&gt;:</code>消息的组合，并将其发送给KVC的调用方</li>
<li>当KVC调用方与代理对象一起工作时，允许底层属性的行为如同NSSet一样，即使他不是NSSet。</li>
</ul>
</li>
<li>查看消息接收者类的<code>+accessInstanceVariableDirectly</code>方法的返回值（默认返回YES），如果返回YES，就按照<code>_&lt;key&gt;</code>、<code>_is&lt;key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code>顺序查找成员变量。如果找到就直接取值执行5，否则执行6。如果<code>+accessInstanceVariableDirectly</code>方法返回NO， 也会执行6</li>
<li>如果取到值是一个对象指针，即获取的是对象，则直接将对象返回。如果取得值是一个NSNumber支持的数据类型，则转换为NSValue对象，然后返回。</li>
<li>调用valueForUndefinedKey:方法，该方法抛出异常NSUnknownKeyException，并导致程序Crash，这是默认实现，我们可以重写该方法根据特点的key做一些特殊处理。</li>
</ol>
<h5 id="基本的Setter搜索模式"><a href="#基本的Setter搜索模式" class="headerlink" title="基本的Setter搜索模式"></a>基本的Setter搜索模式</h5><p>以下是setValue:forKey方法的默认实现，给定一个key作为输入参数，返回属性名为key的集合的代理对象（这里指的是NSMutableArray对象），在消息接收者类中操作，执行以下过程。</p>
<ol>
<li><p>查找—对方法<code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code><br>（相当于<code>NSMutableArray</code>的原始方法<code>insertObjects:atIndexes:</code>和<code>removeObjectsAtIndexes:</code>）。</p>
<ul>
<li><p>如果我们至少实现了一个<code>insertion</code>方法和一个<code>removal</code>方法，则返回一个代理对象，来响应发送给<code>NSMutableArray</code>的消息，通过发送<code>insertObject:in&lt;Key&gt;AtIndex:</code>、<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>、<code>insert&lt;Key&gt;:atIndexes:</code>、<code>remove&lt;Key&gt;AtIndexes:</code>组合消息给<code>KVC</code>调用方。否则执行②。</p>
<blockquote>
<p>该代理对象类型为<code>NSKeyValueFastMutableArray2</code>，继承链为<code>NSKeyValueFastMutableArray2</code>-&gt;<code>NSKeyValueFastMutableArray</code>-&gt;<code>NSKeyValueMutableArray</code>-&gt;<code>NSMutableArray</code>。</p>
</blockquote>
</li>
<li><p>如果我们也实现了一个可选的<code>replace object</code>方法，如<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>，代理对象在适当的情况下也会使用它们，以获得最佳性能。</p>
</li>
</ul>
</li>
<li><p>查找<code>set&lt;Key&gt;:</code>方法。如果找到，就会向<code>KVC</code>调用方发送一个<code>set&lt;Key&gt;:</code></p>
<p>消息，来返回一个响应<code>NSMutableArray</code>消息的代理对象。否则执行③。</p>
<blockquote>
<p>该代理对象类型为<code>NSKeyValueSlowMutableArray</code>，继承链为<code>NSKeyValueSlowMutableArray</code>-&gt;<code>NSKeyValueMutableArray</code>-&gt;<code>NSMutableArray</code>。</p>
</blockquote>
<blockquote>
<p>注意：** 此步骤中描述的机制比上一步的效率低得多，因为它可能重复创建新的集合对象，而不是修改现有的集合对象。因此，在设计自己的键值编码兼容对象时，通常应该避免使用它。</p>
<p>给代理对象发送<code>NSMutableArray</code>消息都会调用<code>set&lt;Key&gt;:</code>方法。即，对代理对象进行修改，都是调用<code>set&lt;Key&gt;:</code>来重新赋值，所以效率会低很多。</p>
</blockquote>
</li>
<li><p>查看消息接收者类的<code>+accessInstanceVariablesDirectly</code>方法的返回值（默认返回<code>YES</code>）。如果返回<code>YES</code>，就按照<code>_&lt;key&gt;</code>、<code>&lt;key&gt;</code>顺序查找成员变量。如果找到就返回一个代理对象，该代理对象将接收所有<code>NSMutableArray</code>消息，通常是<code>NSMutableArray</code>或其子类。否则执行④。如果<code>+accessInstanceVariablesDirectly</code>方法返回<code>NO</code>也执行④。</p>
</li>
<li><p>返回一个可变的集合代理对象。当它接收到<code>NSMutableArray</code>消息时，发送一个<code>valueForUndefinedKey:</code>消息给<code>KVC</code>调用方，该方法抛出异常<code>NSUnknownKeyException</code>，并导致程序<code>Crash</code>。这是默认实现，我们可以重写该方法根据特定<code>key</code>做一些特殊处理。</p>
</li>
</ol>
<h5 id="其他搜索模式"><a href="#其他搜索模式" class="headerlink" title="其他搜索模式"></a>其他搜索模式</h5><p>除了以上三种，<code>KVC</code>还有<code>NSMutableSet</code>和<code>NSMutableOrderedSet</code>两种搜索模式，它们的搜索规则和<code>NSMutableArray</code>相同，只是搜索和调用的方法不同。具体可以查看<code>KVC</code>官方文档 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">KVC - Accessor Search Patterns</a></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><p>根据KVC搜索规则，当没有搜索到对应的key 或者 keyPath相关方法或者变量时，会调用对应的异常方法valueForUndefinedKey: 或 setValue:forUndefinedKey:，这两个方法的默认实现是抛出异常NSUnKnownKeyException，并导致程序Crash。我们可以重写这两个方法来处理异常</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given that an invocation of -valueForKey: would be unable to get a keyed value using its default access mechanism, return the keyed value using some other mechanism. The default implementation of this method raises an NSUndefinedKeyException. You can override it to handle properties that are dynamically defined at run-time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given that an invocation of -setValue:forKey: would be unable to set the keyed value using its default mechanism, set the keyed value using some other mechanism. The default implementation of this method raises an NSUndefinedKeyException. You can override it to handle properties that are dynamically defined at run-time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当进行赋值如setValue:forKey:时，如果key的数据类型是非对象类型，则value就禁止传nil。否则调用setNilValueForKey:方法，该方法的默认实现是抛出异常NSInvalidArgumentException，并导致程序Crash。我们可以重写这个方法来处理异常。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"hidden"</span>]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setValue:@(<span class="literal">NO</span>) forKey:@”hidden”];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> setNilValueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doris AI</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doris AI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
