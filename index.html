<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorisgit.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="泡泡茶壶">
<meta property="og:url" content="https://dorisgit.github.io/index.html">
<meta property="og:site_name" content="泡泡茶壶">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Doris AI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dorisgit.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>泡泡茶壶</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泡泡茶壶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/21/%E4%B8%80%E6%AC%A1Crash%E8%B7%9F%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/%E4%B8%80%E6%AC%A1Crash%E8%B7%9F%E8%B8%AA/" class="post-title-link" itemprop="url">一次Crash跟踪</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-21 16:43:40 / Modified: 19:51:10" itemprop="dateCreated datePublished" datetime="2020-12-21T16:43:40+08:00">2020-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一次偶然的机会，线上反馈用户手机出现了打开App即Crash的情况，根据用户提供时间点以及视频信息，我们查看了bugly和尝试本地复现，很遗憾，都没有相关有用信息。</p>
<p>这时想到了，用户分析本机中可能存在log信息。</p>
<h4 id="获取Crash文件"><a href="#获取Crash文件" class="headerlink" title="获取Crash文件"></a>获取Crash文件</h4><p>设置-&gt;分析与改进-&gt;分析数据，找到当天对应的Crash文件，分享到电脑上。</p>
<h4 id="获取-ipa包的UUID"><a href="#获取-ipa包的UUID" class="headerlink" title="获取.ipa包的UUID"></a>获取.ipa包的UUID</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun dwarfdump --uuid xxx.app/xxx</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID: 464A42BE-DB0F-3DF5-ABA7-F3CC4C4944CF (armv7) xxx.app/xxx</span><br><span class="line">UUID: F89C620B-0D6F-3422-A9BE-1C84FC827111 (arm64) xxx.app/xxx</span><br></pre></td></tr></table></figure>

<h4 id="查看Crash文件的UUID"><a href="#查看Crash文件的UUID" class="headerlink" title="查看Crash文件的UUID"></a>查看Crash文件的UUID</h4><p>打开Crash日志，直接搜索<code>Binary Images</code>，对应的就是uuid</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x100110000 - 0x10283ffff xxx arm64  &lt;f89c620b0d6f3422a9be1c84fc827111&gt; /var/containers/Bundle/Application/66BFB77D-3B41-42F2-A283-3F96EB4AD716/xxx.app/xxx</span><br></pre></td></tr></table></figure>

<p>可以看到crash日志中的uuid与ipa包中的uuid对应上了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f89c620b0d6f3422a9be1c84fc827111</span><br></pre></td></tr></table></figure>

<h4 id="查看-dSYM文件的UUID"><a href="#查看-dSYM文件的UUID" class="headerlink" title="查看.dSYM文件的UUID"></a>查看.dSYM文件的UUID</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid xxx.app.dSYM</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID: 464A42BE-DB0F-3DF5-ABA7-F3CC4C4944CF (armv7) xxx.app.dSYM/Contents/Resources/DWARF/xxx</span><br><span class="line">UUID: F89C620B-0D6F-3422-A9BE-1C84FC827111 (arm64) xxx.app.dSYM/Contents/Resources/DWARF/xxx</span><br></pre></td></tr></table></figure>

<h4 id="symbolicatecrash"><a href="#symbolicatecrash" class="headerlink" title="symbolicatecrash"></a>symbolicatecrash</h4><h5 id="获取解析工具symbolicatecrash所在位置"><a href="#获取解析工具symbolicatecrash所在位置" class="headerlink" title="获取解析工具symbolicatecrash所在位置"></a>获取解析工具symbolicatecrash所在位置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;SharedFrameworks&#x2F;DVTFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Resources&#x2F;symbolicatecrash</span><br></pre></td></tr></table></figure>

<p>按照格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbolicatecrash .crash文件 .dSYM文件 &gt;result.log</span><br></pre></td></tr></table></figure>

<p>拼装命令，执行即可获得解析结果result.log</p>
<h5 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash /Users/mikasa/Documents/Crash/xxx-2020-12-20-212420.ips xxx.app.dSYM &gt;result.log</span><br></pre></td></tr></table></figure>

<p>终端可能会出现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: "DEVELOPER_DIR" is not defined at /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash line 69.</span><br></pre></td></tr></table></figure>

<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p>再执行命令，在终端完成以后，在Crash文件夹中就会多出一个result.log文件，可以查看bug的崩溃信息。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201221184525739.png" alt="image-20201221184525739"></p>
<h4 id="如何找回已发布到App-Store的App对应的dSYM文件？"><a href="#如何找回已发布到App-Store的App对应的dSYM文件？" class="headerlink" title="如何找回已发布到App Store的App对应的dSYM文件？"></a>如何找回已发布到App Store的App对应的dSYM文件？</h4><h5 id="通过Xcode找回"><a href="#通过Xcode找回" class="headerlink" title="通过Xcode找回"></a>通过Xcode找回</h5><ul>
<li>打开 Xcode 顶部菜单栏 -&gt; Window -&gt; Organizer 窗口</li>
<li>打开 Xcode 顶部菜单栏，选择 Archive 标签</li>
<li>找到发布的归档包，右键点击对应归档包，选择Show in Finder操作</li>
<li>右键选择定位到的归档文件，选择显示包内容操作</li>
<li>选择dSYMs目录，目录内即为下载到的 dSYM 文件</li>
</ul>
<h5 id="通过iTunes-Connect找回"><a href="#通过iTunes-Connect找回" class="headerlink" title="通过iTunes Connect找回"></a>通过iTunes Connect找回</h5><ul>
<li>登录<a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">iTunes Connect</a></li>
<li>进入“我的App（My Apps）”的“活动（Activity）”页面</li>
<li>在“所有构件版本（All Builds）”中选择某一个版本，点“下载dSYM（Download dSYM）”下载dSYM文件</li>
</ul>
<h5 id="通过mdfind工具找回"><a href="#通过mdfind工具找回" class="headerlink" title="通过mdfind工具找回"></a>通过mdfind工具找回</h5><ul>
<li><p>查询到crash对应的UUID</p>
</li>
<li><p>然后在Mac的Shell中，用mdfind命令定位dSYM文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdfind "com_apple_xcode_dsym_uuids == &lt;UUID&gt;"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，使用mdfind时，UUID需要格式转换（增加“-”）： 12345678-1234-1234-1234-xxxxxxxxxxxx</p>
</blockquote>
</li>
</ul>
<p>例如，要定位的dSYM的UUID为：f89c620b0d6f3422a9be1c84fc827111 则定位dSYM文件的命令如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdfind "com_apple_xcode_dsym_uuids == F89C620B-0D6F-3422-A9BE-1C84FC827111"</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/21/%E6%B5%85%E8%B0%88iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E5%8E%8B%E7%BC%A9%E4%BB%8E%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/%E6%B5%85%E8%B0%88iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E5%8E%8B%E7%BC%A9%E4%BB%8E%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">浅谈iOS图片解压缩从文件渲染到屏幕的过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-21 14:28:48 / Modified: 14:35:21" itemprop="dateCreated datePublished" datetime="2020-12-21T14:28:48+08:00">2020-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>概述</p>
<p>将一张图片从磁盘中加载出来，并最终显示到屏幕上，中间其实经过了一系列复杂的处理过程，从文件到屏幕，其中包括了对图片的解压缩操作。</p>
<p><strong>渲染图片到屏幕的过程</strong></p>
<p><img src="/Users/mikasa/Desktop/image_mark/16cfbeb484307840.png" alt="16cfbeb484307840"></p>
<p>如上所示，图片渲染到屏幕上，是CPU和GPU协作完成的。</p>
<p>CPU/GPU等这样一次渲染过程中的具体分工：</p>
<ul>
<li>CPU：计算视图frame、图片解码、需要绘制纹理图片通过数据总线交给GPU</li>
<li>GPU：纹理混合、顶点变换与计算</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/17/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/" class="post-title-link" itemprop="url">知识小集</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-17 14:01:13" itemprop="dateCreated datePublished" datetime="2020-12-17T14:01:13+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-21 14:27:38" itemprop="dateModified" datetime="2020-12-21T14:27:38+08:00">2020-12-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><h4 id="UIView-和-CALayer的区别？"><a href="#UIView-和-CALayer的区别？" class="headerlink" title="UIView 和 CALayer的区别？"></a>UIView 和 CALayer的区别？</h4><ul>
<li>UIView继承至UIRespond，可以处理手势响应事件；CALayer继承至NSObject，不可以处理处理响应事件</li>
<li>UIView着重于内容管理，CALayer着重于内容绘制</li>
<li>UIView与CALayer之间存在依赖关系，UIView的显示依赖于CALayer的内容，CALayer依赖UIView的容器来绘制显示的内容</li>
<li>UIView来自CALayer，高于CALayer，是CALayer的高层展示与封装，UIView的特性均来来自于CALayer</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/14/%E6%9B%B4%E6%94%B9AppStore%E5%85%AC%E5%8F%B8%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/%E6%9B%B4%E6%94%B9AppStore%E5%85%AC%E5%8F%B8%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">更改AppStore公司信息</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 15:36:27 / Modified: 16:48:13" itemprop="dateCreated datePublished" datetime="2020-12-14T15:36:27+08:00">2020-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>公司更改的企业名称，App Store中的需要同步更改。</p>
<h4 id="账号持有者"><a href="#账号持有者" class="headerlink" title="账号持有者"></a>账号持有者</h4><p><a href="https://developer.apple.com/account/#/membership" target="_blank" rel="noopener">查看账户持有者</a>，只有是苹果开发者账户持有者，才会给你修改。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214154119454.png" alt="image-20201214154119454"></p>
<h4 id="更改名称"><a href="#更改名称" class="headerlink" title="更改名称"></a>更改名称</h4><h5 id="联系苹果客服"><a href="#联系苹果客服" class="headerlink" title="联系苹果客服"></a>联系苹果客服</h5><p>拨打苹果开发者(中国)电话 400-670-1855 告诉客服你要更改公司名称，必须要说你是代理人。或者用代理人的邮箱直接写邮件：“我需要更改公司名称”发送到 <a href="mailto:chinadev@asia.apple.com">chinadev@asia.apple.com</a>。</p>
<h5 id="提供公司信息"><a href="#提供公司信息" class="headerlink" title="提供公司信息"></a>提供公司信息</h5><p>然后客服会给你发一封邮件，邮件中包括需要你提供的信息和邓白氏的联系方式。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214163025028.png" alt="image-20201214163025028"></p>
<p>提供邮件信息进行回复后，苹果接着会回复邮件（基本1个小时左右会收到回复）</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214163248859.png" alt="image-20201214163248859"></p>
<h5 id="联系邓白氏"><a href="#联系邓白氏" class="headerlink" title="联系邓白氏"></a>联系邓白氏</h5><p>因为我们需要同时变更英文名称，苹果让我们显联系邓白氏，因为一个公司只有一个邓白氏编码，为了保证，你现在的新名称公司将沿用之前的邓白氏码。</p>
<p>点击邮件中链接，会直接来到<a href="https://support.dnb.com/?CUST=APPLEDEV" target="_blank" rel="noopener">D-U-N-S</a>网站，填写邮箱信息</p>
<blockquote>
<p>注意：邮箱只能使用企业邮箱，个人邮箱会直接不予通过</p>
</blockquote>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214163825700.png" alt="image-20201214163825700"></p>
<h5 id="获取D-U-N-S"><a href="#获取D-U-N-S" class="headerlink" title="获取D-U-N-S"></a>获取D-U-N-S</h5><p><a href="https://developer.apple.com/cn/support/D-U-N-S/" target="_blank" rel="noopener">相关信息查询网站</a></p>
<p><a href="https://developer.apple.com/enroll/duns-lookup/#!/select/complete" target="_blank" rel="noopener">获取D-U-N-S编号</a></p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214164756200.png" alt="image-20201214164756200"></p>
<blockquote>
<p>注意：在获取DUNS信息时，填写的法人代表与开发者账户中的“Team Name”一致</p>
</blockquote>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214164225552.png" alt="image-20201214164225552"></p>
<p>接着会收到D-U-N-S 编号邮件</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214164410118.png" alt="image-20201214164410118"></p>
<p>根据D-U-N-S 编号，继续去填写Request</p>
<h5 id="填写更新信息"><a href="#填写更新信息" class="headerlink" title="填写更新信息"></a>填写更新信息</h5><p>选择提交申请</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214160714384.png" alt="image-20201214160714384"></p>
<p>填写完毕</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214161118176.png" alt="image-20201214161118176"></p>
<p>邮箱会收到邮件</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201214161223146.png" alt="image-20201214161223146"></p>
<p>接着就是等待邓白氏那边更新了，更新完毕后再联系苹果开发者。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/12/08/iOS%E2%80%94%E2%80%94KVO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/iOS%E2%80%94%E2%80%94KVO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">iOS——KVO相关总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-08 20:26:57" itemprop="dateCreated datePublished" datetime="2020-12-08T20:26:57+08:00">2020-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-11 17:50:28" itemprop="dateModified" datetime="2020-12-11T17:50:28+08:00">2020-12-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="KVO概述"><a href="#KVO概述" class="headerlink" title="KVO概述"></a>KVO概述</h3><ul>
<li>KVO全称是key value observing，俗称“键值监听/观察”，是苹果提供的一套事件通知机制，允许一个对象观察/监听另一个对象指定属性值的变化，当被观察对象属性值发生变化时，会触发KVO的监听方法来通知观察者，KVO时MVC应用程序中的各层之前进行通信的非常有用的技术。</li>
<li>KVO 和 NSNotification都是ios中观察者模式的一种实现</li>
<li>KVO可以监听单个属性的变化，也可以监听集合对象的变化，监听集合对象变化时，需要通过KVC的mutableValueForKey:等可变代理方法获得集合代理对象，并使用代理对象进行操作，当代理对象的内部对象发生变化时，会触发KVO的监听方法。集合对象包含NSArray 和 NSSet。</li>
</ul>
<h3 id="KVO的基本使用"><a href="#KVO的基本使用" class="headerlink" title="KVO的基本使用"></a>KVO的基本使用</h3><p>KVO使用步骤：添加/注册KVO监听、实现监听方法以接受属性变化通知、移除KVO监听</p>
<ol>
<li><p>调用方法给被观察对象添加观察者</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSArray 添加</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer toObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在观察者类中实现方法以接受属性变化的通知消息</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当观察者不需要再监听时，调用方法将观察者移除。需要注意的是，至少在观察者销毁之前，进行移除，否则可能会导致Crash</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSArray 移除</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer fromObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer fromObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="注册方法"><a href="#注册方法" class="headerlink" title="注册方法"></a>注册方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 注册观察者</span></span><br><span class="line"><span class="comment">/// @param observer 观察者对象</span></span><br><span class="line"><span class="comment">/// @param keyPath 观察对象属性路径</span></span><br><span class="line"><span class="comment">/// @param options</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionNew 观察新值</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionOld 观察旧值</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionInitial 观察初始值（如果想在注册观察者后立即收到一次通知，可以加入此值）</span></span><br><span class="line"><span class="comment">///     NSKeyValueObservingOptionPrior 分别在值改变前后触发方法（即一次修改有两次触发）</span></span><br><span class="line"><span class="comment">/// @param context  可以传入任意数据（任意类型的对象或者C指针），在监听方法中可以接收到这个数据，是KVO中的一种传值方式，</span></span><br><span class="line"><span class="comment">///                 如果传的是一个对象，必须在移除观察之前持有它的强引用，否则在监听方法中访问context就可能导致Crash</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<h4 id="监听方法"><a href="#监听方法" class="headerlink" title="监听方法"></a>监听方法</h4><p>如果对象被注册成为观察者，则该对象必须能响应一下监听方法，即该对象所属类中必须实现监听方法。当被观察对象属性发生改变时会调用监听方法，如果没有实现则会Crash。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 监听方法</span></span><br><span class="line"><span class="comment">/// @param keyPath 观察对象属性路径</span></span><br><span class="line"><span class="comment">/// @param object 观察对象</span></span><br><span class="line"><span class="comment">/// @param change</span></span><br><span class="line"><span class="comment">/// 字典 NSDictionary&lt;NSKeyValueChangeKey, id&gt;，属性值更改的详细信息，根据注册方法中options参数传入的枚举来返回</span></span><br><span class="line"><span class="comment">/// key为 NSKeyValueChangeKey 枚举类型</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">/// 1.NSKeyValueChangeKindKey：存储本次改变的信息（change字典中默认包含这个key）</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">/// 对应枚举类型 NSKeyValueChange</span></span><br><span class="line"><span class="comment">///     typedef NS_ENUM(NSUInteger, NSKeyValueChange) &#123;</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeSetting     = 1,</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeInsertion   = 2,</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeRemoval     = 3,</span></span><br><span class="line"><span class="comment">///         NSKeyValueChangeReplacement = 4</span></span><br><span class="line"><span class="comment">///&#125;;</span></span><br><span class="line"><span class="comment">/// 如果是对被观察对象属性（包括集合）进行赋值操作，kind 字段的值为 NSKeyValueChangeSetting</span></span><br><span class="line"><span class="comment">/// 如果被观察的是集合对象，且进行的是（插入、删除、替换）操作，则会根据集合对象的操作方式来设置 kind 字段的值</span></span><br><span class="line"><span class="comment">/// 插入：NSKeyValueChangeInsertion</span></span><br><span class="line"><span class="comment">/// 删除：NSKeyValueChangeRemoval</span></span><br><span class="line"><span class="comment">/// 替换：NSKeyValueChangeReplacement</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&#125;</span></span><br><span class="line"><span class="comment">/// 2.NSKeyValueChangeNewKey：存储新值（如果options中传入NSKeyValueObservingOptionNew，change字典中就会包含这个key）</span></span><br><span class="line"><span class="comment">/// 3.NSKeyValueChangeOldKey：存储旧值（如果options中传入NSKeyValueObservingOptionOld，change字典中就会包含这个key）</span></span><br><span class="line"><span class="comment">/// 4.NSKeyValueChangeIndexesKey：如果被观察的是集合对象，且进行的是（插入、删除、替换）操作，则change字典中就会包含这个key，</span></span><br><span class="line"><span class="comment">/// 这个key的value是一个NSIndexSet对象，包含更改关系中的索引</span></span><br><span class="line"><span class="comment">/// 5.NSKeyValueChangeNotificationIsPriorKey：如果options中传入NSKeyValueObservingOptionPrior，则在改变前通知的change字典中会包含这个key。</span></span><br><span class="line"><span class="comment">/// 这个key对应的value是NSNumber包装的YES，我们可以这样来判断是不是在改变前的通知[change[NSKeyValueChangeNotificationIsPriorKey] boolValue] == YES]</span></span><br><span class="line"><span class="comment">/// @param context 注册方法中传入的context</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<h4 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h4><p>在调用注册方法后，KVO不会对观察者进行强引用，所以需要注意观察者的生命周期，至少需要在观察者销毁之谦，调用移除监听方法，否则在观察者被释放后，再次触发KVO监听方法就会Crash。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 移除观察者</span></span><br><span class="line"><span class="comment">/// @param observer 观察对象</span></span><br><span class="line"><span class="comment">/// @param keyPath 观察对象路径</span></span><br><span class="line"><span class="comment">/// @param context 注册传入的context</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<h4 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)add_newKey_kvo &#123;</span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionInitial</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context; &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@--%@--%@--%@"</span>,keyPath,object,change,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>======Log======</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">15</span>:<span class="number">57</span>:<span class="number">49</span>] -[MMKVO observeValueForKeyPath:ofObject:change:context:] [第<span class="number">61</span>行] 💕 name--&lt;MMKVOPerson: <span class="number">0x600002a04100</span>&gt;--&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125;--(null)</span><br><span class="line"></span><br><span class="line">[<span class="number">15</span>:<span class="number">57</span>:<span class="number">49</span>] -[MMKVO observeValueForKeyPath:ofObject:change:context:] [第<span class="number">61</span>行] 💕 name--&lt;MMKVOPerson: <span class="number">0x600002a04100</span>&gt;--&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">123</span>;</span><br><span class="line">&#125;--(null)</span><br></pre></td></tr></table></figure>

<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>KVO主要用来做键值观察操作，想要一个值发生改变后通知另一个对象，则用KVO实现最为合适。</p>
<p>View-Model-Controller之间数据传递</p>
<h4 id="KVO触发监听方法的方式"><a href="#KVO触发监听方法的方式" class="headerlink" title="KVO触发监听方法的方式"></a>KVO触发监听方法的方式</h4><p>KVO触发分为手动触发和自动触发</p>
<h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><ul>
<li>如果是监听对象特定属性值的改变，通过以下方式改变属性值会触发KVO；<ol>
<li>使用点语法</li>
<li>使用setter方法</li>
<li>使用KVC的setValue:ForKey:方法（key为<code>&lt;key&gt;</code>，<code>_&lt;key&gt;</code>不会触发）</li>
<li>使用KVC的setValue:ForKeyPath:方法（key为<code>&lt;key&gt;</code>，<code>_&lt;key&gt;</code>不会触发）</li>
</ol>
</li>
<li>如果是监听集合对象的改变，需要通过KVC的mutableArrayValueForKey:等方法获取代理对象，并使用代理对象进行操作，当代理对象的内部对象发生改变时，会触发KVO。集合对象包含NSArray 和 NSSet。</li>
</ul>
<h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul>
<li><p>普通对象属性或是成员变量使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSArray、NSSet对象使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="KVO的进阶使用"><a href="#KVO的进阶使用" class="headerlink" title="KVO的进阶使用"></a>KVO的进阶使用</h3><h4 id="observationInfo属性"><a href="#observationInfo属性" class="headerlink" title="observationInfo属性"></a>observationInfo属性</h4><ul>
<li><code>observationInfo</code>属性是<code>NSKeyValueObserving.h</code>文件中系统通过分类给<code>NSObject</code>添加的属性，所以所有继承于<code>NSObject</code>的对象都含有该属性；</li>
<li>可以通过<code>observationInfo</code>属性查看被观察对象的全部观察信息，包括<code>observer</code>、<code>keyPath</code>、<code>options</code>、<code>context</code>等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable) void *observationInfo NS_RETURNS_INNER_POINTER;</span><br></pre></td></tr></table></figure>

<h4 id="context的使用"><a href="#context的使用" class="headerlink" title="context的使用"></a>context的使用</h4><p>注册方法addObserver:forKey:options:context:中context可以传入任意数据，并且可以在监听方法中接收到这个数据。</p>
<ul>
<li><p>context左右：标签，可以更精确的确定被观察对象属性，用于继承、多监听；也可用于传值</p>
<p>KVO只有一个监听回调方法<code>observeValueForKeyPath:ofObject:change:context:</code>，我们通常情况下可以在注册方法中指定context为NULL，并在监听方法中通过object 和 keyPath来判断触发KVO的来源</p>
<p>但是如果存在继承的情况，子类和父类都对同一个属性进行了观察，当属性变化时候由谁来进行处理，通过context就能很好的解决这个问题，在注册方法中为context设置一个独立无二的值，然后在监听方法中对context进行校验即可</p>
</li>
<li><p>苹果推荐用法：用context来准确的缺点被观察对象属性，使用唯一命名的静态变量地址作为context的值。可以为整个类设置一个context，然后在监听方法中通过object 和 keypath来确定被观察属性，这样存在继承的情况就可以通过context来判断，也可以为每个被观察对象数量设置不同的context，这样使用context就能精确的确定被观察对象属性。</p>
</li>
</ul>
<p>以SDWebImage源码为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * SDMemoryCacheContext = &amp;SDMemoryCacheContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册监听</span></span><br><span class="line">[config addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxMemoryCost)) options:<span class="number">0</span> context:SDMemoryCacheContext];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == SDMemoryCacheContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxMemoryCost))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.totalCostLimit = <span class="keyword">self</span>.config.maxMemoryCost;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxMemoryCount))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.countLimit = <span class="keyword">self</span>.config.maxMemoryCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>context优点：嵌套少，性能高，更安全、扩展性强</li>
<li>context注意点：<ol>
<li>如果传的是一个对象，必须在移除观察之前持有它的强引用，否则在监听方法中访问<code>context</code>就可能Crash</li>
<li>空传NULL 而不应该传nil</li>
</ol>
</li>
</ul>
<p>直接出现Crash</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MMKVOPerson *person = [MMKVOPerson new];</span><br><span class="line">person.name = <span class="string">@"person"</span>;</span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionInitial</span> context:(__bridge <span class="keyword">void</span> * _Nullable)(person)];</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span>: EXC_BAD_ACCESS (code=<span class="number">1</span>, address=<span class="number">0x64b6f2e7498c</span>)</span><br></pre></td></tr></table></figure>

<h4 id="KVO的自动触发控制"><a href="#KVO的自动触发控制" class="headerlink" title="KVO的自动触发控制"></a>KVO的自动触发控制</h4><p>通过在被观察对象的类中重写<code>automaticallyNotifiesObserversForKey:</code>方法来控制<code>KVO</code>的自动触发，通过控制，我们可以只让外界观察类中的某些属性的变化</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">20</span>:<span class="number">03</span>:<span class="number">19</span>] -[MMKVO observeValueForKeyPath:ofObject:change:context:] [第<span class="number">108</span>行] 💕 name--&lt;MMKVOPerson: <span class="number">0x600000e28dd0</span>&gt;--&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="string">"&lt;null&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于注册监听<code>option</code>包含的<code>NSKeyValueObservingOptionInitial</code>的观察对象，会在注册观察者后立即收到一次通知。</p>
<p>也可以实现遵循命名规则为<code>+ (BOOL)automaticallyNotifiesObserversOf&lt;Key&gt;</code>的方法来单一控制属性的KVO自动触发，<code>&lt;key&gt;</code>为属性名（首字母大写）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversOfName;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>第一个方法的优先级高于第二个方法。如果实现了<code>automaticallyNotifiesObserversForKey:</code>方法，并对<code>&lt;key&gt;</code>做了处理，则系统不会再调用 <code>&lt;key&gt;</code>的<code>automaticallyNotifiesObserversOf&lt;Key&gt;</code></li>
<li>options指定的<code>NSKeyValueObservingOptionInitial</code>触发的<code>KVO</code>通知，是无法被<code>automaticallyNotifiesObserversForKey:</code>阻止</li>
</ul>
</blockquote>
<h4 id="KVO的手动触发"><a href="#KVO的手动触发" class="headerlink" title="KVO的手动触发"></a>KVO的手动触发</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>使用KVO监听成员变量值的改变；</li>
<li>在某些需要控制监听过程的场景下：<ol>
<li>为了尽量减少不必要的触发通知操作</li>
<li>当多个更改同时具备的时候才调用属性改变的监听方法</li>
</ol>
</li>
</ul>
<h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h5><ul>
<li>由于KVO的本质，重写setter方法来达到可以通知所有观察者对象的目的，所以只有通过setter方法或者KVC方法去修改属性变量值的时候，才会触发KVO，直接修改成员变量是不会触发KVO。</li>
<li>当我们要使用KVO监听成员变量值改变的时候，可以通过在为成员变量赋值的前后手动调用willChangeValueForKey: 和 didChangeValueForKey:两个方法来手动触发KVO。</li>
<li>NSKeyValueObservingOptionPrior（分别在值改变前后触发方法，即一次修改有两次触发），两次触发分别在willChangeValueForKey: 和 didChangeValueForKey:的时候进行。</li>
<li>如果注册方法中options传入NSKeyValueObservingOptionPrior，那么可以通过值调用willChangeValueForKey:来触发改变前的那次KVO，可以用于在属性即将改变时做一些操作。</li>
</ul>
<h4 id="KVO新旧值相等时不触发"><a href="#KVO新旧值相等时不触发" class="headerlink" title="KVO新旧值相等时不触发"></a>KVO新旧值相等时不触发</h4><p>控制KVO监听的属性值修改前后相等时，不触发KVO的监听方法，可以结合自动触发和手动触发来实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        automatic = <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![_name isEqualToString:name]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">        _name = name;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动观察集合属性"><a href="#手动观察集合属性" class="headerlink" title="手动观察集合属性"></a>手动观察集合属性</h4><p>手动触发监听方法API（数组）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，根据<code>KVC</code>的<code>NSMutableArray</code>搜索模式：</p>
<ul>
<li>至少要实现一个插入和一个删除方法，都在不会触发<code>KVO</code><ol>
<li>插入方法：<code>insertObject:in&lt;Key&gt;AtIndex:</code>或<code>insert&lt;Key&gt;:atIndexes:</code> </li>
<li>删除方法：<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>或<code>remove&lt;Key&gt;AtIndexes:</code></li>
</ol>
</li>
<li>可以不实现替换方法，但是如果不实现替换方法，执行替换操作时，KVO会把它当成先删除后添加，即会触发两次<code>KVO</code>。第一次触发<code>KVO</code>中<code>change</code>字典的<code>old</code>键的值为替换前的元素，第二次触发的<code>KVO</code>中<code>change</code>字典的<code>new</code>键的值为替换后的元素，前提条件是注册方法中的<code>options</code>传入对于的枚举值。</li>
<li>如果实现替换方法，则执行替换操作只会触发一次<code>KVO</code>，并且<code>change</code>字典会同时包含<code>new</code>和<code>old</code>，前提条件是注册方法中的<code>options</code>中传入了对于的枚举值。<ol>
<li>替换方法：<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></li>
</ol>
</li>
<li>建议实现替换方法以提高性能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    BOOL automatic &#x3D; NO;</span><br><span class="line">    if ([key isEqualToString:@&quot;mArray&quot;]) &#123;</span><br><span class="line">        automatic &#x3D; NO;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        automatic &#x3D; [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    return automatic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)insertMArray:(NSArray *)array atIndexes:(NSIndexSet *)indexes</span><br><span class="line">&#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeInsertion valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">    [self.mArray insertObjects:array atIndexes:indexes];</span><br><span class="line">    [self didChange:NSKeyValueChangeInsertion valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeMArrayAtIndexes:(NSIndexSet *)indexes</span><br><span class="line">&#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">    [self.mArray removeObjectsAtIndexes:indexes];</span><br><span class="line">    [self didChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)replaceMArrayAtIndexes:(NSIndexSet *)indexes withMArray:(NSArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeReplacement valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">    [self.mArray replaceObjectsAtIndexes:indexes withObjects:array];</span><br><span class="line">    [self didChange:NSKeyValueChangeReplacement valuesAtIndexes:indexes forKey:@&quot;mArray&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KVO的依赖观察"><a href="#KVO的依赖观察" class="headerlink" title="KVO的依赖观察"></a>KVO的依赖观察</h4><h5 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h5><p>有些情况下，一个属性的改变依赖于背的一个或多个属性的改变，也就是说当别的属性遍了，这个属性也会跟着改变。</p>
<p>比如我们对<code>Download</code>类中的<code>downloadProgress</code>属性进行<code>KVO</code>监听，改属性的改变依赖于<code>writtenData</code> 和 <code>totalData</code>属性的改变。观察者监听了<code>downloadProgress</code>，当<code>writtenData</code> 和 <code>totalData</code>属性值发生改变时，观察者也应该被通知。</p>
<ol>
<li><p>重写<code>keyPathsForValuesAffectingValueForKey:</code>方法指明属性依赖于 <code>writtenData</code> 和 <code>totalData</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"downloadProgress"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@"writtenData"</span>,<span class="string">@"totalData"</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个遵循命名规则为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的类方法，<code>&lt;key&gt;</code>是依赖于其他值的属性名（首字母大小）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingDownloadProgress</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"writtenData"</span>,<span class="string">@"totalData"</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>注意：以上两个方法可以同时存在，且都会调用，但是最终结果会以<code>keyPathsForValuesAffectingValueForKey:</code>为准。</p>
</blockquote>
<h5 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h5><p>以上方法在观察集合属性时就不管用了。例如，假如你有一个 Department 类，它有一个装有 Employee 类的实例对象的数组，Employee 类有 salary 属性。你希望 Department 类有一个 totalSalary 属性来计算所有员工的薪水，也就是在这个关系中 Department 的 totalSalary 依赖于所有 Employee 实例对象的 salary 属性。以下有两种方法可以解决这个问题。</p>
<ol>
<li><p>你可以用<code>KVO</code>将 parent（比如 Department ）作为所有 children（比如 Employee ）相关属性的观察者。你必须在把 child 添加或删除到 parent 时把 parent 作为 child 的观察者添加或删除。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中我们可以针对被依赖项的变更来更新依赖项的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Department.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *totalSalaryContext = &amp;totalSalaryContext;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Department</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSArray</span>&lt;Employee *&gt; *employees;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSNumber</span> *totalSalary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Department</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEmployees:(<span class="built_in">NSArray</span> *)employees</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.employees = [employees <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">for</span> (Employee *em <span class="keyword">in</span> <span class="keyword">self</span>.employees) &#123;</span><br><span class="line">            [em addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"salary"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:totalSalaryContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == totalSalaryContext) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setTotalSalary:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"employees.@sum.salary"</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)setTotalSalary:(<span class="built_in">NSNumber</span> *)totalSalary</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_totalSalary != totalSalary) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">        _totalSalary = totalSalary;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (Employee *em <span class="keyword">in</span> <span class="keyword">self</span>.employees) &#123;</span><br><span class="line">        [em removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"salary"</span> context:totalSalaryContext];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用iOS中观察者模式的另外一种实现方式：通知（NSNotification）</p>
</li>
</ol>
<h3 id="KVO的使用注意"><a href="#KVO的使用注意" class="headerlink" title="KVO的使用注意"></a>KVO的使用注意</h3><h4 id="移除观察者的注意点"><a href="#移除观察者的注意点" class="headerlink" title="移除观察者的注意点"></a>移除观察者的注意点</h4><ul>
<li>在调用KVO注册方法后，KVO并不会对观察者进行强引用，所以需要注意观察者的生命周期。至少需要在观察者销毁之前，调用KVO移除方法移除观察者，否则如果观察者被释放后，再次触发KVO监听方法就会Crash。</li>
<li>KVO的注册方法和移除方法应该是成对的，如果重复调用移除方法，就会抛出NSRangeException并导致Crash。</li>
<li>苹果推荐的方式是，在观察者初始化期间（init 或 viewDidLoad的时候）注册为观察者，在释放（dealloc）时调用移除方法，这样可以保证他们是成对出现的，是一种比较理想的方式。</li>
</ul>
<h4 id="防止多次注册-和-移除相同的KVO"><a href="#防止多次注册-和-移除相同的KVO" class="headerlink" title="防止多次注册 和 移除相同的KVO"></a>防止多次注册 和 移除相同的KVO</h4><p>有时候我们难以避免多次注册 和 移除KVO，或者移除了一个未注册的观察者，从而产生可能会导致Crash的风险。</p>
<h5 id="黑科技防止多次添加删除KVO出现的问题"><a href="#黑科技防止多次添加删除KVO出现的问题" class="headerlink" title="黑科技防止多次添加删除KVO出现的问题"></a>黑科技防止多次添加删除KVO出现的问题</h5><p>核心：利用runtime实现方法交换，进行拦截<code>add</code>  和 <code>remove</code> 进行操作。</p>
<h6 id="方案一：利用-try-catch"><a href="#方案一：利用-try-catch" class="headerlink" title="方案一：利用@try @catch"></a>方案一：利用@try @catch</h6><p>利用@try @catch捕获异常，不让程序Crash，但是只能针对多次删除<code>KVO</code>的处理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">kvoRemove</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzleInstanceMethod:<span class="keyword">@selector</span>(removeObserver:forKeyPath:) withSelector:<span class="keyword">@selector</span>(swizzle_removeObserver:forKeyPath:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzle_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> swizzle_removeObserver:observer forKeyPath:keyPath];</span><br><span class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h6 id="方案二：利用模型数组进行存储数据"><a href="#方案二：利用模型数组进行存储数据" class="headerlink" title="方案二：利用模型数组进行存储数据"></a>方案二：利用模型数组进行存储数据</h6><p>利用模型数据进行存储记录</p>
<ul>
<li>利用<code>runtime</code>，拦截监听对象 和 <code>keyPath</code></li>
<li>利用模型存储执行<code>addObserver</code>对象 和 监听的<code>KeyPath</code></li>
<li>进行存储校验，不存在于模型中的<code>addObserver</code>对象 和 监听的<code>KeyPath</code>，才进行<code>addObserver</code></li>
<li><code>remove</code>的时候同样进行校验一下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSKVOCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/// arrayM</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="built_in">NSMutableArray</span> *&gt; *dictM;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSKVOCache</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareInshance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSKVOCache</span> *_instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [<span class="built_in">NSKVOCache</span> new];</span><br><span class="line">        _instance.dictM = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">kvoRemove</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzleInstanceMethod:<span class="keyword">@selector</span>(removeObserver:forKeyPath:)</span><br><span class="line">                   withSelector:<span class="keyword">@selector</span>(swizzle_removeObserver:forKeyPath:)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> swizzleInstanceMethod:<span class="keyword">@selector</span>(addObserver:forKeyPath:options:context:)</span><br><span class="line">                   withSelector:<span class="keyword">@selector</span>(swizzle_addObserver:forKeyPath:options:context:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzle_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSKVOCache</span> *kvo = [<span class="built_in">NSKVOCache</span> shareInshance];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arrayM = kvo.dictM[keyPath];</span><br><span class="line">    <span class="keyword">if</span> (arrayM &amp;&amp; [arrayM containsObject:observer]) &#123;</span><br><span class="line">        [arrayM removeObject:observer];</span><br><span class="line">        [<span class="keyword">self</span> swizzle_removeObserver:observer forKeyPath:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzle_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSKVOCache</span> *kvo = [<span class="built_in">NSKVOCache</span> shareInshance];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arrayM = kvo.dictM[keyPath];</span><br><span class="line">    <span class="keyword">if</span> (!arrayM) &#123;</span><br><span class="line">        arrayM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        [kvo.dictM setObject:arrayM forKey:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![arrayM containsObject:observer]) &#123;</span><br><span class="line">        [arrayM addObject:observer];</span><br><span class="line">        [<span class="keyword">self</span> swizzle_addObserver:observer forKeyPath:keyPath options:options context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h6 id="方案三：利用obserationInfo里私有属性"><a href="#方案三：利用obserationInfo里私有属性" class="headerlink" title="方案三：利用obserationInfo里私有属性"></a>方案三：利用<code>obserationInfo</code>里私有属性</h6><p><code>obserationInfo</code>属性包含属性的监听者，通知者，以及监听的<code>keyPath</code>，通过私有属性直接拿到当前对象所监听的<code>keyPath</code>，和<code>observer</code></p>
<p>实现上和方案二基本一直，只不过可以通过<code>obserationInfo</code>充当我们前面的<code>NSKVOCache</code>的功能，进行校验</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行检索获取Key</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)observerKeyPath:(<span class="built_in">NSString</span> *)key observer:(<span class="keyword">id</span> )observer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> info = <span class="keyword">self</span>.observationInfo;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = [info valueForKey:<span class="string">@"_observances"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> objc <span class="keyword">in</span> array) &#123;</span><br><span class="line">        <span class="keyword">id</span> Properties = [objc valueForKeyPath:<span class="string">@"_property"</span>];</span><br><span class="line">        <span class="keyword">id</span> newObserver = [objc valueForKeyPath:<span class="string">@"_observer"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *keyPath = [Properties valueForKeyPath:<span class="string">@"_keyPath"</span>];</span><br><span class="line">        <span class="keyword">if</span> ([key isEqualToString:keyPath] &amp;&amp; [newObserver isEqual:observer]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h4><ul>
<li>如果对象被注册成为观察者，则该对象必须实现能响应的监听方法，当对象的属性发生改变时就会调用监听方法。如果没有实现，会直接Crash。</li>
<li><code>keyPath</code>传入的是一个字符串，为避免写错，可以使用<code>NSStringFromSelector(@selector(propertyName))</code>，将属性的getter方法SEL转换成字符串，在编译阶段对keyPath进行校验</li>
<li>如果注册方法中<code>context</code>传的是一个对象，必须在移除观察之前持有它的强引用，否则监听方法中访问<code>context</code>就可能导致Crash。</li>
<li>如果监听集合对象的改变，需要通过<code>KVC</code>的<code>mutableArrayValueForKey:</code>等方法获得代理对象，并使用代理对象进行操作，当代理对象的内部对象发生改变时，会触发<code>KVO</code>。如果直接对集合对象进行操作改变，不会触发<code>KVO</code>。</li>
<li>在观察者类的监听方法中，应该为无法识别的<code>context</code> 或者 <code>object</code>、keyPath调用父类的<code>[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</code></li>
</ul>
<h3 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h3><h4 id="isa-swizzling"><a href="#isa-swizzling" class="headerlink" title="isa-swizzling"></a>isa-swizzling</h4><p>苹果使用了isa混写技术（isa-swizzling）来实现KVO，当我们调用addObserver:forKeyPath:options:context:方法为instance添加KVO监听后，系统会在运行时利于Runtime API动态创建instance对象所属类的子类NSKVONotifying_A，并且让instance对象的isa指针指向这个全新的子类，并重写原类的被观察属性的setter方法来达到可以通知所有观察者对象的目的。</p>
<ul>
<li>这个子类指向它自己的meta-class对象，而不是原类的meta-class对象</li>
<li>重写的setter方法的SEL对象的IMP为Foundation中的<code>_NSSetXXXValueAndNotify</code>函数（XXX为key的数据类型），当被观察的属性发生变化时，会调用_NSSetXXXValueAndNotify函数，这个函数中调用：<ol>
<li>willChangeValueForKey:方法</li>
<li>父类原来的setter方法</li>
<li>didChangeValueForKey:方法（内部触发observer监听方法observeValueForKeyPath:ofObject:change:context:）</li>
</ol>
</li>
<li>在移除KVO监听后，被观察对象的isa会指回原类A，但是NSKVONotifying_A类并没有销毁，还是保存在内存中</li>
</ul>
<h4 id="KVO动态生成的子类都有哪些方法"><a href="#KVO动态生成的子类都有哪些方法" class="headerlink" title="KVO动态生成的子类都有哪些方法"></a>KVO动态生成的子类都有哪些方法</h4><p>NSKVONotifying_A除了重写setter方法，还是重写了class、dealloc、_isKVO这三个方法（可以使用runtime的class_copyMethodList函数打印方法列表获取），其中：</p>
<ul>
<li>Class:class 方法返回的是父类的class对象，目的是为了不让外界知道KVO动态生成类的存在；</li>
<li>Dealloc:释放KVO使用过程产生的东西</li>
<li>_isKVO:用来标示它是一个KVO的类</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/11/17/iOS%E2%80%94%E2%80%94KVC%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/iOS%E2%80%94%E2%80%94KVC%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">iOS——KVC相关总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-17 16:02:22" itemprop="dateCreated datePublished" datetime="2020-11-17T16:02:22+08:00">2020-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-08 20:26:04" itemprop="dateModified" datetime="2020-12-08T20:26:04+08:00">2020-12-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ul>
<li>KVC 全称是（Key-Value Coding）键值编码，是有<code>NSKeyValueCoding</code>非正式协议启用的一种机制，对象采用这种机制来提供对其属性的间接访问，可以通过字符串来访问一个对象的成员变量或其关联的存取方法（<code>setter</code> or <code>getter</code>）。</li>
<li>通常，我们可以直接通过存储方法或变量名来访问对象的属性，我们也可以通过<code>KVC</code>间接访问对象的属性，并且<code>KVC</code>还可以访问私有变量。某些情况下，<code>KVC</code>还可以帮助简化代码</li>
<li><code>KVC</code>是许多其他Cocoa技术的基础，比如<code>KVO</code>、<code>Cocoa bingdings</code>，<code>Core Data</code>，<code>AppleScript-ability</code>等。</li>
</ul>
<p>访问对象属性</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return an array containing the results of invoking -valueForKey: on each of the receiver's elements. The returned array will contain NSNull elements for each instance of -valueForKey: returning nil.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;<span class="comment">// 通过key来取值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Invoke -setValue:forKey: on each of the receiver's elements.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Key-path-taking variants of like-named methods. The default implementation of each parses the key path enough to determine whether or not it has more than one component (key path components are separated by periods). If so, -valueForKey: is invoked with the first key path component as the argument, and the method being invoked is invoked recursively on the result, with the remainder of the key path passed as an argument. If not, the like-named non-key-path-taking method is invoked.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath; <span class="comment">// 通过keyPath来取值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given an array of keys, return a dictionary containing the keyed attribute values, to-one-related objects, and/or collections of to-many-related objects. Entries for which -valueForKey: returns nil have NSNull as their value in the returned dictionary.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given a dictionary containing keyed attribute values, to-one-related objects, and/or collections of to-many-related objects, set the keyed values. Dictionary entries whose values are NSNull result in -setValue:nil forKey:key messages being sent to the receiver.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>

<h5 id="setValue-forKey"><a href="#setValue-forKey" class="headerlink" title="setValue:forKey"></a>setValue:forKey</h5><p>通过<code>KVC</code>间接为属性赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];</span><br></pre></td></tr></table></figure>

<h5 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey"></a>valueForKey</h5><p>通过<code>KVC</code>间接取值，通过其<code>key</code>获取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myAccount valueForKey:@&quot;currentBalance&quot;];</span><br></pre></td></tr></table></figure>

<h5 id="setValue-forKeyPath"><a href="#setValue-forKeyPath" class="headerlink" title="setValue:forKeyPath"></a>setValue:forKeyPath</h5><p>KVC<code>还支持多级访问</code>，KeyPath用法和点语法相同。例如：我们想对<code>myAccount</code>的<code>owner</code>属性的<code>address</code>属性的<code>street</code>属性赋值，其<code>keyPath</code>为<code>myAccount.owner.address.</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myAccount setValue:<span class="string">@"地址"</span> forKeyPath:<span class="string">@"owner.address.street"</span>];</span><br></pre></td></tr></table></figure>

<h4 id="多值操作"><a href="#多值操作" class="headerlink" title="多值操作"></a>多值操作</h4><p>给定一组<code>Key</code>，获得一组<code>Value</code>，以字典的形式返回。该方法为数组中的每个<code>key</code>调用<code>valueForKey</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure>

<p>将指定字典中的值设置到消息接受者的属性中，使用字典的key标示属性。默认实现市委每个键值调用setValue:forKey:方法，会根据需要用nil替换NSNull对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>

<h4 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h4><p>我们可以像访问其他对象一样使用<code>valueForKey:</code>或<code>setValue:forKey:</code>方法获取或设置集合对象（主要包括<code>NSArray</code>或<code>NSSet</code>）。但是，当我们要操作集合对象的内容，比如添加或者删除元素时，通过KVC的可变代理方法获取集合代理对象是有效的。</p>
<p>根据<code>KVO</code>的实现原理，是在运行时动态生成子类并重写<code>setter</code>方法来达到可以通知所有观察者对象的目的，因此我们对集合对象进行操作是不会触发<code>KVO</code>的。当我们要使用<code>KVO</code>监听集合对象变化时，需要通过<code>KVC</code>的可变代理方法获取集合代理对象，然后对代理对象进行操作，当代理对象内部对象发生变化时，会触发<code>KVO</code>的监听方法。</p>
<p><code>KVC</code>提供了三种不同的代理对象访问的代理方法，每种都有<code>key</code> 和 <code>keyPath</code>两种方法。</p>
<ul>
<li><p>返回NSMutableArray对象的代理对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)mutableArrayValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回NSMutableSet对象的代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回NSMutableOrderedSet对象的代理对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="built_in">NSString</span> *)key API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h4><p>KVC的valueForKeyPath:方法除了可以取出属性值以外，还可以在keyPath中嵌套集合运算符，来对集合对象进行操作。</p>
<p>KeyPath 分为三部分，left key path（左键路径）、Collection operation（集合运算符）、right key path（右键路径，要进行运算的集合中的属性）</p>
<p>集合运算符分为三类：</p>
<ul>
<li>聚合运算符：以某种方式合并集合中的对象，并返回右键路径中指定的属性的数据类型匹配的一个对象，一般返回NSNumber对象</li>
<li>数组运算符：根据运算符的条件，将符合条件的对象以一个NSArray对象返回</li>
<li>嵌套运算符：处理集合对象中嵌套其他集合对象的情况，并根据运算符返回一个NSArray 或 NSSet对象</li>
</ul>
<h5 id="聚合运算符"><a href="#聚合运算符" class="headerlink" title="聚合运算符"></a>聚合运算符</h5><p>以某种方式合并集合中的对象，并返回右键路径中指定的属性的数据类型匹配的一个对象，一般返回NSNumber对象</p>
<h6 id="avg"><a href="#avg" class="headerlink" title="@avg"></a>@avg</h6><p>读取集合中每个元素的右键路径指定的属性，将其转换为double类型（nil 用 0代替），并计算这些值的算术平均值，然后将结果以NSNumber对象返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算集合中amount属性的平均值</span></span><br><span class="line"><span class="built_in">NSNumber</span> *transactionAverage = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@"@avg.amount"</span>];</span><br></pre></td></tr></table></figure>

<h6 id="count"><a href="#count" class="headerlink" title="@count"></a>@count</h6><p>计算集合中的元素个数，以NSNumber实例返回</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 transactions 集合中的元素个数。</span></span><br><span class="line"><span class="built_in">NSNumber</span> *numberOfTransactions = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@"@count"</span>];</span><br><span class="line"><span class="comment">// numberOfTransactions 的值为 13。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：@count运算符比较特别，它不需要写右键路径，即使写了也会被忽略</p>
</blockquote>
<h6 id="sum"><a href="#sum" class="headerlink" title="@sum"></a>@sum</h6><p>读取集合中每个元素的右键路径指定的属性，将其转换为double类型(nil 用 0代替)，并计算这些值的总和，然后将结果以NSNumber实例返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算amount 的总和</span><br><span class="line">NSNumber *amountSum &#x3D; [self.transactions valueForKeyPath:@&quot;@sum.amount&quot;];</span><br></pre></td></tr></table></figure>

<h6 id="max"><a href="#max" class="headerlink" title="@max"></a>@max</h6><p>返回集合右键路径指定的属性的最大值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取日期的最大值</span><br><span class="line">NSDate *latestDate &#x3D; [self.transactions valueForKeyPath:@&quot;@max.date&quot;];</span><br></pre></td></tr></table></figure>

<p>@min</p>
<p>返回集合右键路径指定的属性的最小值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取日期的最小值</span></span><br><span class="line"><span class="built_in">NSDate</span> *earliestDate = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@"@min.date"</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：@max 和 @min根据右键路径指定的属性在集合中搜索，搜索使用compare:方法进行。因此，右键路径指定的属性必须能响应compare:消息。搜索忽略值为nil的集合项，也可通过重写compare:方法对搜索结果进行控制。</p>
</blockquote>
<h5 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h5><p>根据运算符的条件，将符合条件的对象以一个NSArray实例返回。</p>
<h6 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="@unionOfObjects"></a>@unionOfObjects</h6><p>读取数组中每个元素的右键路径指定的属性，放在一个NSArray实例中返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取集合中的所有payee对象</span><br><span class="line">NSArray *payees &#x3D; [self.transactions valueForKeyPath:@&quot;@unionOfObjects.payee&quot;];</span><br><span class="line">&#x2F;&#x2F; payees 数组中包含所有payee元素的字符串</span><br></pre></td></tr></table></figure>

<h6 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="@distinctUnionOfObjects"></a>@distinctUnionOfObjects</h6><p>读取数组中每个元素的右键路径指定的属性，放在一个NSArray实例中，将数组进行去重后返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取集合中的所有不同的 payee 对象。</span><br><span class="line">NSArray *distinctPayees &#x3D; [self.transactions valueForKeyPath:@&quot;@distinctUnionOfObjects.payee&quot;];</span><br><span class="line">&#x2F;&#x2F; distinctPayees 数组包含以下字符串：Car Loan, General Cable, Animal Hospital, Green Power, Mortgage</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在使用数组运算符时，如果有任何操作的对象为nil，则valueForKeyPath:方法将引发异常</p>
</blockquote>
<h5 id="嵌套运算符"><a href="#嵌套运算符" class="headerlink" title="嵌套运算符"></a>嵌套运算符</h5><p>处理集合对象中嵌套其他集合对象的情况，并根据运算符返回一个NSArray 和 NSSet实例。</p>
<p>如下，一个数组中放着另外两个数组</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>* moreTransactions = @[&lt;<span class="meta"># transaction data #&gt;];</span></span><br><span class="line"><span class="built_in">NSArray</span>* arrayOfArrays = @[<span class="keyword">self</span>.transactions, moreTransactions];</span><br></pre></td></tr></table></figure>

<h6 id="unionOfArrays"><a href="#unionOfArrays" class="headerlink" title="@unionOfArrays"></a>@unionOfArrays</h6><p>读取集合中每个集合中每个元素的右键路径指定的属性，放在一个NSArray实例中返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 arrayOfArrays 集合中的每个集合中的所有 payee 对象。</span></span><br><span class="line"><span class="built_in">NSArray</span> *collectedPayees = [arrayOfArrays valueForKeyPath:<span class="string">@"@unionOfArrays.payee"</span>];</span><br></pre></td></tr></table></figure>

<h6 id="distinctUnionOfArrays"><a href="#distinctUnionOfArrays" class="headerlink" title="@distinctUnionOfArrays"></a>@distinctUnionOfArrays</h6><p>读取集合中每个集合每个元素的右键路径指定的属性，放在一个NSArray实例中，将数组进行去重后返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 arrayOfArrays 集合中的每个集合中的所有不同的 payee 对象。</span></span><br><span class="line"><span class="built_in">NSArray</span> *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:<span class="string">@"@distinctUnionOfArrays.payee"</span>];</span><br></pre></td></tr></table></figure>

<h6 id="distinctUnionOfSets"><a href="#distinctUnionOfSets" class="headerlink" title="@distinctUnionOfSets"></a>@distinctUnionOfSets</h6><p>读取集合中每个集合每个元素的右键路径指定的属性，放在一个NSSet实例中，去重后返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSSet</span> *collectedDistinctPayees = [setOfSets valueForKeyPath:<span class="string">@"@distinctUnionOfSets.payee"</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>在使用嵌套运算符时，valueForKeyPath:内部会根据运算符创建一个NSMuatbleArray 或 NSMuatbleSet对象，将集合中的array 和 set添加进去在进行操作。如果集合中有非集合元素，会导致Crash</li>
<li>使用unionArrays 或 distionctUnionOfArrays运算符，消息接收者应该是arrayOfArrays类型，即<code>NSArray&lt;NASrray *&gt; *arrayOfArrays;</code>；使用distinctUnionOfSets运算符，消息接收者的类型应该是setOfSets或者arrayOfSets类型，否则会发生异常。</li>
<li>在使用嵌套运算符时，如果有任何操作对象为nil，则valueForKeyPath:方法将引发异常</li>
</ul>
</blockquote>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>如果集合对象都是NSNumber，右键路径可以用self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array &#x3D; @[@1, @2, @3, @4, @5];</span><br><span class="line">NSNumber *sum &#x3D; [array valueForKeyPath:@&quot;@sum.self&quot;];</span><br><span class="line">NSLog(@&quot;%d&quot;,[sum intValue]);</span><br></pre></td></tr></table></figure>

<h4 id="自定义集合运算符"><a href="#自定义集合运算符" class="headerlink" title="自定义集合运算符"></a>自定义集合运算符</h4><p>根据<code>Runtime</code>获取<code>NSArray</code>类的方法列表</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)print_arrayMethodList &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    Method *methods = class_copyMethodList([<span class="built_in">NSArray</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果(未完全截图)：</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201208151209139.png" alt="image-20201208151209139"></p>
<p>方法很多，搜索关键字<code>avg</code>、<code>count</code>、<code>sum</code>等<code>KVC</code>为我们提供的集合运算符，发现都有对象的方法<code>_&lt;operatorKey&gt;ForKeyPath:</code></p>
<blockquote>
<p>注意：再来看一下<code>NSSet</code>类支持的集合运算符：</p>
<p>可见<code>NSSet</code>类不支持<code>@unionOfObjects</code> 和 <code>@unionOfArrays</code>运算符，如果使用了就会抛出<code>NSInvalidArgumentException</code>异常并崩溃，reason：<code>[&lt;__NSSetI 0x6000017a12f0&gt; valueForKeyPath:]: this class does not implement the unionOfArrays operation.</code>不支持该运算符。</p>
<p>而<code>NSArray</code>类虽然支持<code>@distinctUnionOfSets</code>运算符，但是必须是<code>arrayOfSets</code>类型，即<code>NSArray&lt; NSSet* &gt;* arrayOfSets;</code>，因为<code>_distinctUnionOfSetsForKeyPath</code>方法中会创建一个<code>NSMutableSet</code>实例，并调用<code>unionSet:</code>方法将集合中的set元素添加进去再进行操作，如果是<code>arrayOfArrays</code>类型就会抛出<code>NSInvalidArgumentException</code>并导致程序崩溃，reason: <code>&#39;*** -[NSMutableSet unionSet:]: set argument is not an NSSet&#39;</code>即集合中有非<code>NSSet</code>元素。</p>
</blockquote>
<p>我们尝试为NSArray添加一个分类，并定义一个_medianForKeyPath:方法，用来获取NSArray中的中位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface NSArray (kvc)</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (kvc)</span><br><span class="line">- (NSNumber *)_medianForKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    &#x2F;&#x2F;排序</span><br><span class="line">    NSArray *sortedArray &#x3D; [self sortedArrayUsingSelector:@selector(compare:)];</span><br><span class="line">    double median;</span><br><span class="line">    if (self.count % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        NSInteger index1 &#x3D; sortedArray.count * 0.5;</span><br><span class="line">        NSInteger index2 &#x3D; sortedArray.count * 0.5 - 1;</span><br><span class="line">        median &#x3D; ([[sortedArray objectAtIndex:index1] doubleValue] + [[sortedArray objectAtIndex:index2] doubleValue]) * 0.5;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSInteger index &#x3D; (sortedArray.count-1) * 0.5;</span><br><span class="line">        median &#x3D; [[sortedArray objectAtIndex:index] doubleValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return [NSNumber numberWithDouble:median];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)medianObject_kvc &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *arr = @[@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">8</span>,@<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSNumber</span> *num = [arr valueForKeyPath:<span class="string">@"@median.self"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,num);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">15</span>:<span class="number">55</span>:<span class="number">06</span>] +[MMKVC medianObject_kvc] [第<span class="number">67</span>行] 💕 <span class="number">3.5</span></span><br></pre></td></tr></table></figure>

<h4 id="非对象值处理"><a href="#非对象值处理" class="headerlink" title="非对象值处理"></a>非对象值处理</h4><p><code>KVC</code>支持基础数据类型和结构体，在使用<code>KVC</code>赋值或取值的时候，会自动在非对象值和对象值之间转换</p>
<ul>
<li>当进行取值如<code>valueForKey:</code>时，如果返回值非对象，会使用该值初始化一个<code>NSNumber</code>或 <code>NSValue</code>实例，然后返回该实例。</li>
<li>当进行赋值如<code>setValue:forKey:</code>时，如果key的数据类型非对象，则会发送一条<code>&lt;type&gt;Value</code>消息给value对象以提取基础数据，然后复制给<code>key</code></li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>因为swift中的所有属性都是对象，所以这里仅适用于Objective-C属性。当进行赋值如setValue:forKey时，如果key 的数据类是非对象类型，则value就禁止传nil。否则调用setNilValueForKey:方法，该方法的默认实现抛出异常NSInvalidArgumentException，并导致Crash</li>
</ul>
</blockquote>
<h4 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h4><p><code>KVC</code>提供了属性验证的方法，如下，我们可以在使用<code>KVC</code>赋值前验证能否为这个<code>key</code>赋值指定的<code>value</code>。</p>
<p><code>validateValue</code>方法的默认实现是查看消息接收者类中是否实现了遵循命名规则为<code>validate&lt;key&gt;:error:</code>的方法，如果有就返回调用该方法的结果，如果没有，就默认验证成功并返回YES，我们可以在消息接收者类中实现<code>validate&lt;key&gt;:error:</code>方法来定义逻辑返回YES 或 NO</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKeyPath:(<span class="built_in">NSString</span> *)inKeyPath error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="keyword">id</span> _Nullable * _Nonnull)ioValue forKey:(<span class="built_in">NSString</span> *)inKey error:(<span class="keyword">out</span> <span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p>在Person类中实现了validateName:error:方法，验证给name赋的值是不是Jack。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.m</span></span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    <span class="built_in">NSString</span> *value = <span class="string">@"rose"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@"name"</span>;</span><br><span class="line">    <span class="built_in">NSError</span>  *error;</span><br><span class="line">    <span class="built_in">BOOL</span> result = [person validateValue:&amp;value forKey:key error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error = %@"</span>, error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateName:(<span class="keyword">id</span> *)value error:(<span class="keyword">out</span> <span class="built_in">NSError</span> * _Nullable __autoreleasing *)outError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name = *value;</span><br><span class="line">    <span class="built_in">BOOL</span> result = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"jack"</span>]) &#123;</span><br><span class="line">        result = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：默认情况下，KVC是不会自动验证属性的。</p>
</blockquote>
<h4 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h4><h5 id="基本的getter搜索模式"><a href="#基本的getter搜索模式" class="headerlink" title="基本的getter搜索模式"></a>基本的getter搜索模式</h5><p>以下是valueForKey:方法的默认实现，给定一个key作为输入参数，在消息接收者类中操作，执行以下过程。</p>
<ol>
<li>按照<code>get&lt;key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code>、<code>_&lt;key&gt;</code>顺序查找，如果找到就调用取值直接执行5，否则执行2</li>
<li>查找countOf<key>、objectIn<key>AtIndex:、<key>AtIndexes:命名的方法。如果找到第一个和后面两个中的至少一个，则创建一个能够响应所有NSArray的方法的集合代理对象（类型为NSKeyValueArray，继承NSArray），并返回该对象。否则执行3<ul>
<li>代理对象随后将将其接收到的任何NSArray消息转换为countOf<key>、objetIn<key>AtIndex:、<key>AtIndexes:消息的组合，并将其发送给KVC调用方。如果原始对象还实现了一个名为get<key>:range:的可选方法，则代理对象也会在适当时使用该方法</li>
<li>当KVC调用方与代理对象一起工作时，允许底层属性的行为如果NSArray一样，即使它不是NSArray</li>
</ul>
</li>
<li>查找<code>countOf&lt;key&gt;</code>、<code>enumeratorOf&lt;key&gt;</code>、<code>memberOf&lt;key&gt;:</code>命名的方法，如果三个方法都找到，则创建一个能够响应所有NSSet的方法的集合代理对象（类型为NSKeyValueSet，继承自NSSet），并返回该对象。否则执行4<ul>
<li>代理对象随后将其接收到的任何NSSet消息转换为<code>countOf&lt;key&gt;</code>、<code>enumeratorOf&lt;key&gt;</code>、<code>memberOf&lt;key&gt;:</code>消息的组合，并将其发送给KVC的调用方</li>
<li>当KVC调用方与代理对象一起工作时，允许底层属性的行为如同NSSet一样，即使他不是NSSet。</li>
</ul>
</li>
<li>查看消息接收者类的<code>+accessInstanceVariableDirectly</code>方法的返回值（默认返回YES），如果返回YES，就按照<code>_&lt;key&gt;</code>、<code>_is&lt;key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code>顺序查找成员变量。如果找到就直接取值执行5，否则执行6。如果<code>+accessInstanceVariableDirectly</code>方法返回NO， 也会执行6</li>
<li>如果取到值是一个对象指针，即获取的是对象，则直接将对象返回。如果取得值是一个NSNumber支持的数据类型，则转换为NSValue对象，然后返回。</li>
<li>调用valueForUndefinedKey:方法，该方法抛出异常NSUnknownKeyException，并导致程序Crash，这是默认实现，我们可以重写该方法根据特点的key做一些特殊处理。</li>
</ol>
<h5 id="基本的Setter搜索模式"><a href="#基本的Setter搜索模式" class="headerlink" title="基本的Setter搜索模式"></a>基本的Setter搜索模式</h5><p>以下是setValue:forKey方法的默认实现，给定一个key作为输入参数，返回属性名为key的集合的代理对象（这里指的是NSMutableArray对象），在消息接收者类中操作，执行以下过程。</p>
<ol>
<li><p>查找—对方法<code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code><br>（相当于<code>NSMutableArray</code>的原始方法<code>insertObjects:atIndexes:</code>和<code>removeObjectsAtIndexes:</code>）。</p>
<ul>
<li><p>如果我们至少实现了一个<code>insertion</code>方法和一个<code>removal</code>方法，则返回一个代理对象，来响应发送给<code>NSMutableArray</code>的消息，通过发送<code>insertObject:in&lt;Key&gt;AtIndex:</code>、<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>、<code>insert&lt;Key&gt;:atIndexes:</code>、<code>remove&lt;Key&gt;AtIndexes:</code>组合消息给<code>KVC</code>调用方。否则执行②。</p>
<blockquote>
<p>该代理对象类型为<code>NSKeyValueFastMutableArray2</code>，继承链为<code>NSKeyValueFastMutableArray2</code>-&gt;<code>NSKeyValueFastMutableArray</code>-&gt;<code>NSKeyValueMutableArray</code>-&gt;<code>NSMutableArray</code>。</p>
</blockquote>
</li>
<li><p>如果我们也实现了一个可选的<code>replace object</code>方法，如<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>，代理对象在适当的情况下也会使用它们，以获得最佳性能。</p>
</li>
</ul>
</li>
<li><p>查找<code>set&lt;Key&gt;:</code>方法。如果找到，就会向<code>KVC</code>调用方发送一个<code>set&lt;Key&gt;:</code></p>
<p>消息，来返回一个响应<code>NSMutableArray</code>消息的代理对象。否则执行③。</p>
<blockquote>
<p>该代理对象类型为<code>NSKeyValueSlowMutableArray</code>，继承链为<code>NSKeyValueSlowMutableArray</code>-&gt;<code>NSKeyValueMutableArray</code>-&gt;<code>NSMutableArray</code>。</p>
</blockquote>
<blockquote>
<p>注意：** 此步骤中描述的机制比上一步的效率低得多，因为它可能重复创建新的集合对象，而不是修改现有的集合对象。因此，在设计自己的键值编码兼容对象时，通常应该避免使用它。</p>
<p>给代理对象发送<code>NSMutableArray</code>消息都会调用<code>set&lt;Key&gt;:</code>方法。即，对代理对象进行修改，都是调用<code>set&lt;Key&gt;:</code>来重新赋值，所以效率会低很多。</p>
</blockquote>
</li>
<li><p>查看消息接收者类的<code>+accessInstanceVariablesDirectly</code>方法的返回值（默认返回<code>YES</code>）。如果返回<code>YES</code>，就按照<code>_&lt;key&gt;</code>、<code>&lt;key&gt;</code>顺序查找成员变量。如果找到就返回一个代理对象，该代理对象将接收所有<code>NSMutableArray</code>消息，通常是<code>NSMutableArray</code>或其子类。否则执行④。如果<code>+accessInstanceVariablesDirectly</code>方法返回<code>NO</code>也执行④。</p>
</li>
<li><p>返回一个可变的集合代理对象。当它接收到<code>NSMutableArray</code>消息时，发送一个<code>valueForUndefinedKey:</code>消息给<code>KVC</code>调用方，该方法抛出异常<code>NSUnknownKeyException</code>，并导致程序<code>Crash</code>。这是默认实现，我们可以重写该方法根据特定<code>key</code>做一些特殊处理。</p>
</li>
</ol>
<h5 id="其他搜索模式"><a href="#其他搜索模式" class="headerlink" title="其他搜索模式"></a>其他搜索模式</h5><p>除了以上三种，<code>KVC</code>还有<code>NSMutableSet</code>和<code>NSMutableOrderedSet</code>两种搜索模式，它们的搜索规则和<code>NSMutableArray</code>相同，只是搜索和调用的方法不同。具体可以查看<code>KVC</code>官方文档 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">KVC - Accessor Search Patterns</a></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><p>根据KVC搜索规则，当没有搜索到对应的key 或者 keyPath相关方法或者变量时，会调用对应的异常方法valueForUndefinedKey: 或 setValue:forUndefinedKey:，这两个方法的默认实现是抛出异常NSUnKnownKeyException，并导致程序Crash。我们可以重写这两个方法来处理异常</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given that an invocation of -valueForKey: would be unable to get a keyed value using its default access mechanism, return the keyed value using some other mechanism. The default implementation of this method raises an NSUndefinedKeyException. You can override it to handle properties that are dynamically defined at run-time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given that an invocation of -setValue:forKey: would be unable to set the keyed value using its default mechanism, set the keyed value using some other mechanism. The default implementation of this method raises an NSUndefinedKeyException. You can override it to handle properties that are dynamically defined at run-time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当进行赋值如setValue:forKey:时，如果key的数据类型是非对象类型，则value就禁止传nil。否则调用setNilValueForKey:方法，该方法的默认实现是抛出异常NSInvalidArgumentException，并导致程序Crash。我们可以重写这个方法来处理异常。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"hidden"</span>]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setValue:@(<span class="literal">NO</span>) forKey:@”hidden”];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> setNilValueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-alloc%E3%80%81retainCount%E3%80%81retain%E3%80%81release%E3%80%81dealloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-alloc%E3%80%81retainCount%E3%80%81retain%E3%80%81release%E3%80%81dealloc/" class="post-title-link" itemprop="url">内存管理-alloc、retainCount、retain、release、dealloc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-30 10:32:42" itemprop="dateCreated datePublished" datetime="2020-10-30T10:32:42+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-17 15:58:41" itemprop="dateModified" datetime="2020-11-17T15:58:41+08:00">2020-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接下来继续从源码角度，分析<code>alloc</code>、<code>retainCount</code>、<code>retain</code>、<code>release</code>、<code>dealloc</code>等方法的实现。</p>
<p>源码地址：<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a></p>
<h3 id="slowpath-amp-fastpath"><a href="#slowpath-amp-fastpath" class="headerlink" title="slowpath &amp; fastpath"></a>slowpath &amp; fastpath</h3><blockquote>
<p>宏定义如下：</p>
<p>#define fastpath(x) (__builtin_expect(bool(x), 1))</p>
<p>#define slowpath(x) (__builtin_expect(bool(x), 0))</p>
</blockquote>
<p>他们都是用了__builtin_expect函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __builtin_expect(<span class="keyword">long</span> <span class="built_in">exp</span>, <span class="keyword">long</span> c);</span><br></pre></td></tr></table></figure>

<p><code>__builtin_expect()</code>函数是GCC提供给程序员是用的，由于大部分程序员在分支预测上都非常糟糕，所以GCC提供这个内建函数来帮助程序员处理分支预测，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。它的意思是: <code>exp == c</code>的概率很大。</p>
<p><code>fastpath(x)</code> 表示  <code>x</code> 是1的概率很大，<code>slowpath(x)</code>表示 <code>x</code> 是0的概率很大。它和if一起使用，<code>if (fastpath(x))</code>表示执行<code>if</code>语句的可能性大，<code>if (slowpath(x))</code>表示执行<code>if</code>语句的可能性小。</p>
<h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>alloc方法的函数调用栈</p>
<h4 id="callAlloc"><a href="#callAlloc" class="headerlink" title="callAlloc"></a>callAlloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="comment">// 调用[cls alloc] or [cls allocWithZone:nil]函数的时候会来到这里，使用适当的快捷方式优化</span></span><br><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">  	<span class="comment">// 校验（checkNil &amp; !cls）</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  	<span class="comment">// 如果cls没有实现默认的allocWithZone，调用_objc_rootAllocWithZone</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">  	<span class="comment">// 给cls 发送 allocWithZone:消息</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="keyword">@selector</span>(allocWithZone:), <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 否则发送alloc消息</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callAlloc()</code>函数主要执行了一下步骤：</p>
<ul>
<li>判断类有没有实现自定义的<code>allocWithZone</code>方法，如果没有，就调用<code>_objc_rootAllocWithZone</code>函数（快捷方式）</li>
<li>如果没有快捷方式，根据<code>allocWithZone</code>的值，true 给<code>cls</code>类发送<code>allocWithZone</code>消息，false则给<code>cls</code>类发送<code>alloc</code>消息</li>
</ul>
<h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Replaced by ObjectAlloc</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>allocWithZone</code>其实现也是调用<code>_objc_rootAllocWithZone</code>函数</p>
<h4 id="alloc-1"><a href="#alloc-1" class="headerlink" title="alloc"></a>alloc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootAlloc"><a href="#objc-rootAlloc" class="headerlink" title="_objc_rootAlloc"></a>_objc_rootAlloc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc</code>函数会调用<code>_objc_rootAlloc</code>函数，最终会再次来到<code>callAlloc</code>函数，传参不再进行nil检查</p>
<h4 id="objc-rootAllocWithZone"><a href="#objc-rootAllocWithZone" class="headerlink" title="_objc_rootAllocWithZone"></a>_objc_rootAllocWithZone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_class_createInstanceFromZone</code>函数，参数<code>zone</code>已经被忽略直接传nil</p>
<h4 id="class-createInstanceFromZone"><a href="#class-createInstanceFromZone" class="headerlink" title="_class_createInstanceFromZone"></a>_class_createInstanceFromZone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();<span class="comment">// 获取cls是否有构造函数</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();<span class="comment">// 获取cls是否有析构函数</span></span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();<span class="comment">// 获取cls是否进行了isa指针优化</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">		<span class="comment">// 获取需要申请的空间大小</span></span><br><span class="line">    <span class="built_in">size</span> = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = <span class="built_in">size</span>;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 如果zone为nil，调用malloc_zone_calloc申请内存空间</span></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (id)malloc_zone_calloc((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果内存空间申请失败，调用_objc_callBadAllocHandler</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 初始化 isa 如果 zone == nil &amp;&amp; isa进行了指针优化，调用initInstanceIsa</span></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">      	<span class="comment">// 否则使用initIsa进行初始化isa指针</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果没有构造函数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 进行构造函数处理，在返回</span></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数_class_createInstanceFromZone中，通过C函数calloc申请内存空间，并初始化对象的isa</p>
<h4 id="initInstanceIsa"><a href="#initInstanceIsa" class="headerlink" title="initInstanceIsa"></a>initInstanceIsa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    ASSERT(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initIsa"><a href="#initIsa" class="headerlink" title="initIsa"></a>initIsa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">  	&#x2F;&#x2F; 未开启isa指针优化，直接将isa指针指向cls类对象</span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa &#x3D; isa_t((uintptr_t)cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ASSERT(!DisableNonpointerIsa);</span><br><span class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA		&#x2F;&#x2F; 对于64位系统，该值为0</span><br><span class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">      	&#x2F;&#x2F; 设置nonpointer 和 magic值位1 和 1101</span><br><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">      	&#x2F;&#x2F; 设置是否有析构函数</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">      	&#x2F;&#x2F; 设置class&#x2F;meta-class对象</span><br><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This write must be performed in a single store in some cases</span><br><span class="line">        &#x2F;&#x2F; (for example when realizing a class because other threads</span><br><span class="line">        &#x2F;&#x2F; may simultaneously try to use the class).</span><br><span class="line">        &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to</span><br><span class="line">        &#x2F;&#x2F; guarantee memory order w.r.t. the class index table</span><br><span class="line">        &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation</span><br><span class="line">        isa &#x3D; newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于ISA指针，具体可见内存管理—ISA指针</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [[cls alloc] init].</span><br><span class="line">id</span><br><span class="line">objc_alloc_init(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return [callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;) init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; In practice, it will be hard to rely on this function.</span><br><span class="line">    &#x2F;&#x2F; Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类的init方法什么都没有做，只是将alloc创建的对象返回。因为我们可以重写init方法做一些初始化操作。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calls [cls new]</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_opt_new(Class cls)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(cls &amp;&amp; !cls-&gt;ISA()-&gt;hasCustomCore())) &#123;</span><br><span class="line">        <span class="keyword">return</span> [callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>) init];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(new));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)new &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(<span class="keyword">self</span>, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new方法比较简单，只是嵌套了alloc和init</p>
<h3 id="copy-amp-mutableCopy"><a href="#copy-amp-mutableCopy" class="headerlink" title="copy &amp; mutableCopy"></a>copy &amp; mutableCopy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)copy &#123;</span><br><span class="line">    return [(id)self copyWithZone:nil];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return (id)self;</span><br><span class="line">&#125;</span><br><span class="line">- (id)mutableCopy &#123;</span><br><span class="line">    return [(id)self mutableCopyWithZone:nil];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return (id)self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy和mutableCopy也很简单，只是调用了copyWithZone和mutableCopyWithZone方法。</p>
<h3 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h3><p>获取对象的引用计数器</p>
<h4 id="retainCount-1"><a href="#retainCount-1" class="headerlink" title="retainCount"></a>retainCount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return _objc_rootRetainCount(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRetainCount"><a href="#objc-rootRetainCount" class="headerlink" title="_objc_rootRetainCount"></a>_objc_rootRetainCount</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_objc_rootRetainCount(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    return obj-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rootRetainCount"><a href="#rootRetainCount" class="headerlink" title="rootRetainCount"></a>rootRetainCount</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果是taggedpointer 直接返回this</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">  	<span class="comment">// 获取isa指针</span></span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">  	<span class="comment">// 判断isa指针是否开始优化</span></span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">      	<span class="comment">// 从extra_rc读取引用计数器 再 +1</span></span><br><span class="line">        uintptr_t rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">      	<span class="comment">// 判断是否使用sidetable额外存储引用计数器</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">  	<span class="comment">// isa指针不是nonpointer, 返回sidetable_retainCount函数获取到的值</span></span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sidetable-getExtraRC-nolock"><a href="#sidetable-getExtraRC-nolock" class="headerlink" title="sidetable_getExtraRC_nolock"></a>sidetable_getExtraRC_nolock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_t </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sidetable-retainCount"><a href="#sidetable-retainCount" class="headerlink" title="sidetable_retainCount"></a>sidetable_retainCount</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数sidetable_getExtraRC_nolock和函数sidetable_retainCount，均是通过哈希查找获取他们的引用计数器表。</p>
<p>不同的是：</p>
<ul>
<li>isa 是 nonpointer会调用sidetable_getExtraRC_nolock函数，它的引用计数器会存在两部分，一部分在isa_t的extra_rc，另一部分存在于SideTable中，不进行加锁</li>
<li>isa不是nonpointer会调用sidetable_retainCount函数，他的引用计数器之存在于SideTable中，需要加锁查找</li>
</ul>
<p>SideTable查找步骤：</p>
<ul>
<li>先根据对象的内存地址，经过哈希查找后从SideTables中获取到它所在的SideTable</li>
<li>再根据当前对象的内存地址，经过哈希查找从SideTable表中的refcnts中取出它的引用计数器表</li>
</ul>
<blockquote>
<p>小结：rootRetainCount函数</p>
<ul>
<li>在arm64之前，isa 不是 nonpointer 对象的引用计数器存储在SideTable中，rootRetainCount获取到的就是1 + SideTable中存储的值</li>
<li>arm64之后，isa如果是nonpointer 对象的引用计数器先存储在extra_rc中，如果19位extra_rc不够存储，你们溢出的部分在存储在SideTable中，rootRetainCount获取到的就是1+ extra_rc的值+SideTable的值</li>
<li>初始化情况下，通过rootRetainCount获取到的1，这是rootRetainCount的功劳，alloc并没有设置对象的引用计数器</li>
</ul>
</blockquote>
<p><strong>Q：alloc方法没有设置对象的引用计数为1，而且内部也没有调用<code>retainCount</code>方法，那<code>alloc</code>创建的对象不会因引用计数器为0，而直接被<code>dealloc</code>吗？</strong></p>
<p>A：dealloc方法是在release方法内部调用的，只有你直接调用了<code>dealloc</code>，或者调用了<code>release</code>方法且在release中判断对象的引用计数器是否为0，才会调用dealloc</p>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p>之前已经说过，持有对象的方式有两种，一种是<code>alloc/new/copy/mutableCopy</code>，一种是<code>retain</code>，<code>retain</code>会将对象的引用计数+1</p>
<h4 id="objc-retain"><a href="#objc-retain" class="headerlink" title="objc_retain"></a>objc_retain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if __OBJC2__</span><br><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">id objc_retain(id obj) &#123; return [obj retain]; &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>如果是<code>__OBJC2__</code>，则调用<code>objc_retain</code>，否则调用<code>retain</code></p>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(id) retain</span><br><span class="line">&#123;</span><br><span class="line">    return _objc_rootRetain(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRetain"><a href="#objc-rootRetain" class="headerlink" title="_objc_rootRetain"></a>_objc_rootRetain</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">id</span></span><br><span class="line">_objc_rootRetain(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRetain"><a href="#objc-object-rootRetain" class="headerlink" title="objc_object::rootRetain()"></a>objc_object::rootRetain()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Base retain implementation, ignoring overrides.</span><br><span class="line">&#x2F;&#x2F; This does not check isa.fast_rr; if there is an RR override then </span><br><span class="line">&#x2F;&#x2F; it was already called and it chose to call [super retain].</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; tryRetain&#x3D;true is the -_tryRetain path.</span><br><span class="line">&#x2F;&#x2F; handleOverflow&#x3D;false is the frameless fast path.</span><br><span class="line">&#x2F;&#x2F; handleOverflow&#x3D;true is the framed slow path including overflow to side table</span><br><span class="line">&#x2F;&#x2F; The code is structured this way to prevent duplication.</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    return rootRetain(false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRetain-bool-tryRetain-bool-handleOverflow"><a href="#objc-object-rootRetain-bool-tryRetain-bool-handleOverflow" class="headerlink" title="objc_object::rootRetain(bool tryRetain, bool handleOverflow)"></a>objc_object::rootRetain(bool tryRetain, bool handleOverflow)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">id</span> </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;<span class="comment">// 是否要将引用计数器存储在SideTable中</span></span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 不去检查isa指针是否fast_rr，因为我们可能会调用重载方法</span></span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">      	<span class="comment">// #   define RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line">      	<span class="comment">// 将引用计数器+1</span></span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">				</span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">          	<span class="comment">// 如果extra_rc上溢</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 设置extra_rc为RC_HALF，同时标记has_sidetable_rc</span></span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;<span class="comment">// #   define RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 如果需要 将溢出的引用计数器存储到sidetable中</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-retain"><a href="#objc-object-sidetable-retain" class="headerlink" title="objc_object::sidetable_retain()"></a>objc_object::sidetable_retain()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage &#x3D; table.refcnts[this];&#x2F;&#x2F; 获取当前引用计数</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; &#x2F;&#x2F; 获取到了 &amp; 未溢出</span><br><span class="line">        refcntStorage +&#x3D; SIDE_TABLE_RC_ONE;&#x2F;&#x2F; 将引用计数+1</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏定义信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The order of these bits is important.</span><br><span class="line">#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)		&#x2F;&#x2F; 标记对象是否有弱引用</span><br><span class="line">#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  	&#x2F;&#x2F; 标记对象是否正在deallocating</span><br><span class="line">#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  	&#x2F;&#x2F; 对象引用计数存储的开始位，引用计数存储在2～63位</span><br><span class="line">#define SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1)) &#x2F;&#x2F; 引用计数 </span><br><span class="line"></span><br><span class="line">#define SIDE_TABLE_RC_SHIFT 2</span><br><span class="line">#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span><br></pre></td></tr></table></figure>

<p>对象引用计数表<code>refcnts</code></p>
<p><img src="/Users/mikasa/Desktop/image_mark/202011032030.png" alt="img"></p>
<h4 id="rootRetain-overflow"><a href="#rootRetain-overflow" class="headerlink" title="rootRetain_overflow"></a>rootRetain_overflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE id </span><br><span class="line">objc_object::rootRetain_overflow(bool tryRetain)</span><br><span class="line">&#123;</span><br><span class="line">    return rootRetain(tryRetain, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果extra_rc存储满了，就会调用rootRetain_overflow，该函数调用了rootRetain，但参数handleOverflow传true</p>
<h4 id="sidetable-addExtraRC-nolock"><a href="#sidetable-addExtraRC-nolock" class="headerlink" title="sidetable_addExtraRC_nolock"></a>sidetable_addExtraRC_nolock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts to the side table from the isa field.</span></span><br><span class="line"><span class="comment">// Returns true if the object is now pinned.</span></span><br><span class="line"><span class="comment">// 将一些引用计数存储在sideTable表中</span></span><br><span class="line"><span class="keyword">bool</span> </span><br><span class="line">objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    size_t oldRefcnt = refcntStorage;</span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    size_t newRefcnt = </span><br><span class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        refcntStorage =</span><br><span class="line">            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        refcntStorage = newRefcnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>extra_rc</code>存储满了，就会调用<code>sidetable_addExtraRC_nolock</code>将<code>extra_rc</code>中的<code>RC_HALF(extra_rc满</code>值的一半)个引用计数转移到<code>sidetable</code>中存储，也是调用<code>addc</code>对<code>refcnt</code>引用计数表进行计数增加操作。</p>
<blockquote>
<p>小结：<code>retain</code>方法：</p>
<ul>
<li>如果<code>isa</code>不是<code>nonpointer</code>，那么就对<code>Sidetable</code>中的引用计数+1</li>
<li>如果isa是nonpointer，就对isa中的<code>extra_rc</code>存储的引用计数进行+1，如果溢出，就将extra_rc中<code>RC_HALF</code>(<code>extra_rc</code>满值的一半)个引用计数转移到<code>sidetable</code>中存储，从<code>rootRetain</code>函数中我们可以看到，如果<code>extra_rc</code>溢出，设置它的值为RC_HALF，这时候又对<code>sidetable</code>中的<code>refcnt</code>增加引用计数。<code>extra_rc</code>是<code>19</code>位，而<code>RC_HALF</code>宏是<code>(1ULL&lt;&lt;18)</code>，实际上相等于进行了 +1 操作</li>
</ul>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>当我们在不需要持有对象的时候，需要调用<code>release</code>方法进行释放，<code>release</code>会将对象的引用计数-1</p>
<h4 id="objc-release"><a href="#objc-release" class="headerlink" title="objc_release"></a>objc_release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">void</span> objc_release(<span class="keyword">id</span> obj) &#123; [obj release]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="objc-object-release"><a href="#objc-object-release" class="headerlink" title="objc_object::release"></a>objc_object::release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::release()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        rootRelease();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(release));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果方法没有被重写，直接调用<code>rootRelease()</code>;，这是快捷方式，否则调用<code>release</code></p>
<h4 id="release-1"><a href="#release-1" class="headerlink" title="release"></a>release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)release</span><br><span class="line">&#123;</span><br><span class="line">    _objc_rootRelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootRelease"><a href="#objc-rootRelease" class="headerlink" title="_objc_rootRelease"></a>_objc_rootRelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootRelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootRelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootRelease"><a href="#objc-object-rootRelease" class="headerlink" title="objc_object::rootRelease"></a>objc_object::rootRelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base release implementation, ignoring overrides.</span></span><br><span class="line"><span class="comment">// Does not call -dealloc.</span></span><br><span class="line"><span class="comment">// Returns true if the object should now be deallocated.</span></span><br><span class="line"><span class="comment">// This does not check isa.fast_rr; if there is an RR override then </span></span><br><span class="line"><span class="comment">// it was already called and it chose to call [super release].</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// handleUnderflow=false is the frameless fast path.</span></span><br><span class="line"><span class="comment">// handleUnderflow=true is the framed slow path including side table borrow</span></span><br><span class="line"><span class="comment">// The code is structured this way to prevent duplication.</span></span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootReleaseShouldDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">      	<span class="comment">// 不是nonpointer</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">          	<span class="comment">// 如果是meta-class直接return</span></span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">          	<span class="comment">// 调用sidetable_release函数</span></span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">      	<span class="comment">// subc函数对extra_rc--</span></span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">      	<span class="comment">// 如果extra_rc已经溢出了</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don't ClearExclusive()</span></span><br><span class="line">          	<span class="comment">// 执行underflow处理下溢</span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line"> <span class="comment">// 处理下溢</span></span><br><span class="line"> underflow:</span><br><span class="line">    <span class="comment">// newisa.extra_rc-- underflowed: borrow from side table or deallocate</span></span><br><span class="line">		<span class="comment">// 出现extra_rc-- 下溢，sidetable移除或者dealloc对象</span></span><br><span class="line">    <span class="comment">// abandon newisa to undo the decrement</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line">		<span class="comment">// 如果has_sidetable_rc 为true</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">      	<span class="comment">// 没有出现下溢</span></span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">          	<span class="comment">// 执行rootRelease_underflow函数</span></span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></span><br><span class="line">				<span class="comment">// 引用计数从sidetable转移到extra_rc中存储</span></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Need to start over to avoid a race against </span></span><br><span class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 尝试从sidetable中删除一些引用计数，传入RC_HALF，borrowed为实际删除的引用计数</span></span><br><span class="line">        <span class="comment">// Try to remove some retain counts from the side table.        </span></span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line">      </span><br><span class="line">				<span class="comment">// 为了避免竞争，has_sidetable_rc必须设置，即使现在sidetable中的引用计数已经是0了</span></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Side table retain count decreased.</span></span><br><span class="line">            <span class="comment">// Try to add them to the inline count.</span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">          	<span class="comment">// 存储失败，再试一次</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 如果还是失败，就将引用计数重新保存在sidetable中</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed.</span></span><br><span class="line">                <span class="comment">// Put the retains back in the side table.</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果引用计数器为0 dealloc对象</span></span><br><span class="line">    <span class="comment">// Really deallocate.</span></span><br><span class="line">		<span class="comment">// 如果当前对象处于deallocating，保证对象只会deallocating一次</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 设置isa处于deallocating状态</span></span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">  	<span class="comment">// 如果存储失败 继续重试</span></span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line">		<span class="comment">// 如果performDealloc==true,给对象发送一条dealloc消息</span></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-release"><a href="#objc-object-sidetable-release" class="headerlink" title="objc_object::sidetable_release"></a>objc_object::sidetable_release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rdar://20206767</span></span><br><span class="line"><span class="comment">// return uintptr_t instead of bool so that the various raw-isa </span></span><br><span class="line"><span class="comment">// -release paths all return zero in eax</span></span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 设置是否需要执行do_dealloc标记，默认不需要</span></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 获取当前对象是否正在执行deallocating</span></span><br><span class="line">    auto it = table.refcnts.try_emplace(<span class="keyword">this</span>, SIDE_TABLE_DEALLOCATING);</span><br><span class="line">  	<span class="comment">// 获取refcnt</span></span><br><span class="line">    auto &amp;refcnt = it.first-&gt;second;</span><br><span class="line">    <span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">      	<span class="comment">// 如果对象处于deallocating状态</span></span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        refcnt |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;<span class="comment">// 如果引用计数器还有值，作计数器-1</span></span><br><span class="line">        refcnt -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">  	<span class="comment">// 如果对象正在作dealloc 和 performDealloc，对当前对象发送dealloc消息</span></span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>isa</code>不是<code>nonpointer</code>，那么就对<code>SideTable</code>中引用计数-1，如果引用计数为0，发送<code>dealloc</code>消息</p>
<h4 id="subc"><a href="#subc" class="headerlink" title="subc"></a>subc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE uintptr_t </span><br><span class="line">subc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)</span><br><span class="line">&#123;</span><br><span class="line">    return __builtin_subcl(lhs, rhs, carryin, carryout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>subc</code> 就是 <code>addc</code>反向操作，用来减少引用计数</p>
<h4 id="objc-object-rootRelease-underflow"><a href="#objc-object-rootRelease-underflow" class="headerlink" title="objc_object::rootRelease_underflow"></a>objc_object::rootRelease_underflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::rootRelease_underflow(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">    return rootRelease(performDealloc, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>extra_rc</code>下溢，就会调用<code>rootRelease_underflow</code>，该函数会再次调用<code>rootRelease</code>，但是参数<code>handleUnderflow</code>传true</p>
<h4 id="objc-object-sidetable-subExtraRC-nolock"><a href="#objc-object-sidetable-subExtraRC-nolock" class="headerlink" title="objc_object::sidetable_subExtraRC_nolock"></a>objc_object::sidetable_subExtraRC_nolock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts from the side table to the isa field.</span></span><br><span class="line"><span class="comment">// Returns the actual count subtracted, which may be less than the request.</span></span><br><span class="line"><span class="comment">// 尝试从sidetable中移动一些引用计数到isa中，返回真实移动的数量，有可能比请求移动的要少</span></span><br><span class="line">size_t </span><br><span class="line">objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 获取refcnts</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="comment">// 如果当前refcnts为空，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()  ||  it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Side table retain count is zero. Can't borrow.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t oldRefcnt = it-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 减少引用计数器</span></span><br><span class="line">    size_t newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class="line">    ASSERT(oldRefcnt &gt; newRefcnt);  <span class="comment">// shouldn't underflow</span></span><br><span class="line">    it-&gt;second = newRefcnt;</span><br><span class="line">    <span class="keyword">return</span> delta_rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sidetable_subExtraRC_nolock</code>函数将引用计数器转移到<code>isa</code>指针的<code>extra_rc</code>中，有可能比请求要移动的少。</p>
<h4 id="objc-object-overrelease-error"><a href="#objc-object-overrelease-error" class="headerlink" title="objc_object::overrelease_error"></a>objc_object::overrelease_error</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::overrelease_error()</span><br><span class="line">&#123;</span><br><span class="line">    _objc_inform_now_and_on_crash(<span class="string">"%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug"</span>, object_getClassName((<span class="keyword">id</span>)<span class="keyword">this</span>), <span class="keyword">this</span>);</span><br><span class="line">    objc_overrelease_during_dealloc_error();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// allow rootRelease() to tail-call this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前对象正处于dealloc状态，再次release机会执行overrelease_error，该函数用于处理过度调用release的时候使用。</p>
<blockquote>
<p><strong>小结：release方法</strong></p>
<p>如果isa不是nonpointer,那么直接对sidetable中的引用计数-1，如果引用计数==0，调用dealloc</p>
<p>如果isa是nonpointer，就将当前extra_rc存储的引用计数器-1，如果下溢，即extra_rc中的引用计数器为0了，判断has_sidetable_rc是否为true，即是否使用的sidetable进行引用计数存储，如果有的话就申请从Sidetable中申请RC_HALF个引用计数转移到extra_rc中存储，如果不足RC_HALF就有多少转移多少，然后将Sitetable中的引用计数减去RC_HALF（或者实际转移数量）将实际申请的引用计数器-1后存储在extra_rc中，如果extra_rc中引用计数器为0了而且has_sidetable_rc 为false或者sitetable中的引用计数器也为0了，你们就发送dealloc消息</p>
</blockquote>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><h4 id="objc-autorelease"><a href="#objc-autorelease" class="headerlink" title="objc_autorelease"></a>objc_autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>), flatten, noinline))</span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">id</span> objc_autorelease(<span class="keyword">id</span> obj) &#123; <span class="keyword">return</span> [obj autorelease]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果是<code>__OBJC2__</code>，则调用autorelease函数，否则调用autorelease方法</p>
<h4 id="objc-object-autorelease"><a href="#objc-object-autorelease" class="headerlink" title="objc_object::autorelease"></a>objc_object::autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) <span class="keyword">return</span> rootAutorelease();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(autorelease));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该方法没有被重写，直接调用objc_object::rootAutorelease，这是快捷方式；否则调用autorelease方法。</p>
<h4 id="objc-object-autorelease-1"><a href="#objc-object-autorelease-1" class="headerlink" title="objc_object::autorelease"></a>objc_object::autorelease</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootAutorelease2"><a href="#objc-object-rootAutorelease2" class="headerlink" title="objc_object::rootAutorelease2"></a>objc_object::rootAutorelease2</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数中调用了<code>AutoreleasePoolPage</code>中<code>autorelease</code>方法</p>
<h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><h4 id="dealloc-1"><a href="#dealloc-1" class="headerlink" title="dealloc"></a>dealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-rootDealloc"><a href="#objc-rootDealloc" class="headerlink" title="_objc_rootDealloc"></a>_objc_rootDealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-rootDealloc"><a href="#objc-object-rootDealloc" class="headerlink" title="objc_object::rootDealloc"></a>objc_object::rootDealloc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  <span class="comment">// 判断是否有弱引用</span></span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  				 <span class="comment">// 判断是否有关联对象</span></span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  		 <span class="comment">// 没有c++析构函数</span></span><br><span class="line">                 !isa.has_sidetable_rc))		 <span class="comment">// 没有使用sidetable进行引用计数存储</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">      	<span class="comment">// 直接使用free销毁对象</span></span><br><span class="line">        free(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 调用object_dispose函数</span></span><br><span class="line">        object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">object_dispose(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);   <span class="comment">// 调用 objc_destructInstance 函数</span></span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);<span class="comment">// 如果有c++析构函数，调用object_cxxDestruct</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);<span class="comment">// 如果有关联对象，移除关联对象</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-clearDeallocating"><a href="#objc-object-clearDeallocating" class="headerlink" title="objc_object::clearDeallocating"></a>objc_object::clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果 isa 不是 nonpointer</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果 isa 是 nonpointer 或者 isa.has_sidetable_rc == true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-sidetable-clearDeallocating"><a href="#objc-object-sidetable-clearDeallocating" class="headerlink" title="objc_object::sidetable_clearDeallocating"></a>objc_object::sidetable_clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_object::sidetable_clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 获取SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear any weak table items</span></span><br><span class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></span><br><span class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 获取弱引用散列表</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">      	<span class="comment">// 当前对象是否有弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 调用table.refcnts.erase从引用计数器中</span></span><br><span class="line">        table.refcnts.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-object-clearDeallocating-slow"><a href="#objc-object-clearDeallocating-slow" class="headerlink" title="objc_object::clearDeallocating_slow"></a>objc_object::clearDeallocating_slow</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Slow path of clearDeallocating() </span></span><br><span class="line"><span class="comment">// for objects with nonpointer isa</span></span><br><span class="line"><span class="comment">// that were ever weakly referenced </span></span><br><span class="line"><span class="comment">// or whose retain count ever overflowed to the side table.</span></span><br><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 是否有弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">      	<span class="comment">// 清理弱引用指针</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果有has_sidetable_rc</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">      	<span class="comment">// 调用table.refcnts.erase从引用计数器中</span></span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结：dealloc方法</strong></p>
<ul>
<li><p>判断条件（1、isa 为nonpointer; 2、没有弱引用；3、没有关联对象；4、没有c++析构函数；5、没有额外使用sidetable进行引用计数器存储）是否成立，均成立的话，使用free函数直接销毁对象，否则调用object_dispose做一些释放对象前的处理</p>
</li>
<li><p>如果有C++析构函数，调用<code>object_cxxDestruct</code>;</p>
</li>
<li><p>如果有关联对象，<code>_object_remove_assocations</code>移除关联对象</p>
</li>
<li><p>如果有弱引用，调用<code>weak_clear_no_lock</code>将指向该对象的弱引用指针置为nil</p>
</li>
<li><p>如果有使用sidetable进行引用计数器存储，调用<code>table.refcnts.erase</code>从引用计数表中擦除该对于的引用计数</p>
</li>
<li><p>调用<code>free</code>函数销毁对象</p>
<p>根据dealloc过程，<code>__weak</code>修饰符的变量在对象被<code>dealloc</code>时，会将该<code>weak</code>置为nil。可见，如果大量使用<code>weak</code>变量的话，是会消耗CPU的资源，所以建议只在需要避免循环引用的时候使用<code>weak</code>修饰符。</p>
</li>
</ul>
</blockquote>
<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><h4 id="清除weak"><a href="#清除weak" class="headerlink" title="清除weak"></a>清除weak</h4><p>以上从dealloc方法实现我们知道了对象在dealloc的时候，会调用weak_clear_no_lock函数将指向该对象的弱引用指针置为nil</p>
<h4 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the </span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 获取weak指向的地址，即当掐对象的地址</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">		<span class="comment">// 找到管理weak_entry_t的容器</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 判断弱引用是否超出定长</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">      	<span class="comment">// 获取entry中的referrers，referrers是一个数组，存储所有指向referent_id的指针</span></span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">      	<span class="comment">// 弱引用数组长度</span></span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果是使用的定长存储</span></span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历弱引用数组，将所有指向referent_id的指针置为nil</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将entry从弱引用表中移除</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结：清除weak</strong></p>
<p>当一个对象销毁是，在<code>dealloc</code>方法内部经过一系列的函数调用栈，通过二次哈希查找，第一次根据对象的地址找到它所在的<code>sidetable</code>，第二次根据对象的地址在Sidetable的<code>weak_table</code>中找打它的弱引用表。弱引用表中存储的是对象的地址（作为<code>key</code>）和weak指针地址的数组（作为<code>value</code>）的映射。<code>weak_clear_no_lock</code>函数中遍历弱引用数组，将指向该对象的地址的<code>weak</code>变量全部置为nil</p>
</blockquote>
<h3 id="添加weak"><a href="#添加weak" class="headerlink" title="添加weak"></a>添加weak</h3><p>一个被声明未__weak的指针，在经过编译之后，通过<code>objc_initWeak</code>函数初始化附有<code>weak</code>修饰符的变量，在变量作用域结束时，通过<code>objc_destroyWeak</code>函数销毁该变量。</p>
<h4 id="objc-moveWeak"><a href="#objc-moveWeak" class="headerlink" title="objc_moveWeak"></a>objc_moveWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Move a weak pointer from one location to another.</span></span><br><span class="line"><span class="comment"> * Before the move, the destination must be uninitialized.</span></span><br><span class="line"><span class="comment"> * After the move, the source is nil.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to either weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_moveWeak(<span class="keyword">id</span> *dst, <span class="keyword">id</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    objc_copyWeak(dst, src);</span><br><span class="line">    objc_destroyWeak(src);</span><br><span class="line">    *src = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-copyWeak"><a href="#objc-copyWeak" class="headerlink" title="objc_copyWeak"></a>objc_copyWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function copies a weak pointer from one location to another,</span></span><br><span class="line"><span class="comment"> * when the destination doesn't already contain a weak pointer. It</span></span><br><span class="line"><span class="comment"> * would be used for code like:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  __weak id src = ...;</span></span><br><span class="line"><span class="comment"> *  __weak id dst = src;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the destination variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param dst The destination variable.</span></span><br><span class="line"><span class="comment"> * @param src The source variable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_copyWeak(<span class="keyword">id</span> *dst, <span class="keyword">id</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = objc_loadWeakRetained(src);</span><br><span class="line">    objc_initWeak(dst, obj);</span><br><span class="line">    objc_release(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Initialize a fresh weak pointer to some object location. </span></span><br><span class="line"><span class="comment"> * It would be used for code like: </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (The nil case) </span></span><br><span class="line"><span class="comment"> * __weak id weakPtr;</span></span><br><span class="line"><span class="comment"> * (The non-nil case) </span></span><br><span class="line"><span class="comment"> * NSObject *o = ...;</span></span><br><span class="line"><span class="comment"> * __weak id weakPtr = o;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param location Address of __weak ptr. </span></span><br><span class="line"><span class="comment"> * @param newObj Object ptr. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)<span class="comment">// location为__weak指针地址，newObj为对象地址</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果对象为nil，那就将__weak指针置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update a weak variable.</span></span><br><span class="line"><span class="comment">// If HaveOld is true, the variable has an existing value </span></span><br><span class="line"><span class="comment">//   that needs to be cleaned up. This value might be nil.</span></span><br><span class="line"><span class="comment">// If HaveNew is true, there is a new value that needs to be </span></span><br><span class="line"><span class="comment">//   assigned into the variable. This value might be nil.</span></span><br><span class="line"><span class="comment">// If CrashIfDeallocating is true, the process is halted if newObj is </span></span><br><span class="line"><span class="comment">//   deallocating or newObj's class does not support weak references. </span></span><br><span class="line"><span class="comment">//   If CrashIfDeallocating is false, nil is stored instead.</span></span><br><span class="line"><span class="comment">// 更新weak变量</span></span><br><span class="line"><span class="comment">// 如果 HaveOld == true，表示变量有旧值，这个值可能为nil</span></span><br><span class="line"><span class="comment">// 如果 HaveNew == true，表示一个新值需要赋值给变量，这个新值可能是nil</span></span><br><span class="line"><span class="comment">// 如果 CrashIfDeallocating == true，表示对象正在销毁 或者 对象不支持弱引用，则停止更新</span></span><br><span class="line"><span class="comment">// 如果 CrashIfDeallocating == false，则存储nil</span></span><br><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) ASSERT(newObj == <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    SideTable *oldTable;<span class="comment">// 旧表，用来存放已有的weak变量</span></span><br><span class="line">    SideTable *newTable;<span class="comment">// 新表，用来存放新的weak变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// 存在旧值，获取旧值对象 和旧值所在的弱引用表</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在新值，创建新表</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 对旧值 新值 分别加锁</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">		<span class="comment">// 判断旧值 和 location指向的值是否相等，即是否同一对象，如果不是就重新获取旧值相关联的对象和表</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="comment">// 存在新值</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">      	<span class="comment">// 判断新值所属的类是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">          	<span class="comment">// 未初始化，先进行初始化，防止 +initialize 内部调用 storeWeak 产生死锁</span></span><br><span class="line">            class_initialize(cls, (<span class="keyword">id</span>)newObj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this class is finished with +initialize then we're good.</span></span><br><span class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">            <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">            <span class="comment">// 标记类已经进行初始化检查</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="comment">// 如果存在旧值，调用weak_unregister_no_lock进行清理</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="comment">// 存在新值，调用weak_register_no_lock方法，将所有weak指针重新指向新的对象</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line">				<span class="comment">// 如果存储成功</span></span><br><span class="line">      	<span class="comment">// 如果对象是 taggedPointer，不做操作</span></span><br><span class="line">      	<span class="comment">// 如果isa 不是 nonpointer,设置Sidetable中弱引用标志位</span></span><br><span class="line">      	<span class="comment">// 如果isa 是 nonpointer，设置isa 的 weakly_referenced弱引用标志位</span></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">      	<span class="comment">// 将location指向新的对象</span></span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：<code>storeWeak</code>函数执行过程：</strong></p>
<ul>
<li>分别获取新旧值相关联的弱引用表；</li>
<li>如果有旧值，就调用<code>weak_unregister_no_lock</code>进行清理</li>
<li>如果有新值，就调用<code>weak_register_no_lock</code>函数分配新值，将所有<code>weak</code>指针重新指向新的对象；</li>
<li>判断<code>isa</code>是否为<code>nonpointer</code> 来设置弱引用标志位，如果不是<code>nonponinter</code>，设置<code>SideTable</code>中的弱引用标志位，否则设置<code>isa</code>的<code>weakly_referenced</code>弱引用标志位。</li>
</ul>
</blockquote>
<h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registers a new (object, weak pointer) pair. Creates a new weak</span></span><br><span class="line"><span class="comment"> * object entry if it does not exist.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object pointed to by the weak reference.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;<span class="comment">// 对象</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;<span class="comment">// 弱引用指针</span></span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 判断对象是否为nil &amp;&amp; 是否是taggedPointer指针，如果是 直接返回当前对象</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">  	<span class="comment">// 确保对象是可用的</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">  	<span class="comment">// 判断当前对象是否正在deallocating</span></span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 当前对象是否支持弱引用</span></span><br><span class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </span><br><span class="line">                                           <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// allowsWeakReference 函数获取的其实就是当前对象! [self _isDeallocating]; </span></span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, <span class="keyword">@selector</span>(allowsWeakReference));</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 正在执行deallocating 不可使用weak指针</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">  	<span class="comment">// 获取弱引用entry</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">  	<span class="comment">// 如果当前entry存在，指向将weak指针追加进去</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果当前entry不存在，先创建一个新的entry，将新的entry存储到weak_table中</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：weak_register_no_lock用于保存弱引用信息，具体实现如下：</strong></p>
<ul>
<li>判断对象是否正在释放，是否支持弱引用，如果实例对象<code>allowsWeakReference</code>返回NO，表明对象正在执行<code>deallocating</code> 不可使用weak指针</li>
<li>查询<code>weak_table</code>表，判断引用表中是否已经保存与对象相关联的弱引用信息；</li>
<li>如果已经有相关弱引用信息，则调用<code>append_referrer</code>函数将弱引用信息添加进现有的entry容器中；如果没有相关联信息，则创建一个<code>entry</code>，判断<code>weak_table</code>是否需要扩容（大小超过<code>3/4，进行2倍扩</code>容），将<code>entry</code>插入到弱引用表中。</li>
</ul>
</blockquote>
<h4 id="weak-unregister-no-lock-1"><a href="#weak-unregister-no-lock-1" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Unregister an already-registered weak reference.</span></span><br><span class="line"><span class="comment"> * This is used when referrer's storage is about to go away, but referent</span></span><br><span class="line"><span class="comment"> * isn't dead yet. (Otherwise, zeroing referrer later would be a</span></span><br><span class="line"><span class="comment"> * bad memory access.)</span></span><br><span class="line"><span class="comment"> * Does nothing if referent/referrer is not a currently active weak reference.</span></span><br><span class="line"><span class="comment"> * Does not zero referrer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * FIXME currently requires old referent value to be passed in (lame)</span></span><br><span class="line"><span class="comment"> * FIXME unregistration should be automatic if referrer is collected</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                        <span class="keyword">id</span> *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 是否存在与当前对象相关联的弱引用表</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">      	<span class="comment">// 从entry中移除弱引用指针referrer</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 判断是否超出定长（4），out_of_line_ness为2标记还是通过inline_referrers存储</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 判断inline_referrers中是否存在weak信息</span></span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：<code>weak_unregister_no_lock</code>函数用来移除弱引用信息，具体实现如下：</p>
<ul>
<li>查询<code>weak_table</code>表，获取与当前对象相关联的弱引用信息；</li>
<li>如果有，调用<code>remove_referrer</code>移除相关弱引用信息；接着判断数组是否为空，如果为空，调用<code>weak_entry_remove</code>移除<code>entry</code></li>
</ul>
</blockquote>
<h4 id="objc-destroyWeak"><a href="#objc-destroyWeak" class="headerlink" title="objc_destroyWeak"></a>objc_destroyWeak</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Destroys the relationship between a weak pointer</span></span><br><span class="line"><span class="comment"> * and the object it is referencing in the internal weak</span></span><br><span class="line"><span class="comment"> * table. If the weak pointer is not referencing anything, </span></span><br><span class="line"><span class="comment"> * there is no need to edit the weak table. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param location The weak pointer address. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_destroyWeak(<span class="keyword">id</span> *location)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="keyword">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_initWeak</code> 和 objc_destroyWeak 函数中都调用了storeWeak，但是传入的参数不同</p>
<ul>
<li><code>objc_initWeak</code>将对象地址传入，且DontHaveOld，DoHaveNew，DoCrashIfDeallocating</li>
<li>objc_destroyWeak将nil传入，且DontHaveOld，DoHaveNew，DoCrashIfDeallocating</li>
</ul>
<p>storeWeak函数将参数二的赋值的对象地址作为key，将参数一的附有__weak修饰符的变量的地址注册到weak表中。如果参数二为nil，则将变量的地址从weak表中删除。</p>
<blockquote>
<p><strong>小结：添加`weak</strong>`</p>
<p>一个被标记为<code>weak</code>的指针，在经过编译之后会调用<code>objc_copyWeak</code>函数，在<code>objc_copyWeak</code>函数中调用<code>objc_initWeak</code>函数，<code>objc_initWeak</code>函数中初始化weak变量后调用<code>storeWeak</code>函数。添加weak的过程如下：</p>
<ul>
<li>经过一系列的调用栈，最终在<code>weak_register_no_lock</code>函数中，进行弱引用变量的添加，具体添加的位置是通过哈希算法来查找的，如果对应位置已经存在当前对象的弱引用表（数组），直接将弱引用变量添加进入，如果不存在弱引用表，先创建弱引用表，再判断是否需要对<code>weak_table</code>进行扩容，然后再将弱引用变量添加进去。</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">内存管理方法</th>
<th align="left">具体实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">alloc</td>
<td align="left">经过一系列的函数调用栈，最终通过调用 C 函数<code>calloc</code>来申请内存空间，并初始化对象的<code>isa</code>，但并没有设置对象的引用计数值为 1。</td>
</tr>
<tr>
<td align="left">init</td>
<td align="left">基类的<code>init</code>方法啥都没干，只是将<code>alloc</code>创建的对象返回。我们可以重写<code>init</code>方法来对<code>alloc</code>创建的实例做一些初始化操作。</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left"><code>new</code>方法很简单，只是嵌套了<code>alloc</code>和<code>init</code>。</td>
</tr>
<tr>
<td align="left">copy、mutableCopy</td>
<td align="left">调用了<code>copyWithZone</code>和<code>mutableCopyWithZone</code>方法。</td>
</tr>
<tr>
<td align="left">retainCount</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，引用计数值 = <code>SideTable</code>中的引用计数表中存储的值 + 1； ② 如果<code>isa</code>是<code>nonpointer</code>，引用计数值 = <code>isa</code>中的<code>extra_rc</code>存储的值 + 1 +<code>SideTable</code>中的引用计数表中存储的值。</td>
</tr>
<tr>
<td align="left">retain</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，就对<code>Sidetable</code>中的引用计数进行 +1； ② 如果<code>isa</code>是<code>nonpointer</code>，就将<code>isa</code>中的<code>extra_rc</code>存储的引用计数进行 +1，如果溢出，就将<code>extra_rc</code>中<code>RC_HALF</code>（<code>extra_rc</code>满值的一半）个引用计数转移到<code>sidetable</code>中存储。</td>
</tr>
<tr>
<td align="left">release</td>
<td align="left">① 如果<code>isa</code>不是<code>nonpointer</code>，就对<code>Sidetable</code>中的引用计数进行 -1，如果引用计数 =0，就<code>dealloc</code>对象； ② 如果<code>isa</code>是<code>nonpointer</code>，就将<code>isa</code>中的<code>extra_rc</code>存储的引用计数进行 -1。如果下溢，即<code>extra_rc</code>中的引用计数已经为 0，判断<code>has_sidetable_rc</code>是否为<code>true</code>即是否有使用<code>Sidetable</code>存储。如果有的话就申请从<code>Sidetable</code>中申请<code>RC_HALF</code>个引用计数转移到<code>extra_rc</code>中存储，如果不足<code>RC_HALF</code>就有多少申请多少，然后将<code>Sidetable</code>中的引用计数值减去<code>RC_HALF</code>（或是小于<code>RC_HALF</code>的实际值），将实际申请到的引用计数值 -1 后存储到<code>extra_rc</code>中。如果<code>extra_rc</code>中引用计数为 0 且<code>has_sidetable_rc</code>为<code>false</code>或者<code>Sidetable</code>中的引用计数也为 0 了，那就<code>dealloc</code>对象。</td>
</tr>
<tr>
<td align="left">dealloc</td>
<td align="left">① 判断销毁对象前有没有需要处理的东西（如弱引用、关联对象、<code>C++</code>的析构函数、<code>SideTabel</code>的引用计数表等等）； ② 如果没有就直接调用<code>free</code>函数销毁对象； ③ 如果有就先调用<code>object_dispose</code>做一些释放对象前的处理（置弱引用指针置为<code>nil</code>、移除关联对象、<code>object_cxxDestruct</code>、在<code>SideTabel</code>的引用计数表中擦出引用计数等等），再用<code>free</code>函数销毁对象。</td>
</tr>
<tr>
<td align="left">清除<code>weak</code>，<code>weak</code>指针置为<code>nil</code>的过程</td>
<td align="left">当一个对象被销毁时，在<code>dealloc</code>方法内部经过一系列的函数调用栈，通过两次哈希查找，第一次根据对象的地址找到它所在的<code>Sidetable</code>，第二次根据对象的地址在<code>Sidetable</code>的<code>weak_table</code>中找到它的弱引用表。遍历弱引用数组，将指向对象的地址的<code>weak</code>变量全都置为<code>nil</code>。</td>
</tr>
<tr>
<td align="left">添加<code>weak</code></td>
<td align="left">经过一系列的函数调用栈，最终在<code>weak_register_no_lock()</code>函数当中，进行弱引用变量的添加，具体添加的位置是通过哈希算法来查找的。如果对应位置已经存在当前对象的弱引用表（数组），那就把弱引用变量添加进去；如果不存在的话，就创建一个弱引用表，然后将弱引用变量添加进去。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-ISA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-ISA/" class="post-title-link" itemprop="url">内存管理-ISA & Weak底层</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-28 17:33:31" itemprop="dateCreated datePublished" datetime="2020-10-28T17:33:31+08:00">2020-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-29 23:01:09" itemprop="dateModified" datetime="2020-10-29T23:01:09+08:00">2020-10-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><h4 id="ISA结构体定义"><a href="#ISA结构体定义" class="headerlink" title="ISA结构体定义"></a>ISA结构体定义</h4><p>oc对象的本质其实是就是结构体，类也是对象，每个对象都有isa指针，对象的isa指针指向该对象所属的类，类对象的<code>isa</code>指针指向的是当前类的元类对象。</p>
<p>ARM64位架构之前，<code>isa</code>只是一个指针，<code>arm64</code>之后，<code>isa</code>是一个联合体/共用体(union)，这是苹果对于isa的优化，结合位域的概念以及位运算的方式来存储更多类相关的信息，简单来说isa指针通过一个叫ISA_MASK的值进行二进制&amp;运算，得到真实的<code>class/meta-class</code>对象的地址。</p>
<p><code>arm64</code>架构之前，isa指针直接指向当前类<code>objc_class</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>arm64</code>之后，<code>isa</code>不再是一个普通的<code>isa</code>指针，也是<code>isa_t</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步根据<code>isa_t</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">      <span class="comment">// 截取arm64架构下定义</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      uintptr_t nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      uintptr_t magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过源码发现isa_t是一个union联合体，union看上去跟struct差不多，只是命名不同，但是union的定义是它使得几个不同类型的变量共占一段内存（互相覆盖），每次只有一个能使用，而struct的成员则具备独立的内存空间，在使用时互不影响。</p>
<p>举个例子，假设A类里面声明一个union</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> x &#123;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">bool</span> isRich;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上定义后，系统会为union x分配8个字节的内存空间，因为指针占8位，int占4位，bool占1位，该union的内存大小由其内部占最大自己的成员类型决定，因为后续操作是需要互相覆盖的。</p>
<p>在看Struct的定义，假设B类中声明了一个Struct</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">bool</span> isRich;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上定义后，系统会为这个struct x分配16个字节的内存空间，各成员所占内存跟上述大小一致，各自有独立对应的内存空间，不过这里由于需要内存对齐，导致结构体的内存大小不再是8bit</p>
<p>接着回到上述结构体的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个成员后面都会有一个:x ,其实这个:x就是位域的应用，简单来说，有的信息他所需要的内存不足以填满一个字节的空间，比如开关状态这样的信息，其实只需要一个二进制空间即可存储，这样就达到了节约内存的目的。（<strong>位域概念是C语言里面的一种数据结构，将一个字节中的二进位划分为多个不同的区域，每个区域具备几个位数，每个域给定一个域名，允许程序中按域名进行操作，这样可以把几个不同的对象用一个字节的二进制位域来表示</strong>）</p>
<ul>
<li>nonpointer——0:代表普通指针，存储class/meta-class对象的内存地址；1:代表优化过，使用位域存储更多信息</li>
<li>has_assoc—— 是否设置过关联对象，如果没有，释放时会更快</li>
<li>has_cxx_dtor——是否有c++的析构函数，如果没有，释放时会更快</li>
<li>shiftcls——这个部分存储的是真正的class/meta-class对象的内存地址，因此要通过isa &amp; ISA_MASK才能取出这里的33的值，得到对象真正的地址</li>
<li>magic——用于在调试的时候分辨对象是否完成了初始化</li>
<li>weakly_referenced——是否倍弱引用的指针指向过，如果没有，释放时会更快</li>
<li>deallocating——是否对象正在被释放</li>
<li>has_sidetable_rc——引用计数器是否过大无法存储在isa中，如果是，这里就是1，引用计数就会被存储在一个叫SideTable的散列表中</li>
<li>extra_rc——里面存储的值是引用计数的值（retainCount-1），如果这19位不够存储，has_sidetable_rc就会变为1</li>
</ul>
<p><img src="/Users/mikasa/Desktop/image_mark/23_8.png" alt="23_8"></p>
<h4 id="ISA初始化"><a href="#ISA初始化" class="headerlink" title="ISA初始化"></a>ISA初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initClassIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DisableNonpointerIsa  ||  cls-&gt;instancesRequireRawIsa()) &#123;</span><br><span class="line">        initIsa(cls, <span class="literal">false</span><span class="comment">/*not nonpointer*/</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initIsa(cls, <span class="literal">true</span><span class="comment">/*nonpointer*/</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::initProtocolIsa(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> initClassIsa(cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor == cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到不管是类对象、实例对象、协议对象还是其他对象，初始化isa结构体最终都调用了initIsa函数，只是所传参数不同而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> nonpointer, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否进行isa优化</span></span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个新的isa_t结构体</span></span><br><span class="line">        <span class="keyword">isa_t</span> newisa(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ISA_MAGIC_VALUE的值是，0x000001a000000001ULL，转化为二进制是64位，可观察到实际只赋值了nonpointer 和 magic</span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        <span class="comment">// 将当前对象的类指针赋值到shiftcls</span></span><br><span class="line">        <span class="comment">// 类的指针式按照（8bits）对齐的，其指针后三位都是没有意义的，因此可以右移3位</span></span><br><span class="line">        newisa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Obj-C中，类的指针是按照字节（8bits）对齐的，也就是说类指针地址转化为十进制后，都是8的倍数，也就是说类指针地址转化为二进制后，后三位都是0，既然0是没有意义的，你们在存储的时候就可以忽略，用节省下来的空间存储一下其他信息。</p>
<p>因此在赋值shiftcls的时候右移三位是安全的，不会丢失任何指针信息。</p>
<h3 id="SideTables"><a href="#SideTables" class="headerlink" title="SideTables"></a>SideTables</h3><p><code>SideTables</code>是一类型是<code>StripedMap&lt;SideTable&gt;</code>的静态全局哈希表，iPhone下它是一个8个元素长度的<code>hash</code>数组，在Mac下它是一个64个元素长度的hash数组，里面存储了<code>SideTable</code>，<code>SideTable</code>的hash键值就是一个对象obj的address。</p>
<p>因此可以说，一个<code>obj</code>对呀一个<code>SideTable</code>，但是一个SideTable会对应多个<code>objc</code>。因为<code>SideTable</code>的数量只有8个，所以会有很多objc公用同一个<code>SideTable</code>的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alignas</span>(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> <span class="keyword">uint8_t</span> </span><br><span class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SideTableInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (SideTableBuf) StripedMap&lt;SideTable&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看下StripedMap的结构，StripedMap是一个以void *为hash key，T为value的hash表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;<span class="comment">//T value 64字节对齐</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT <span class="built_in">array</span>[StripeCount];<span class="comment">// 所有PaddedT 类型数据被存储在array中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法以void *为key 来获取对应的T</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;<span class="comment">// 防止index越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hash算法计算方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;<span class="comment">// 防止index越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将地址指针右移4位 异或 指针右移9位计算后，进行取余。</p>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><h4 id="SideTable定义"><a href="#SideTable定义" class="headerlink" title="SideTable定义"></a>SideTable定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;<span class="comment">// 自旋锁</span></span><br><span class="line">    RefcountMap refcnts;<span class="comment">// 引用计数器表（散列表）</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table; <span class="comment">// 弱引用表（散列表）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>spinlock_t：自旋锁，用于上锁/解锁<code>SideTable</code>，保证操作<code>SideTable</code>时的线程安全</li>
<li>RefcountMap:以<code>DisguisedPtr&lt;objc_object&gt;</code>为key的hash表，用来存储OC对象的引用计数器（仅在未开启isa指针优化，或isa引用计数器溢出的情况下才会用到）</li>
<li>weak_table_t：存储对象弱引用指针的hash表</li>
</ul>
<p><code>SideTable</code>表存储在<code>SideTables()</code>中，<code>SideTables()</code>本质也是散列表，可以通过对象指针来获取他对应的（引用计数器和弱引用表）在哪一个<code>SideTable</code>中。在非嵌入式系统中，<code>SideTables()</code>有64的<code>SideTable</code></p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><strong>Q：如何找到对象所在的SideTable？</strong></p>
<p>A：通过<code>indexForPointer</code>函数计算hash算法，找到对象应用的<code>SideTable</code></p>
<p><strong>Q：为什么不是用一个SideTable，而是用SideTables去管理多个SideTable？</strong></p>
<p>A：SideTable中有一个自旋锁，如果把所有类都放在同一个<code>SideTable</code>，有任何一个类有改动都会对当前<code>SideTable</code>进行加锁操作，其他操作处于等待状态，这样会导致操作效率和查询效率很低。而多个<code>SideTable</code>的话，操作的都是单个SideTable，并不会影响其他<code>SideTable</code>，这就是分离锁。</p>
<p>​    全局的引用计数器之所以不存在同一个表中，是为了避免资源竞争，解决效率问题。引用计数表中引入了分离锁的概念，将一个表拆分位多个部分，对他们分别加锁，可以实现并发操作，提升执行效率。</p>
<p><strong>Q：如何找到对象的引用计数器？</strong></p>
<p>A：先找到对象所在<code>SideTable</code>，然后根据<code>refcnts</code>查找获取引用计数器值，<code>refcnts</code>也是一个散列表，以当前对象为key，value为引用计数器的值，如果是<code>nonpointer</code>为1的<code>isa</code>指针，还需加上<code>extra_rc</code>的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">inline uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    if (bits.nonpointer) &#123;</span><br><span class="line">        uintptr_t rc &#x3D; 1 + bits.extra_rc;</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc +&#x3D; sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 获取SideTable表中refcnts的值</span><br><span class="line">size_t </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h3><p><code>weak_table_t</code>是全局保存的弱引用的hash表，以<code>object</code> ids为keys，以<code>weak_entry_t</code>为values</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The global weak references table. Stores object ids as keys,</span><br><span class="line"> * and weak_entry_t structs as their values.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct weak_table_t &#123;</span><br><span class="line">  weak_entry_t *weak_entries;&#x2F;&#x2F; 存储weak_entry_t的哈希数组</span><br><span class="line">  size_t    num_entries;&#x2F;&#x2F; 当前weak_entries保存的weak_entry_t的数量，哈希数组内保存的元素个数</span><br><span class="line">  uintptr_t mask;&#x2F;&#x2F; 哈希数组的总长度-1，会参与hash函数计算</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 记录所有项的最大偏移量，即发生hash冲突的最大次数</span><br><span class="line">  &#x2F;&#x2F; 用户判断是否出现了逻辑错误，hash表中的冲突次数绝对不会超过这个值</span><br><span class="line">  &#x2F;&#x2F; 因为会有hash碰撞的情况，而weak_entry_t采用了开放地址寻址法来解决</span><br><span class="line">  &#x2F;&#x2F; 所以某个weak_entry_t时机存储的位置不一定是hash函数计算出来的结果</span><br><span class="line">  uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h4><p><code>weak_entry_t</code>的功能是保存一个对象，然后保存一组对象的弱引用</p>
<p><code>weak_entry_t</code>的哈希存储的数据是<code>weak_referrer_t</code>，实质上是弱引用变量的地址，即objc_object **，通过操作指针的指针，就可以使得弱引用变量在对象析构后指向nil。这里必须保存弱引用变量的地址，才能把它的指向置为nil</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">  <span class="comment">// referent中存放的化身为整数的objec_object的实例的地址，下面保存的弱引用变量都指向这个对象</span></span><br><span class="line">  DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当指向referent的弱引用个数小于等于4时使用inline_referrers数组保存这些弱引用变量的地址</span></span><br><span class="line">  <span class="comment">// 大于4以后用referent这个哈希数组保存</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 公用32个字节内存空间的联合体</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span> *referrers;<span class="comment">//保存weak_referrer_t的哈希数组</span></span><br><span class="line">        <span class="comment">// out_of_line_ness 和 num_refs 构成位域存储，共占64位</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;<span class="comment">// 2，标记当前使用哈希数组还是inline_referrers保存weak_referrer_t</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;<span class="comment">// 62，当前referrers内保存的weak_referrer_t数量</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        mask;<span class="comment">// referrers哈希数组总长度-1，会参与哈希函数计算</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可能会发生hash冲突的最大次数，用于判断是否出现了逻辑错误，（hash表中的冲突次数绝对不会超过该值）</span></span><br><span class="line">        <span class="comment">// 该值在新建weak_entry_t和插入新的weak_referrer_t时会被更新，它一直记录的都是最大偏移量</span></span><br><span class="line">        <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">        <span class="comment">// out_of_line_ness和 inline_referrers[1]的低两位的内存空间重合</span></span><br><span class="line">        <span class="comment">// 长度为4的weak_referrer_t数组</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回true表示inline_referrers保存，返回false表示referrers保存weak_referrer_t</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重载操作符，直接使用memcpy拷贝other到this</span></span><br><span class="line">  <span class="keyword">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// newReferent是原始对象的指针，newReferrer是指向newReferent弱引用变量的地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化列表</span></span><br><span class="line">  <span class="keyword">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">      : referent(newReferent)</span><br><span class="line">  &#123;</span><br><span class="line">      inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">      <span class="comment">// 将inline_referrers数组中的剩余3位都置为nil</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">          inline_referrers[i] = nil;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之所以使用定长/哈希数组的切换，应该是考了到实例对象的弱引用变量个数一般比较少，这是使用定长数组不需要在动态申请内存空间（union中两个结构体公用32个字节内存），而是使用weak_entry_t初始化时分配的一块连续内存空间，这回得到允许效率上的提升。</p>
<h4 id="weak-referrer-t"><a href="#weak-referrer-t" class="headerlink" title="weak_referrer_t"></a>weak_referrer_t</h4><p>用于伪装__weak变量的地址，即用于伪装objc_object *的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The address of a __weak variable.</span></span><br><span class="line"><span class="comment">// These pointers are stored disguised so memory analysis tools</span></span><br><span class="line"><span class="comment">// don't see lots of interior pointers from the weak table into objects.</span></span><br><span class="line"><span class="comment">// __weak变量的地址（objc_object **），这些指针是伪装的，因此内存分析工具不会看到从weak table到object的大量内部指针</span></span><br><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; <span class="keyword">weak_referrer_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="object-setIvar"><a href="#object-setIvar" class="headerlink" title="_object_setIvar"></a>_object_setIvar</h3><p>设置对象的成员变量，根据成员变量获取当前成员变量类型是strong、weak以及_unsafe_unretained，调用对象存储函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_setIvar(id obj, Ivar ivar, id value, <span class="keyword">bool</span> assumeStrong)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj  ||  !ivar  ||  obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> offset;</span><br><span class="line">    <span class="keyword">objc_ivar_memory_management_t</span> memoryManagement;</span><br><span class="line">    _class_lookUpIvar(obj-&gt;ISA(), ivar, offset, memoryManagement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryManagement == objc_ivar_memoryUnknown) &#123;</span><br><span class="line">        <span class="keyword">if</span> (assumeStrong) memoryManagement = objc_ivar_memoryStrong;</span><br><span class="line">        <span class="keyword">else</span> memoryManagement = objc_ivar_memoryUnretained;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id *location = (id *)((<span class="keyword">char</span> *)obj + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (memoryManagement) &#123;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryWeak:       objc_storeWeak(location, value); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryStrong:     objc_storeStrong(location, value); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryUnretained: *location = value; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> objc_ivar_memoryUnknown:    _objc_fatal(<span class="string">"impossible"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-storeWeak"><a href="#objc-storeWeak" class="headerlink" title="objc_storeWeak"></a>objc_storeWeak</h4><blockquote>
<p>更新指针指向，创建对应的弱引用表</p>
<p>如果存在旧表，也存在成员值，需要进行清理操作，因为这个值可能是nil</p>
<p>如果有新表，赋值这个新值到变量中，这个值可能是nil</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Update a weak variable.</span><br><span class="line">&#x2F;&#x2F; If HaveOld is true, the variable has an existing value </span><br><span class="line">&#x2F;&#x2F;   that needs to be cleaned up. This value might be nil.</span><br><span class="line">&#x2F;&#x2F; If HaveNew is true, there is a new value that needs to be </span><br><span class="line">&#x2F;&#x2F;   assigned into the variable. This value might be nil.</span><br><span class="line">&#x2F;&#x2F; If CrashIfDeallocating is true, the process is halted if newObj is </span><br><span class="line">&#x2F;&#x2F;   deallocating or newObj&#39;s class does not support weak references. </span><br><span class="line">&#x2F;&#x2F;   If CrashIfDeallocating is false, nil is stored instead.</span><br><span class="line">enum CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating &#x3D; false, DoCrashIfDeallocating &#x3D; true</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj) &#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前置条件判断</li>
<li>声明新旧两个SideTable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (haveOld) &#123;</span><br><span class="line">    oldObj &#x3D; *location;</span><br><span class="line">    oldTable &#x3D; &amp;SideTables()[oldObj];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    oldTable &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line">if (haveNew) &#123;</span><br><span class="line">    newTable &#x3D; &amp;SideTables()[newObj];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    newTable &#x3D; nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据新值和旧值分别获区全局的SideTables表中的SideTable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls &#x3D; newObj-&gt;getIsa();</span><br><span class="line">        if (cls !&#x3D; previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            class_initialize(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If this class is finished with +initialize then we&#39;re good.</span><br><span class="line">            &#x2F;&#x2F; If this class is still running +initialize on this thread </span><br><span class="line">            &#x2F;&#x2F; (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">            &#x2F;&#x2F; then we may proceed but it will appear initializing and </span><br><span class="line">            &#x2F;&#x2F; not yet initialized to the check above.</span><br><span class="line">            &#x2F;&#x2F; Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">            previouslyInitializedClass &#x3D; cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>确保对象在弱引用之前，以及成功初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Clean up old value, if any.</span><br><span class="line">if (haveOld) &#123;</span><br><span class="line">  weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空旧值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign new value, if any.</span></span><br><span class="line"><span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">    newObj = (objc_object *)</span><br><span class="line">        weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                              crashIfDeallocating);</span><br><span class="line">    <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">    <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">        newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">    *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储新值<code>weak_register_no_lock</code>函数执行真正的存储逻辑</p>
<h4 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, id referent_id, </span><br><span class="line">                      id *referrer_id, bool crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F; referent弱引用对象，referrer weak指针的地址</span><br><span class="line">    objc_object *referent &#x3D; (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer &#x3D; (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; now remember it and where it is being stored</span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    if ((entry &#x3D; weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Do not set *referrer. objc_storeWeak() requires that the </span><br><span class="line">    &#x2F;&#x2F; value not change.</span><br><span class="line"></span><br><span class="line">    return referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明一个<code>weak_entry_t</code>类型实体，这里保存了呗弱引用对象的指针和weak指针的地址</li>
<li>根据弱引用对象的指针从全局<code>weak_table</code>中查找<code>entry</code>，如果找到则执行插入操作。</li>
<li>如果<code>weak_entry_for_referent</code>返回的entry存储<code>weak</code>指针的是<code>inline_referrers</code>类型，今天通过直接操作数组中的元素来达到修改数值的目的</li>
<li>如果没有查找到<code>entry</code>，则新建一个<code>weak_entry_t</code>结构体数组，直接将这个<code>weak_entry_t</code>插入到<code>weak_table</code>表中</li>
</ul>
<blockquote>
<p><code>weak_table_t</code>调用<code>weak_grow_maybe</code> 和 <code>weak_compact_maybe</code>这两个函数，用来当<code>weak_table_t</code>哈希数组过满或者为空的情况下及时调整其大小，优化内存的使用效率，并提高查找效率。这两个函数都是通过<code>weak_resize</code>函数来调整weak_table_t数组的大小</p>
</blockquote>
<h4 id="weak-grow-maybe"><a href="#weak-grow-maybe" class="headerlink" title="weak_grow_maybe"></a>weak_grow_maybe</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Grow the given zone&#39;s table of weak references if it is full.</span><br><span class="line">&#x2F;&#x2F; 如果给定区域的弱引用表已满，则对齐进行扩展</span><br><span class="line">static void weak_grow_maybe(weak_table_t *weak_table)</span><br><span class="line">&#123;</span><br><span class="line">    size_t old_size &#x3D; TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Grow if at least 3&#x2F;4 full.</span><br><span class="line">    &#x2F;&#x2F; 如果目前哈希数组中存储的weak_entry_t数量超过了总长度的3 &#x2F; 4，则进行扩容</span><br><span class="line">    if (weak_table-&gt;num_entries &gt;&#x3D; old_size * 3 &#x2F; 4) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果weak_table是新建的，则出事其哈希数组长度为64，如果是非空，则扩容为之前长度的两倍</span><br><span class="line">        weak_resize(weak_table, old_size ? old_size*2 : 64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数用于扩充<code>weak_table_t</code>的<code>weak_entry_t *weak_entries</code>长度，扩充条件是<code>num_entries</code>长度超过了mask+1的3 / 4。初始化<code>weak_table</code>长度是64，每次扩充的长度则是mask+1的两倍，扩容完毕后会把原哈希数组中的weak_entry_t重新哈希化插入到新空间内，并更新weak_tabl_t各成员变量。占据的内存空间的总容量则是<code>(mask+1) * sizeof(weak_entry_t)</code>字节。综上mask+1总是2的N次方（2^6=64 即 N&gt;=6）</p>
<h4 id="weak-compact-maybe"><a href="#weak-compact-maybe" class="headerlink" title="weak_compact_maybe"></a>weak_compact_maybe</h4><p>该函数会在weak_entry_remove函数中调用，旨在<code>weak_entry_t</code>从<code>weak_table_t</code>的数组中移除后，缩小<code>weak_entry_t *weak_entries</code>的空间</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shrink the table if it is mostly empty.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_compact_maybe(weak_table_t *weak_table)</span><br><span class="line">&#123;</span><br><span class="line">    size_t old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shrink if larger than 1024 buckets and at most 1/16 full.</span></span><br><span class="line">    <span class="comment">// old_size 超过了1024 并且低于1/16的空间占用率，则进行缩小 </span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= <span class="number">1024</span>  &amp;&amp; old_size / <span class="number">16</span> &gt;= weak_table-&gt;num_entries) &#123;</span><br><span class="line">        <span class="comment">// 缩小容量为1/8</span></span><br><span class="line">        weak_resize(weak_table, old_size / <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// leaves new table no more than 1/2 full</span></span><br><span class="line">        <span class="comment">// 缩小容量1/8 和 空间占用率少于1/16，两个条件组合在一起，保证缩小后的容量占用少于1/2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩小<code>weak_entry_t *weak_entries</code>容量的条件是目前的总长度超过了1024 和 容量占用了少于1/16，<code>weak_entries</code>空间缩小为当前空间的1/8</p>
<h4 id="weak-resize"><a href="#weak-resize" class="headerlink" title="weak_resize"></a>weak_resize</h4><p>扩大和缩小空间都会调用的weak_resize公共函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_resize(weak_table_t *weak_table, size_t new_size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// old_size = mask+1;表示原始哈希数组的总长度</span></span><br><span class="line">  size_t old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧weak_entries哈希数组的起始地址</span></span><br><span class="line">  weak_entry_t *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">  <span class="comment">// 为新 weak_entries 哈希数组申请指定长度的空间，并把起始地址返回</span></span><br><span class="line">  <span class="comment">// 内存空间大小为 new_size * sizeof(weak_entry_t)</span></span><br><span class="line">  weak_entry_t *new_entries = (weak_entry_t *)</span><br><span class="line">      calloc(new_size, <span class="keyword">sizeof</span>(weak_entry_t));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新mask,仍是new_size-1</span></span><br><span class="line">  weak_table-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 更新哈希数组起始地址</span></span><br><span class="line">  weak_table-&gt;weak_entries = new_entries;</span><br><span class="line">  <span class="comment">// 最大哈希冲突偏移值，默认为0</span></span><br><span class="line">  weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 当前哈希数组的占用数量，默认为0</span></span><br><span class="line">  weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有旧的weak_entry_t，需要放在新的空间内</span></span><br><span class="line">  <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">      weak_entry_t *entry;</span><br><span class="line">      weak_entry_t *end = old_entries + old_size;</span><br><span class="line">      <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">              weak_entry_insert(weak_table, entry);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      free(old_entries);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="weak-entry-insert"><a href="#weak-entry-insert" class="headerlink" title="weak_entry_insert"></a>weak_entry_insert</h4><p>将weak_entry_t<code>添加到</code>weak_table_t-&gt;weak_entries中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Add new_entry to the object&#39;s table of weak references.</span><br><span class="line"> * Does not check whether the referent is already in the table.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 添加一个新的weak_entry_t到对象的弱引用表中</span><br><span class="line">&#x2F;&#x2F; 不进行检查引用对象是否已存在表中</span><br><span class="line">static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 哈希数组的起始地址</span><br><span class="line">  weak_entry_t *weak_entries &#x3D; weak_table-&gt;weak_entries;</span><br><span class="line">  assert(weak_entries !&#x3D; nil);</span><br><span class="line">	&#x2F;&#x2F; 调用hash函数找到new_entry在weak_table_t的哈希数组中的位置，可能会发生hash冲突</span><br><span class="line">  size_t begin &#x3D; hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">  size_t index &#x3D; begin;</span><br><span class="line">  size_t hash_displacement &#x3D; 0;</span><br><span class="line">  while (weak_entries[index].referent !&#x3D; nil) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 如果发生hash冲突+1，继续往下探测</span><br><span class="line">      index &#x3D; (index+1) &amp; weak_table-&gt;mask;</span><br><span class="line">      &#x2F;&#x2F; 如果index每次+1加到值等于begin还是没有找到空位置，则触发bad_weak_table致命错误</span><br><span class="line">      if (index &#x3D;&#x3D; begin) bad_weak_table(weak_entries);</span><br><span class="line">      &#x2F;&#x2F; 记录偏移量 用于更新max_hash_displacement</span><br><span class="line">      hash_displacement++;</span><br><span class="line">  &#125;</span><br><span class="line">	&#x2F;&#x2F; new_entry放入哈希数组中</span><br><span class="line">  weak_entries[index] &#x3D; *new_entry;</span><br><span class="line">  &#x2F;&#x2F; 更新num_entries</span><br><span class="line">  weak_table-&gt;num_entries++;</span><br><span class="line">	&#x2F;&#x2F; 记录weak_table_t哈希数组中发生哈希冲突时的最大偏移量</span><br><span class="line">  if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">      weak_table-&gt;max_hash_displacement &#x3D; hash_displacement;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综合来看，weak_entry_insert函数可知weak_resize函数的整体左右，该函数对哈希数组进行的扩大和缩小，首先根据new_size申请相应大小的内存，new_entries指针指向这块新申请的内存。设置weak_table的mask为new_size-1。此处mask的作用是记录weak_table 总容量的内存边界，此外mask还用在哈希函数中保证index不会哈希数组越界。</p>
<p>​    weak_table_t的哈希数组可能会发生哈希碰撞，而weak_table_t采用了开放地址寻址法来处理碰撞。如果发生碰撞的话，将寻找相邻（如果已经到尾端的话，则从头开始）的下一个空位，例如weak_entry_for_referent函数，寻找给定的referent在弱引用表中的entry时，如果在循环过程中hash_displacement的值超过了weak_table-&gt;max_hash_displacement则表示，不存在要找的weak_entry_t</p>
<h4 id="weak-entry-for-referent"><a href="#weak-entry-for-referent" class="headerlink" title="weak_entry_for_referent"></a>weak_entry_for_referent</h4><blockquote>
<p>根据给定的referent 和 weak_table_t哈希表，查找其中的weak_entry_t并返回，如果未找到则返回NULL。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Return the weak reference table entry for the given referent. </span><br><span class="line"> * If there is no entry for referent, return NULL. </span><br><span class="line"> * Performs a lookup.</span><br><span class="line"> *</span><br><span class="line"> * @param weak_table </span><br><span class="line"> * @param referent The object. Must not be nil.</span><br><span class="line"> * </span><br><span class="line"> * @return The table of weak referrers to this object. </span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; weak_table通过&amp;SideTables()[referent]可从全局的SideTables中找到referent所处的weak_table</span><br><span class="line">static weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    assert(referent);</span><br><span class="line">		&#x2F;&#x2F; weak_table_t哈希数组的入口</span><br><span class="line">    weak_entry_t *weak_entries &#x3D; weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    if (!weak_entries) return nil;</span><br><span class="line"></span><br><span class="line">  	&#x2F;&#x2F; 哈希函数：hash_pointer函数返回值与mask做与，防止index越界</span><br><span class="line">    size_t begin &#x3D; hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index &#x3D; begin;</span><br><span class="line">    size_t hash_displacement &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 如果未发生哈希冲突的话，这weak_table-&gt;weak_entries[index]就是要找的weak_entry_t了</span><br><span class="line">    while (weak_table-&gt;weak_entries[index].referent !&#x3D; referent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果发生了哈希冲突 + 1，继续向下探测（开放地址寻址法）</span><br><span class="line">        index &#x3D; (index+1) &amp; weak_table-&gt;mask;</span><br><span class="line">        if (index &#x3D;&#x3D; begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        &#x2F;&#x2F; 记录探测偏移了多远</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        &#x2F;&#x2F; 如果探测偏移超过了 weak_table_t 的 max_hash_displacement，则说明weak_table中没有referent的weak_entry_t，则返回nil</span><br><span class="line">        if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Tagged-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Tagged-Pointer/" class="post-title-link" itemprop="url">内存管理-Tagged Pointer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-27 19:18:37" itemprop="dateCreated datePublished" datetime="2020-10-27T19:18:37+08:00">2020-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-28 17:32:55" itemprop="dateModified" datetime="2020-10-28T17:32:55+08:00">2020-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>苹果在iOS采用RC（引用计数器）进行内存管理，在MRC时代需要我们手动进行内存管理调用retain和release进行引用计数器+1和-1，iOS5之后苹果引入了ARC，通过LLVM和Runtime运行机制编译器自动帮忙添加上retain、release和autoreleasepool进行内存管理，大多数情况下我们已经不用在管理引用计数器问题。</p>
<p>但是为了了解系统内存管理的本质，需要我们通过源码去探究一下。</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>对象在内存中是对齐的，他们的地址总是指针的整数倍，通常为16倍数</p>
<p>通常情况下，对象、指针、NSInteger的内存占用都与当前CPU的位数有关，一个NSInteger类型的变量在32位下占4个字节，在64位下就会占用8个字节，指针也是，对象同理，同一个程序从32位机器上迁移到64位机器上，虽然逻辑没变化，但是内存占用上会翻倍，同时在效率上为了存储和访问一个NSNumber对象，我们需要在堆上为它分配内存维护引用计数器，管理它的生命周期，这都将造成运行效率上的损失。</p>
<h4 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h4><p>为了改进内存和效率上的问题，苹果引入了Tagged Pointer，由于NSNumber之类的变量本身的值需要占用的内存大小常常不需要8字节。所以我们可以将一个对象拆分为两个部分，一部分直接保存数据，一部分作为特殊标记，表示这是一个特别的指针不指向任何一个地址。</p>
<h3 id="Tagged-Pointer定义"><a href="#Tagged-Pointer定义" class="headerlink" title="Tagged Pointer定义"></a>Tagged Pointer定义</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if __LP64__</span><br><span class="line">#define OBJC_HAVE_TAGGED_POINTERS 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>64-bit，tag存储在LSB（Least Significant Bit最低位）。其他情况比如真机，tag存储在MSB（Most Significant Bit最高位）</p>
<ul>
<li><code>MacOS</code>下采用 LSB（Least Significant Bit，即最低有效位）为<code>Tagged Pointer</code>标识位；</li>
<li><code>iOS</code>下则采用 MSB（Most Significant Bit，即最高有效位）为<code>Tagged Pointer</code>标识位。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span><br><span class="line">    &#x2F;&#x2F; 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">    &#x2F;&#x2F; Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 1</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK 0xfUL</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>接下来是一个枚举定义，定义了默认使用了<code>Tagged Pointer</code>的类。例如NSString、NSNumber、NSIndexPath、NSDate</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">objc_tag_index_t</span> : <span class="keyword">uint16_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">objc_tag_index_t</span>;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 60-bit payloads</span></span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 60-bit reserved</span></span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 52-bit payloads</span></span><br><span class="line">    OBJC_TAG_Photos_1          = <span class="number">8</span>,</span><br><span class="line">    OBJC_TAG_Photos_2          = <span class="number">9</span>,</span><br><span class="line">    OBJC_TAG_Photos_3          = <span class="number">10</span>,</span><br><span class="line">    OBJC_TAG_Photos_4          = <span class="number">11</span>,</span><br><span class="line">    OBJC_TAG_XPC_1             = <span class="number">12</span>,</span><br><span class="line">    OBJC_TAG_XPC_2             = <span class="number">13</span>,</span><br><span class="line">    OBJC_TAG_XPC_3             = <span class="number">14</span>,</span><br><span class="line">    OBJC_TAG_XPC_4             = <span class="number">15</span>,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  &amp;&amp;  !defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">objc_tag_index_t</span> <span class="keyword">objc_tag_index_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><p>校验是否是<code>tagged pointer</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成一个<code>tagged pointer</code>，最高四位是tagged，余下是数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * _Nonnull</span><br><span class="line">_objc_makeTaggedPointer(<span class="keyword">objc_tag_index_t</span> tag, <span class="keyword">uintptr_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// PAYLOAD_LSHIFT and PAYLOAD_RSHIFT are the payload extraction shifts.</span></span><br><span class="line">    <span class="comment">// They are reversed here for payload insertion.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// assert(_objc_taggedPointersEnabled());</span></span><br><span class="line">    <span class="keyword">if</span> (tag &lt;= OBJC_TAG_Last60BitPayload) &#123;</span><br><span class="line">        <span class="comment">// assert(((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT) == value);</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> result =</span><br><span class="line">            (_OBJC_TAG_MASK | </span><br><span class="line">             ((<span class="keyword">uintptr_t</span>)tag &lt;&lt; _OBJC_TAG_INDEX_SHIFT) | </span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_LSHIFT));</span><br><span class="line">        <span class="keyword">return</span> _objc_encodeTaggedPointer(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// assert(tag &gt;= OBJC_TAG_First52BitPayload);</span></span><br><span class="line">        <span class="comment">// assert(tag &lt;= OBJC_TAG_Last52BitPayload);</span></span><br><span class="line">        <span class="comment">// assert(((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) == value);</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> result =</span><br><span class="line">            (_OBJC_TAG_EXT_MASK |</span><br><span class="line">             ((<span class="keyword">uintptr_t</span>)(tag - OBJC_TAG_First52BitPayload) &lt;&lt; _OBJC_TAG_EXT_INDEX_SHIFT) |</span><br><span class="line">             ((value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT));</span><br><span class="line">        <span class="keyword">return</span> _objc_encodeTaggedPointer(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Tagged Pointer中获取值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">objc_tag_index_t</span> </span><br><span class="line">_objc_getTaggedPointerTag(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    <span class="keyword">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">uintptr_t</span> extTag =   (value &gt;&gt; _OBJC_TAG_EXT_INDEX_SHIFT) &amp; _OBJC_TAG_EXT_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">objc_tag_index_t</span>)(extTag + OBJC_TAG_First52BitPayload);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">objc_tag_index_t</span>)basicTag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Tagged Pointer的引入，直接将值存储于指针本身，不旦减少了内存的占用，而且它不存在在堆中，也不需要malloc和free，还提高了运行效率。</p>
<p>我们也可以在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，看到苹果对于<code>Tagged Pointer</code>特点的介绍：</p>
<ul>
<li>Tagged Pointer专门用于存储小的对象，例如NSNumber、NSSting</li>
<li>Tagged Pointer的值不再是地址，而是真正的值，所以，它实际不再是一个对象，它只是一个披着对象皮的指针，所以它并不存储在堆中，也不需要malloc和free</li>
<li>在内存读取上有着3倍的速度，创建时也比之前快106倍</li>
</ul>
<h5 id="关闭tagged-pointer的数据混淆"><a href="#关闭tagged-pointer的数据混淆" class="headerlink" title="关闭tagged pointer的数据混淆"></a>关闭tagged pointer的数据混淆</h5><p>在现在的版本中，为了保证数据安全，苹果对tagged point做了数据混淆，开发者通过打印指针无法判断他是不是一个tagged pointer，更无法读取其存储的数据。</p>
<p>在分析tagged pointer之前，我们需要先把<code>tagged pointer</code>数据混淆关闭，以方便我们进行调试。通过设置环境变量<code>OBJC_DISABLE_TAG_OBFUSCATION</code>为<code>YES</code></p>
<h4 id="iOS应用举例"><a href="#iOS应用举例" class="headerlink" title="iOS应用举例"></a>iOS应用举例</h4><h5 id="NSNumber应用"><a href="#NSNumber应用" class="headerlink" title="NSNumber应用"></a>NSNumber应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *charNumber &#x3D; [NSNumber numberWithChar:&#39;1&#39;];</span><br><span class="line">NSNumber *shortNumber &#x3D; [NSNumber numberWithShort:1];</span><br><span class="line">NSNumber *intNumber &#x3D; [NSNumber numberWithInt:1];</span><br><span class="line">NSNumber *floatNumber &#x3D; [NSNumber numberWithFloat:1.0];</span><br><span class="line">NSNumber *longNumber &#x3D; [NSNumber numberWithLong:1];</span><br><span class="line">NSNumber *doubleNumber &#x3D; [NSNumber numberWithDouble:1.0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出变量的指针地址：</span><br><span class="line">&#x2F;&#x2F; charNumber 0xb000000000000310</span><br><span class="line">&#x2F;&#x2F; shortNumber 0xb000000000000011</span><br><span class="line">&#x2F;&#x2F; intNumber 0xb000000000000012</span><br><span class="line">&#x2F;&#x2F; floatNumber 0xb000000000000014</span><br><span class="line">&#x2F;&#x2F; longNumber 0xb000000000000013</span><br><span class="line">&#x2F;&#x2F; doubleNumber 0xb000000000000015</span><br></pre></td></tr></table></figure>

<p><img src="/Users/mikasa/Desktop/image_mark/image-20201028113927598.png" alt="image-20201028113927598"></p>
<p>规律都是以0xb(1011开头)</p>
<ul>
<li>最高位是1，说明指针是一个Tagged Pointer类型</li>
<li>第61-63位是11（十进制对应的是3），根据上诉枚举定义也就是（OBJC_TAG_NSNumber）</li>
<li>第1-4位是NSNumber类型，比如char是0 short是1，int是2，float是4，long是3，double是5</li>
<li>剩下56位就是真正的值了</li>
</ul>
<p><img src="/Users/mikasa/Desktop/image_mark/zufmtqnvbq.png" alt="zufmtqnvbq"></p>
<h5 id="NSString应用"><a href="#NSString应用" class="headerlink" title="NSString应用"></a>NSString应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 &#x3D; [NSString stringWithFormat:@&quot;a&quot;];</span><br><span class="line">NSString *str2 &#x3D; [NSString stringWithFormat:@&quot;ab&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出变量的指针地址：</span><br><span class="line">&#x2F;&#x2F; str1: 0xa000000000000611</span><br><span class="line">&#x2F;&#x2F; str2: 0xa000000000062612</span><br></pre></td></tr></table></figure>

<p><img src="/Users/mikasa/Desktop/image_mark/image-20201028114331053.png" alt="image-20201028114331053"></p>
<p>与NSNumber类似</p>
<ul>
<li>最高位是1，说明指针是一个Tagged Pointer类型</li>
<li>第61-63位是10（对应的十进制是2），根据上述枚举定义类型也就是OBJC_TAG_NSString</li>
<li>第1-4位是字符串长度</li>
<li>剩下的56位就是真正的值了</li>
</ul>
<p>进一步扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSString *a &#x3D; @&quot;a&quot;;</span><br><span class="line">NSMutableString *b &#x3D; [a mutableCopy];</span><br><span class="line">NSString *c &#x3D; [a copy];</span><br><span class="line">NSString *d &#x3D; [[a mutableCopy] copy];</span><br><span class="line">NSString *e &#x3D; [NSString stringWithString:a];</span><br><span class="line">NSString *f &#x3D; [NSString stringWithFormat:@&quot;f&quot;];</span><br><span class="line">NSString *string1 &#x3D; [NSString stringWithFormat:@&quot;abcdefg&quot;];</span><br><span class="line">NSString *string2 &#x3D; [NSString stringWithFormat:@&quot;abcdefghi&quot;];</span><br><span class="line">NSString *string3 &#x3D; [NSString stringWithFormat:@&quot;abcdefghij&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;* MacOS打印结果</span><br><span class="line">a: 0x100002038, __NSCFConstantString, 18446744073709551615</span><br><span class="line">b: 0x10071f3c0, __NSCFString, 1</span><br><span class="line">c: 0x100002038, __NSCFConstantString, 18446744073709551615</span><br><span class="line">d: 0x6115, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">e: 0x100002038, __NSCFConstantString, 18446744073709551615</span><br><span class="line">f: 0x6615, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">string1: 0x6766656463626175, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">string2: 0x880e28045a54195, NSTaggedPointerString, 18446744073709551615</span><br><span class="line">string3: 0x10071f6d0, __NSCFString, 1 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>从打印结果来看，有三种NSString类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__NSCFConstantString</td>
<td align="left">常量字符串，存储在字符串常量区，继承于 __NSCFString。相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例，可以通过 == 判断字符串内容是否相同。2. 这种对象一般通过字面值@”…”创建。如果使用 __NSCFConstantString 来初始化一个字符串，那么这个字符串也是相同的 __NSCFConstantString。</td>
</tr>
<tr>
<td align="left">__NSCFString</td>
<td align="left">存储在堆区，需要维护其引用计数，继承于 NSMutableString。2. 通过stringWithFormat:等方法创建的NSString对象（且字符串值过大无法使用Tagged Pointer存储）一般都是这种类型。</td>
</tr>
<tr>
<td align="left">NSTaggedPointerString</td>
<td align="left">Tagged Pointer，字符串的值直接存储在了指针上。</td>
</tr>
</tbody></table>
<p>打印结果分析：</p>
<table>
<thead>
<tr>
<th align="left">NSString 对象</th>
<th align="left">类型</th>
<th align="left">分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="left">__NSCFConstantString</td>
<td align="left">通过字面量@”…”创建</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">__NSCFString</td>
<td align="left">a 的深拷贝，指向不同的内存地址，被拷贝到堆区</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">__NSCFConstantString</td>
<td align="left">a 的浅拷贝，指向同一块内存地址</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">单独对 a 进行 copy（如 c），浅拷贝是指向同一块内存地址，所以不会产生Tagged Pointer；单独对 a 进行 mutableCopy（如 b），复制出来是可变对象，内容大小可以扩展；而Tagged Pointer存储的内容大小有限，因此无法满足可变对象的存储要求。</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">__NSCFConstantString</td>
<td align="left">使用 __NSCFConstantString 来初始化的字符串</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">通过stringWithFormat:方法创建，指针足够存储字符串的值。</td>
</tr>
<tr>
<td align="left">string1</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">通过stringWithFormat:方法创建，指针足够存储字符串的值。</td>
</tr>
<tr>
<td align="left">string2</td>
<td align="left">NSTaggedPointerString</td>
<td align="left">通过stringWithFormat:方法创建，指针足够存储字符串的值。</td>
</tr>
<tr>
<td align="left">string3</td>
<td align="left">__NSCFString</td>
<td align="left">通过stringWithFormat:方法创建，指针不足够存储字符串的值。</td>
</tr>
</tbody></table>
<p><img src="/Users/mikasa/Desktop/image_mark/cj0aj4o1ul.png" alt="cj0aj4o1ul"></p>
<p>在objc4源码中，我们经常会在函数中看见tagged pointer。比如objc_msgSend函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL _cmd, ...);</span><br><span class="line"> * IMP objc_msgLookup(id self, SEL _cmd, ...);</span><br><span class="line"> * </span><br><span class="line"> * objc_msgLookup ABI:</span><br><span class="line"> * IMP returned in x17</span><br><span class="line"> * x16 reserved for our use but not used</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">	.data</span><br><span class="line">	.align 3</span><br><span class="line">	.globl _objc_debug_taggedpointer_classes</span><br><span class="line">_objc_debug_taggedpointer_classes:</span><br><span class="line">	.fill 16, 8, 0</span><br><span class="line">	.globl _objc_debug_taggedpointer_ext_classes</span><br><span class="line">_objc_debug_taggedpointer_ext_classes:</span><br><span class="line">	.fill 256, 8, 0</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #0			// nil check and tagged pointer check</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br><span class="line">	ldr	p13, [x0]		// p13 = isa</span><br><span class="line">	GetClassFromIsa_p16 p13		// p16 = class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p><code>objc_msgSend</code>函数能够识别<code>tagged pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，不会进行<code>objc_msgSend</code>的三大流程，节省了调用开销。</p>
<p>内存管理相关，如<code>retain</code>方法中的<code>rootRetain</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行判断是否是tagged pointer伪对象</p>
<h4 id="Tagged-Pointer注意点"><a href="#Tagged-Pointer注意点" class="headerlink" title="Tagged Pointer注意点"></a>Tagged Pointer注意点</h4><p>前面知道，tagged pointer并不是真正的对象，它没有isa指针，所以直接访问tagged pointer的isa成员的话，在编译器就会出现警告。</p>
<p><strong>执行以下两段待会，会出现什么情况？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)mm_tagged_no_pointer &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            self.name &#x3D; [NSString stringWithFormat:@&quot;abcdefghi1&quot;];</span><br><span class="line">            NSLog(@&quot;%p---%@&quot;,self.name,[self.name class]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果，Crash</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mm_tagged_pointer &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abcdefghi"</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%p---%@"</span>,<span class="keyword">self</span>.name,[<span class="keyword">self</span>.name <span class="keyword">class</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果，正常</p>
<p>分别打印两段代码中的<code>self.name</code>，可以发现第一段代码中的<code>self.name</code>类型为<code>CFString</code> ，第二段代码中的类型为<code>NSTaggedPointerString</code>。</p>
<p><img src="/Users/mikasa/Desktop/image_mark/image-20201028161517267.png" alt="image-20201028161517267"></p>
<p>观察一下Crash崩溃函数调用信息，不难发现，在线程退出的时候，会对当前线程中的TSD数据（<code>Autoreleasepool</code>及放入其中的对象进行<code>release</code>），多条线程并发执行过程中，可能就会出现对一个对象多次调用<code>release</code>造成对象过度释放，导致Crash</p>
<p><strong>解决办法（保证多线程数据安全）：</strong></p>
<ul>
<li>使用atomic属性关键字</li>
<li>加锁</li>
<li>队列串行访问</li>
<li>信号量</li>
</ul>
<p>而第二段代码中的NSString类型为<code>NSTaggedPointerString</code>类型，在objc_release函数会判断是否是TaggedPointer类型，是的话就不会进行release操作，也就避免了因过度释放对象而导致的Crash。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dorisgit.github.io/2020/10/23/AutoreleasePool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doris AI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泡泡茶壶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/23/AutoreleasePool/" class="post-title-link" itemprop="url">AutoreleasePool</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-23 14:18:49" itemprop="dateCreated datePublished" datetime="2020-10-23T14:18:49+08:00">2020-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-26 17:24:32" itemprop="dateModified" datetime="2020-10-26T17:24:32+08:00">2020-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ARC和MRC下的autoreleasepool"><a href="#ARC和MRC下的autoreleasepool" class="headerlink" title="ARC和MRC下的autoreleasepool"></a>ARC和MRC下的autoreleasepool</h4><h5 id="MRC中的autoreleasepool"><a href="#MRC中的autoreleasepool" class="headerlink" title="MRC中的autoreleasepool"></a>MRC中的autoreleasepool</h5><p>在MRC环境下，当我们创建和释放一个对象时，需手动管理器内存周期，调用<code>retain</code> 和 <code>release</code>或autorelease方法来释放它。调用retain会让计数器+1，调用<code>release</code>会让计数器-1，当对象计数器为0时，就会被释放。调用<code>autorelease</code>的对象会被添加到自动释放池中，它会在一个合适的时候（下文）为对象调用<code>release</code>人，所以加入到<code>autorelease</code>中的对象会被延迟释放。</p>
<p><strong>release</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool1() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [[MMPerson alloc] init];</span><br><span class="line">        [person retain];</span><br><span class="line">        </span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">        [person release]</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person dealloc</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure>

<p><strong>autorelease</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool1() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [[[MMPerson alloc] init] autoreleasepool];</span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person</span><br><span class="line">person dealloc</span><br></pre></td></tr></table></figure>

<p>局部变量person调用release后会被立即释放，而将对象加入到autoreleasepool中不会立即释放，释放时机被延迟了。</p>
<h5 id="ARC中autoreleasepool"><a href="#ARC中autoreleasepool" class="headerlink" title="ARC中autoreleasepool"></a>ARC中autoreleasepool</h5><p>苹果在iOS5中引入了ARC（Automatic Reference Counting）自动引用计数器管理技术，通过LLVM编译器和Runtime机协作进行自动管理内存。LLVM会在编译时在合适的地方为OC对象插入retain、release和autoreleasepool代码。</p>
<p><strong>通过alloc、copy、mutableCopy和new方式创建对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool1() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [MMPerson new];</span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，对象出了作用域立即被释放了，编译时插入了release</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[20:53:54] -[MMPerson dealloc] [第22行] 💕 MMPerson dealloc</span><br><span class="line">[20:53:54] _addAutoReleasePool1 [第49行] 💕 (null)</span><br></pre></td></tr></table></figure>

<p><strong>通过系统提供工厂方法创建对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void _addAutoReleasePool2() &#123;</span><br><span class="line">    __weak MMPerson *person2 &#x3D; nil;</span><br><span class="line">    &#123;</span><br><span class="line">        MMPerson *person &#x3D; [MMPerson buttonWithType:UIButtonTypeSystem];</span><br><span class="line">        person2 &#x3D; person;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，对象超出了其作用域还是存在的，也就是说起内部调用了autorelease方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[20:53:54] _addAutoReleasePool2 [第58行] 💕 &lt;MMPerson: 0x7fdbad51fe90; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x6000002e6fc0&gt;&gt;</span><br><span class="line">[20:53:54] -[MMPerson dealloc] [第22行] 💕 MMPerson dealloc</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>以 <code>alloc</code>, <code>copy</code>, ,<code>mutableCopy</code>和<code>new</code>这些方法会被默认标记为 <code>__attribute((ns_returns_retained))</code> ，以这些方法创建的对象,编译器在会在调用方法外围要加上内存管理代码<code>retain/release</code>，所以其在作用域结束的时候就会释放，而不以这些关键字开头的方法，会被默认标记为<code>__attribute((ns_returns_not_retained))</code>,编译器会在方法内部自动加上<code>autorelease</code>方法，这时创建的对象就会被注册到自动释放池中，同时其释放会延迟，等到自动释放池销毁的时候才释放。</p>
<h4 id="main入口函数中的-autoreleasepool"><a href="#main入口函数中的-autoreleasepool" class="headerlink" title="main入口函数中的@autoreleasepool"></a>main入口函数中的@autoreleasepool</h4><p>我们先来看看Xcode11版本中的main()函数，与之前版本的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Xcode 11</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; Setup code that might create autoreleased objects goes here.</span><br><span class="line">        appDelegateClassName &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Xcode 旧版本</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的点是</strong>，Xcode11之前是将整个应用程序放在<code>@autoreleasepool</code>中，由于<code>runloop</code>的存在，要程序结束后<code>@autoreleasepool</code>作用域才会结束，这也意味着程序结束后<code>main</code>函数中的<code>@autoreleasepool</code>中的<code>autoreleasepool</code>对象才会释放</p>
<p>Xcode11之后，触发主线程的<code>UIApplicationMain</code>函数被放置在<code>@autoreleasepool</code>之外，这可以保证<code>@autoreleasepool</code>中的autoreleasepool对象在程序启动后可以被立即释放。</p>
<p><strong>网上对于<code>main()</code>函数中的<code>@autoreleasepool</code>有一种解释</strong>：</p>
<p>在iOS工程的<code>main()</code>函数中有一个<code>@autoreleasepool</code>，这个<code>@autoreleasepool</code>负责应用程序所有<code>autoreleasepool</code>对象的释放。</p>
<p><strong>这个解释是错误的</strong></p>
<p>如果你的程序使用了AppKit或UIKit框架，系统在主线程的<code>RunLoop</code>里注册了两个<code>Observer</code>，回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler</code> ，第一个<code>Observer</code>的状态是<code>activities=0x1</code>，第二个Observer的状态是<code>activities=0xa0</code></p>
<p><code>0x1</code>代表的是<code>kCFRunLoopEntry</code>，主线程的<code>runloop</code>就会在即将进入loop时，<code>Observe</code>监听的事件为Entry，其内部回调就会调用<code>_objc_autoreleasePoolPush()</code>创建一个自动释放池，优先级最高，保证创建自动释放池发生在其他所有回调之前</p>
<p><code>0xa0</code>代表的是<code>kCFRunLoopBeforeWaiting</code>和<code>kCFRunLoopExit</code>，在<code>kCFRunLoopBeforeWaiting</code>事件时调用<code>_objc_autoreleasePoolPop</code>和<code>_objc_autoreleasePoolPush</code>，释放旧的释放池和其中的资源并创建新的自动释放池；在<code>kCFRunLoopExit</code>事件时调用<code>_objc_autoreleasePoolPop</code>来释放自动释放池，同时这个<code>Observer</code>的优先级最低，保证其自动释放池的操作发生在其他回调之后.</p>
<p>也就是说主线程的runLoop会在每次事件循环迭代中创建并处理<code>@autoreleasepool</code>，而main函数中的<code>@autoreleasepool</code>只是管理他作用域中的对象。</p>
<p>以上场景与嵌套<code>@autoreleasepool</code>情况类似。</p>
<h4 id="嵌套-autoreleasepool"><a href="#嵌套-autoreleasepool" class="headerlink" title="嵌套@autoreleasepool"></a>嵌套<code>@autoreleasepool</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface MMPerson : UIButton</span><br><span class="line">@end</span><br><span class="line">@implementation MMPerson</span><br><span class="line">+ (instancetype)person &#123;</span><br><span class="line">    return [[MMPerson alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;MMPerson dealloc&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">NS_INLINE void _addAutoReleasePool() &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MMPerson *person &#x3D; [MMPerson person];</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            MMPerson *person1 &#x3D; person;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                MMPerson *person2 &#x3D; person;</span><br><span class="line">                NSLog(@&quot;current count %@&quot;,person);</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;current count 2%@&quot;,person);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;current count 3%@&quot;,person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[20:24:37] _addAutoReleasePool [第68行] 💕 current count 1&lt;MMPerson: 0x7ffe76d22460; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x60000224bce0&gt;&gt;</span><br><span class="line"></span><br><span class="line">[20:24:37] _addAutoReleasePool [第70行] 💕 current count 2&lt;MMPerson: 0x7ffe76d22460; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x60000224bce0&gt;&gt;</span><br><span class="line"></span><br><span class="line">[20:24:37] _addAutoReleasePool [第72行] 💕 current count 3&lt;MMPerson: 0x7ffe76d22460; baseClass &#x3D; UIButton; frame &#x3D; (0 0; 0 0); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x60000224bce0&gt;&gt;</span><br><span class="line"></span><br><span class="line">[20:24:37] -[MMPerson dealloc] [第22行] 💕 MMPerson dealloc</span><br></pre></td></tr></table></figure>

<p>对于多层嵌套而言，在<code>pop</code>的时候总会释放到上次<code>push</code>的位置为止，也就是哨兵位置，多层<code>pool</code>其实就是插入多个哨兵对象而已，然后根据哨兵对象来进行释放。</p>
<p><strong>注意：如果将一个对象加入到多个pool中</strong>，那么对象内层pool执行pop操作的时候就会被release释放掉，那么当调用<code>rootRelease()</code>的时候就会报错，因为当前对象已经被释放了，那么也就是说对于添加到pool中的对象只能被释放一次（同一个对象不能反复<code>autorelease</code>）</p>
<h4 id="Autoreleasepool的应用场景"><a href="#Autoreleasepool的应用场景" class="headerlink" title="Autoreleasepool的应用场景"></a>Autoreleasepool的应用场景</h4><p>AppKit和UIkit通常都会在RunLoop每次事件循环迭代中创建并处理<code>@autoreleasepool</code>，因此通常我们不必自己创建<code>@autoreleasepool</code>，但有些情况需要我们创建<code>@autoreleasepool</code></p>
<blockquote>
<p>苹果给出了三种需要手动添加<code>@autoreleasepool</code>的场景：</p>
<ul>
<li><p>如果你编写的应用程序不是基于UI框架的，比如说命令行工具</p>
</li>
<li><p>如果你编写的循环中创建了大量的临时对象；</p>
<p>你可以在循环中使用<code>@autoreleasepool</code>在下一次迭代之前处理这些对象，在循环中使用<code>@autoreleasepool</code>有助于减少应用程序的最大内存占用</p>
</li>
<li><p>如果你创建了辅助线程</p>
<p>一旦线程开始执行，就必须创建自己的<code>@autoreleasepool</code>；否则，你的应用程序将存在内存泄露</p>
</li>
</ul>
</blockquote>
<p>举个🌰</p>
<p>for循环中创建大量临时对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)mm_circulateMemory &#123;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100000000; i ++) &#123;</span><br><span class="line">        NSString * str &#x3D; [NSString stringWithFormat:@&quot;no_AutoReleasePool&quot;];</span><br><span class="line">        NSString *tempstr &#x3D; str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/Users/mikasa/Desktop/image_mark/image-20201026171701138.png" alt="image-20201026171701138" style="zoom:50%;" />

<p>for循环中使用<code>@autoreleasepool</code>处理临时对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (void)mm_circulateMemory_autorelease &#123;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100000000; i ++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSString * str &#x3D; [NSString stringWithFormat:@&quot;have_AutoReleasePool&quot;];</span><br><span class="line">            NSString *tempstr &#x3D; str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Users/mikasa/Desktop/image_mark/image-20201026172111999.png" alt="image-20201026172111999"></p>
<p>使用<code>@autoreleasepool</code>进行处理临时对象后，内存没有明显变化。</p>
<h4 id="线程私有数据（TSD）"><a href="#线程私有数据（TSD）" class="headerlink" title="线程私有数据（TSD）"></a>线程私有数据（TSD）</h4><p>​        线程私有数据（Thread-Specific Data 或 TSD）。</p>
<p>​        在单线程中，我们经常用到全局变量来实现多个函数间数据共享，然而在多线程环境中，由于数据空间是共享的，全局变量也为多个线程多共享。但有时应用程序需要“线程私有的全局变量，仅在单个线程有效，但是却可以跨多个函数访问”，POSIX线程库，听过维护一定的数据结构来解决这个问题，线程私有数据TSD</p>
<h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>​        首先创建允许所有线程访问的全局变量key，然后在任意一个线程中调用pthread_key_create接口创建所有线程有可见的线程特定数据的键值key，但是这个键值所指向的真实数据却是不同，它并不指向同一块内存，而是指向的属于自己数据，更改线程0的key中所指向的数据，并不会影响线程1key中所指向的数据。</p>
<p>​        各个子线程可以通过pthread_setspecific 和 get_specific接口使用这个key来获取和存储数据，每个线程的操作都在自己的私有线程数据中完成。</p>
<h5 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h5><p><strong>创建TSD</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">init <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span>(*destr_function)(<span class="keyword">void</span> *))</span></span></span><br></pre></td></tr></table></figure>

<p>一个进程被启动后，多个线程被创建，当其中一个线程调用函数<code>pthread_key_create</code>，TSD分配一项空间，并将其赋值为key，系统在key结构数据中找到第一个未使用的元素，将其索引返回给调用者。</p>
<p>如果destr_function不为空，在线程退出（pthread_exit()）时，将以key所关联的数据为参数调用<code>destr_function()</code>，以释放分配的缓冲区。</p>
<p>无论哪个线程调用pthread_key_create获取的tsd数据区都是所有线程可访问的，各个线程可根据需要存储不同的数据。</p>
<p><strong>注销TSD</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span></span><br></pre></td></tr></table></figure>

<p>函数<code>pthread_key_delete</code>并不会检查当前是否有线程正使用TSD，也不会调清理函数（destr_function），而只是将TSD释放以供下一次调用pthread_key_create使用。</p>
<p><strong>读写TSD</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthreat_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *pointer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span></span><br></pre></td></tr></table></figure>

<p>写入pthread_setspecific()时，将pointer的值（不是所指内容）与key相关联，而相应的读出函数则将与key相关联的数据读出来。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://woniuxiang.space/blog/post/lightime/多线程（pthreads）" target="_blank" rel="noopener">多线程（pthread）</a></p>
<p><a href="https://juejin.im/post/6844904094503567368#heading-21" target="_blank" rel="noopener">iOS - 聊聊 autorelease 和 @autoreleasepool</a></p>
<p><a href="https://juejin.im/post/6844903971405086734#heading-13" target="_blank" rel="noopener">Autorelease &amp; AutoreleasePool</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doris AI</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doris AI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
